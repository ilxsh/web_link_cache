<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="Content-Language" content="zh-CN"><title>systemctl
  中文手册 [金步国]</title><style>
@font-face { font-family: "JinBuGuoWebMono"; src: url("/d/mono.ttf") format("truetype"); }
* { font-family: "JinBuGuoWebMono", "Ubuntu Mono", "Consolas", "Menlo", monospace; }
body { margin:10px; }
h1 { text-align:center; background:#ddd; }
h2#auth_name { text-align:center; margin: 10px 5%; }

    a.headerlink {
      color: #c60f0f;
      font-size: 0.8em;
      padding: 0 4px 0 4px;
      text-decoration: none;
      visibility: hidden;
    }

    a.headerlink:hover {
      background-color: #c60f0f;
      color: white;
    }

    h1:hover > a.headerlink, h2:hover > a.headerlink, h3:hover > a.headerlink, dt:hover > a.headerlink {
      visibility: visible;
    }
</style><script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?d286c55b63a3c54a1e43d10d4c203e75"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><h1>systemctl 中文手册</h1><h2 id="auth_name">译者：<strong><a href="http://www.jinbuguo.com/">金步国</a></strong></h2><hr><h3>版权声明</h3><p>本文译者是一位开源理念的坚定支持者，所以本文虽然不是软件，但是遵照开源的精神发布。</p><ul><li>无担保：本文译者不保证译文内容准确无误，亦不承担任何由于使用此文档所导致的损失。</li><li>自由使用：任何人都可以自由的<u>阅读/链接/打印</u>此文档，无需任何附加条件。</li><li>名誉权：任何人都可以自由的<u>转载/引用/再创作</u>此文档，但必须保留译者署名并注明出处。</li></ul><h3>其他作品</h3><p>本文译者十分愿意与他人分享劳动成果，如果你对我的其他翻译作品或者技术文章有兴趣，可以在如下位置查看现有的作品集：</p><ul><li><a href="http://www.jinbuguo.com/">金步国作品集</a> [ <a href="http://www.jinbuguo.com/">http://www.jinbuguo.com/</a> ]</li></ul><h3>联系方式</h3><p>由于译者水平有限，因此不能保证译文内容准确无误。如果你发现了译文中的错误(哪怕是错别字也好)，请来信指出，任何提高译文质量的建议我都将虚心接纳。</p><ul><li>Email(QQ)：70171448在QQ邮箱</li></ul><hr><a href="systemd.index.html">手册索引</a> .
  <a href="systemd.directives.html">指令索引</a><span style="float:right">systemd-235</span><hr><div class="refentry"><a name="systemctl"></a><div class="titlepage"></div><div class="refnamediv"><h2>名称</h2><p>systemctl — 控制 systemd 系统与服务管理器</p></div><div class="refsynopsisdiv"><h2>大纲</h2><div class="cmdsynopsis"><p><code class="command">systemctl</code>  [OPTIONS...]  COMMAND  [NAME...]</p></div></div><div class="refsect1"><a name="id-1.5"></a><h2 id="描述">描述<a class="headerlink" title="Permalink to this headline" href="#%E6%8F%8F%E8%BF%B0">¶</a></h2><p>
    <span class="command"><strong>systemctl</strong></span>
    可用于检查和控制
    <a href="systemd.html#"><span class="citerefentry"><span class="refentrytitle">systemd</span>(1)</span></a>
    系统与服务管理器的状态。
    </p></div><div class="refsect1"><a name="id-1.6"></a><h2 id="选项">选项<a class="headerlink" title="Permalink to this headline" href="#%E9%80%89%E9%A1%B9">¶</a></h2><p>能够识别的命令行选项如下：</p><div class="variablelist"><dl class="variablelist"><dt id="-t"><span class="term"><code class="option">-t</code>, </span><span class="term"><code class="option">--type=</code></span><a class="headerlink" title="Permalink to this term" href="#-t">¶</a></dt><dd><p>
          参数必须是一个
          逗号分隔的单元类型列表(例如"service,socket")。
          </p><p>在列出单元时，如果使用了此选项，
          那么表示只列出指定类型的单元，
          否则将列出所有类型的单元。</p><p>此外，作为特例，使用
          <code class="option">--type=help</code>
          表示在列出所有可用的单元类型之后退出。</p></dd><dt id="--state="><span class="term"><code class="option">--state=</code></span><a class="headerlink" title="Permalink to this term" href="#--state=">¶</a></dt><dd><p>参数必须是一个逗号分隔的单元状态列表(只有 LOAD, ACTIVE, SUB 三大类)。
          在列出单元时，如果使用了此选项，那么表示只列出处于指定状态的单元，
          否则将列出所有状态的单元。
          例如，使用 <code class="option">--state=failed</code> 表示只列出处于失败(failed)状态的单元。</p><p>此外，作为特例，使用
          <code class="option">--state=help</code>
          表示在列出所有可用的单元状态之后退出。</p></dd><dt id="-p"><span class="term"><code class="option">-p</code>, </span><span class="term"><code class="option">--property=</code></span><a class="headerlink" title="Permalink to this term" href="#-p">¶</a></dt><dd><p>
          参数必须是一个逗号分隔的属性名称列表(例如"MainPID,LogLevel")，
          表示在使用 <span class="command"><strong>show</strong></span> 命令显示属性时，
          仅显示参数中列出的属性。
          如果未指定此选项，那么将显示全部属性。
          如果多次指定此选项，
          那么相当于将这些选项的参数用逗号连接起来。
          </p><p>不带参数的
          <span class="command"><strong>systemctl show</strong></span> 命令
          将会显示管理器(systemd)自身的属性(参见
          <a href="systemd-system.conf.html#"><span class="citerefentry"><span class="refentrytitle">systemd-system.conf</span>(5)</span></a> 手册)。
          </p><p>
          不同类型的单元拥有不同的属性集，
          指定任意一个单元(即使并不存在)，都可以查看此类单元的所有属性。
          类似的，即使指定了一个不存在的任务(job)，也能查看任务的所有属性。
          每种单元能够拥有的属性集分散在
          <a href="systemd.unit.html#"><span class="citerefentry"><span class="refentrytitle">systemd.unit</span>(5)</span></a> 手册
          以及此类单元专属的手册中，例如
          <a href="systemd.service.html#"><span class="citerefentry"><span class="refentrytitle">systemd.service</span>(5)</span></a>,
          <a href="systemd.socket.html#"><span class="citerefentry"><span class="refentrytitle">systemd.socket</span>(5)</span></a> 等等。
          </p></dd><dt id="-a"><span class="term"><code class="option">-a</code>, </span><span class="term"><code class="option">--all</code></span><a class="headerlink" title="Permalink to this term" href="#-a">¶</a></dt><dd><p>在列出单元时，表示列出所有已加载的单元(不管它处于何种状态)。
          在使用 <span class="command"><strong>show</strong></span> 命令显示属性时，
          表示显示所有属性，而不管这些属性是否已被设置。</p><p>如果想要列出所有已安装的单元，请使用
          <span class="command"><strong>list-unit-files</strong></span> 命令。</p><p>在使用 <span class="command"><strong>list-dependencies</strong></span> 命令时，
          表示递归的显示所有单元的依赖关系(默认仅显示 target 单元的依赖关系)
          </p></dd><dt id="-r"><span class="term"><code class="option">-r</code>, </span><span class="term"><code class="option">--recursive</code></span><a class="headerlink" title="Permalink to this term" href="#-r">¶</a></dt><dd><p>在列出单元时，
          同时也以
          "<code class="literal">容器名:单元名</code>"
          格式列出本地容器中的单元。</p></dd><dt id="--reverse"><span class="term"><code class="option">--reverse</code></span><a class="headerlink" title="Permalink to this term" href="#--reverse">¶</a></dt><dd><p>在使用 <span class="command"><strong>list-dependencies</strong></span> 命令时，
          仅显示单元之间的反向依赖关系。
          也就是仅显示 <code class="varname">WantedBy=</code>,
          <code class="varname">RequiredBy=</code>,
          <code class="varname">PartOf=</code>, <code class="varname">BoundBy=</code>
          系列(而不是 <code class="varname">Wants=</code> 系列)的依赖关系。
          </p></dd><dt id="--after"><span class="term"><code class="option">--after</code></span><a class="headerlink" title="Permalink to this term" href="#--after">¶</a></dt><dd><p>
          在使用 <span class="command"><strong>list-dependencies</strong></span> 命令时，
          仅显示在先后顺序上早于指定单元的那些单元，
          也就是递归的列出 <code class="varname">After=</code> 中的单元。</p><p>注意，每个 <code class="varname">After=</code>
          依赖都会自动生成一个对应的
          <code class="varname">Before=</code> 依赖。
          单元之间的先后顺序既可以被显式的明确设定，
          也可以由其他指令隐式的自动生成(例如
          <code class="varname">WantedBy=</code>
          或
          <code class="varname">RequiresMountsFor=</code>)。
          无论是隐式自动生成的先后顺序，
          还是显式明确设定的先后顺序，
          都会被 <span class="command"><strong>list-dependencies</strong></span> 命令显示出来。</p><p>在使用 <span class="command"><strong>list-jobs</strong></span> 命令时，同时显示正在等待该任务完成的其他任务。
          可以与 <code class="option">--before</code> 一起使用，同时显示等待该任务完成的其他任务，
          以及该任务正在等待的其他任务。</p></dd><dt id="--before"><span class="term"><code class="option">--before</code></span><a class="headerlink" title="Permalink to this term" href="#--before">¶</a></dt><dd><p>在使用 <span class="command"><strong>list-dependencies</strong></span> 命令时，
          仅显示在先后顺序上晚于指定单元的那些单元，
          也就是递归的列出
          <code class="varname">Before=</code> 中的单元。</p><p>在使用 <span class="command"><strong>list-jobs</strong></span> 命令时，同时显示该任务正在等待的其他任务。
          可以与 <code class="option">--after</code> 一起使用，同时显示等待该任务完成的其他任务，
          以及该任务正在等待的其他任务。</p></dd><dt id="-l"><span class="term"><code class="option">-l</code>, </span><span class="term"><code class="option">--full</code></span><a class="headerlink" title="Permalink to this term" href="#-l">¶</a></dt><dd><p>在 <span class="command"><strong>status</strong></span>, <span class="command"><strong>list-units</strong></span>,
          <span class="command"><strong>list-jobs</strong></span>,
          <span class="command"><strong>list-timers</strong></span> 命令的输出中，
          显示完整的单元名称、进程树项目、日志输出、单元描述，
          也就是不省略或截断它们。</p><p>在 <span class="command"><strong>is-enabled</strong></span> 命令的输出中显示所安装的 target 单元。
          </p></dd><dt id="--value"><span class="term"><code class="option">--value</code></span><a class="headerlink" title="Permalink to this term" href="#--value">¶</a></dt><dd><p>在使用 <span class="command"><strong>show</strong></span> 命令显示属性时，
          仅显示属性值，而不显示属性名及等号。
          </p></dd><dt id="--show-types"><span class="term"><code class="option">--show-types</code></span><a class="headerlink" title="Permalink to this term" href="#--show-types">¶</a></dt><dd><p>在使用 <span class="command"><strong>list-sockets</strong></span> 命令列出套接字(socket)时，同时显示套接字的类型。</p></dd><dt id="--job-mode="><span class="term"><code class="option">--job-mode=</code></span><a class="headerlink" title="Permalink to this term" href="#--job-mode=">¶</a></dt><dd><p>在向任务队列中添加新任务(job)时，如何处理队列中已有的任务。
        可设为 "<code class="literal">fail</code>",
        "<code class="literal">replace</code>",
        "<code class="literal">replace-irreversibly</code>",
        "<code class="literal">isolate</code>",
        "<code class="literal">ignore-dependencies</code>",
        "<code class="literal">ignore-requirements</code>",
        "<code class="literal">flush</code>" 之一。
        仅在使用 <span class="command"><strong>isolate</strong></span> 命令时，默认值为 "<code class="literal">isolate</code>" 且不能更改，
        对于其他命令，默认值皆为 "<code class="literal">replace</code>" 。
        </p><p> "<code class="literal">fail</code>"
        表示当新任务与队列中已有的任务冲突时，该命令将失败。
        所谓"冲突"的含义是：导致队列中已有的某个启动操作转变为停止操作，或者相反。
        </p><p> "<code class="literal">replace</code>"
        表示将队列中冲突的任务替换为新任务。
        </p><p> "<code class="literal">replace-irreversibly</code>"
        与 "<code class="literal">replace</code>" 类似，
        不同之处在于将新任务同时标记为"不可撤销"，
        也就是即使未来与其他新添加的任务发生冲突也不会被撤消。
        注意，这个"不可撤销"的任务，
        仍然可以使用 <span class="command"><strong>cancel</strong></span> 命令显式的撤消。
        应该将此模式应用于所有包含在
         <code class="filename">shutdown.target</code> 中的任务。</p><p> "<code class="literal">isolate</code>"
        仅用于启动操作，表示在该单元启动之后，所有其他单元都会被停止。
        当使用 <span class="command"><strong>isolate</strong></span> 命令的时候，
        这是默认值，且不能更改。</p><p> "<code class="literal">flush</code>"
        表示撤消队列中已有的全部任务，然后加入新任务。</p><p> "<code class="literal">ignore-dependencies</code>"
        表示忽略新任务的所有依赖关系(包括先后顺序依赖)，
        立即执行请求的操作。
        如果成功，
        那么所有被依赖的单元及先后顺序都将被忽略。
        仅用于调试目的，切勿用于常规目的。
        </p><p> "<code class="literal">ignore-requirements</code>"
        类似于 "<code class="literal">ignore-dependencies</code>" ，
        表示仅忽略必需的依赖(但依然遵守单元之间的先后顺序)。
        </p></dd><dt id="--fail"><span class="term"><code class="option">--fail</code></span><a class="headerlink" title="Permalink to this term" href="#--fail">¶</a></dt><dd><p>这是 <code class="option">--job-mode=fail</code> 的快捷方式。</p><p>当与 <span class="command"><strong>kill</strong></span> 命令一起使用时，
          表示如果没有任何单元被杀死，那么将会导致报错。
          </p></dd><dt id="-i"><span class="term"><code class="option">-i</code>, </span><span class="term"><code class="option">--ignore-inhibitors</code></span><a class="headerlink" title="Permalink to this term" href="#-i">¶</a></dt><dd><p>
          当关闭或休眠系统时，忽略 inhibitor 锁。
          应用程序可以利用 inhibitor 锁防止某些重要操作(例如刻录光盘)被关机或休眠打断。
          任何用户都可以获取 inhibitor 锁，
          但是只有特权用户可以撤消或者忽略它。
          正常情况下，
          关机与休眠动作会因为 inhibitor 锁的存在而失败(无论该动作是否由特权用户发起)，
          同时所有已激活的 inhibitor 锁也都会被显示出来。
          但如果使用了此选项，
          那么 inhibitor 锁将被忽略，关机或休眠将会照常执行，
          同时也不再显示这些已激活的锁。
          </p></dd><dt id="-q"><span class="term"><code class="option">-q</code>, </span><span class="term"><code class="option">--quiet</code></span><a class="headerlink" title="Permalink to this term" href="#-q">¶</a></dt><dd><p>
          安静模式，也就是禁止输出任何信息到标准输出。
          注意：(1)这并不适用于输出信息是唯一结果的命令(例如 <span class="command"><strong>show</strong></span>)；
          (2)显示在标准错误上的出错信息永远不会被屏蔽。
          </p></dd><dt id="--no-block"><span class="term"><code class="option">--no-block</code></span><a class="headerlink" title="Permalink to this term" href="#--no-block">¶</a></dt><dd><p>
          默认为阻塞模式，也就是任务经过校验、排入任务队列之后，
          <span class="command"><strong>systemctl</strong></span> 必须一直等到单元启动/停止完成才算执行结束。
          使用此选项之后，将变为无阻塞模式，也就是任务排入队列之后，
          即算 <span class="command"><strong>systemctl</strong></span> 执行结束(不必等待单元启动/停止完成)。
          此选项不可与 <code class="option">--wait</code> 一起使用。</p></dd><dt id="--wait"><span class="term"><code class="option">--wait</code></span><a class="headerlink" title="Permalink to this term" href="#--wait">¶</a></dt><dd><p>一直等待到被启动的单元再次终止为止。
          此选项不可与 <code class="option">--no-block</code> 一起使用。
          注意，如果某个给出的单元一直不终止，那么将会导致无限等待，
          特别是那些使用了
           "<code class="literal">RemainAfterExit=yes</code>" 的服务单元。</p></dd><dt id="--user"><span class="term"><code class="option">--user</code></span><a class="headerlink" title="Permalink to this term" href="#--user">¶</a></dt><dd><p><a name="user-text"></a>与当前调用用户的用户服务管理器(systemd 用户实例)通信，
      而不是默认的系统服务管理器(systemd 系统实例)。</p></dd><dt id="--system"><span class="term"><code class="option">--system</code></span><a class="headerlink" title="Permalink to this term" href="#--system">¶</a></dt><dd><p><a name="system-text"></a>与系统服务管理器(systemd 系统实例)通信，
      这是默认值。</p></dd><dt id="--failed"><span class="term"><code class="option">--failed</code></span><a class="headerlink" title="Permalink to this term" href="#--failed">¶</a></dt><dd><p>列出处于失败(failed)状态的单元。等价于
          <code class="option">--state=failed</code></p></dd><dt id="--no-wall"><span class="term"><code class="option">--no-wall</code></span><a class="headerlink" title="Permalink to this term" href="#--no-wall">¶</a></dt><dd><p>在执行 halt, poweroff, reboot 动作前，不发送警告消息。</p></dd><dt id="--global"><span class="term"><code class="option">--global</code></span><a class="headerlink" title="Permalink to this term" href="#--global">¶</a></dt><dd><p>
          表示在全局用户单元目录(通常是 <code class="filename">/etc/systemd/user/</code>)上操作，
          从而全局的操作一个用户单元，这会影响到所有未来登入的用户。
          </p></dd><dt id="--no-reload"><span class="term"><code class="option">--no-reload</code></span><a class="headerlink" title="Permalink to this term" href="#--no-reload">¶</a></dt><dd><p>与 <span class="command"><strong>enable</strong></span>, <span class="command"><strong>disable</strong></span>, <span class="command"><strong>edit</strong></span> 命令连用，
          表示在完成操作之后不重新加载 systemd 守护进程的配置(默认会自动重新加载)，
          相当于不自动执行 <span class="command"><strong>daemon-reload</strong></span> 命令。</p></dd><dt id="--no-ask-password"><span class="term"><code class="option">--no-ask-password</code></span><a class="headerlink" title="Permalink to this term" href="#--no-ask-password">¶</a></dt><dd><p>
          与 <span class="command"><strong>start</strong></span>
          及其相关命令(reload, restart, try-restart, reload-or-restart, reload-or-try-restart, isolate)连用，
          表示不询问密码。
          单元在启动时可能要求输入密码(例如用于解密证书或挂载加密文件系统)。
          当未使用此选项时，
          <span class="command"><strong>systemctl</strong></span> 将会在终端上向用户询问所需的密码。
          如果使用了此选项，
          那么必须通过其他方法提供密码(例如通过密码代理程序)，
          否则单元可能会启动失败。
          使用此选项还会导致在验证用户身份时，
          不能使用从终端输入密码的方式。
          </p></dd><dt id="--kill-who="><span class="term"><code class="option">--kill-who=</code></span><a class="headerlink" title="Permalink to this term" href="#--kill-who=">¶</a></dt><dd><p>
          与 <span class="command"><strong>kill</strong></span> 命令连用，
          表示向哪个进程发送信号(<code class="option">--signal=</code>)。
          可设为 <code class="option">main</code>(仅杀死主进程)
          或 <code class="option">control</code>(仅杀死控制进程)
          或 <code class="option">all</code>(杀死全部进程，这是默认值)。
          所谓"主进程"是指定义了单元生存期的进程。
          所谓"控制进程"是指用于改变单元状态的进程。
          例如，所有
          <code class="varname">ExecStartPre=</code>,
          <code class="varname">ExecStop=</code>,
          <code class="varname">ExecReload=</code>
          启动的进程都是控制进程。
          注意，对于一个单元来说，同一时刻只能存在一个控制进程，
          因为同一时刻只能存在一个状态变化的动作。
          对于 <code class="varname">Type=forking</code> 类型的服务来说，
          <code class="varname">ExecStart=</code>
          启动的初始进程就是一个控制进程，
          而此进程随后派生出来作为守护进程运行的那个进程，
          则是该单元的主进程(如果它可以被检测到的话)。
          但对于其他类型的服务来说，
          <code class="varname">ExecStart=</code>
          启动的初始进程反而始终是该服务的主进程。
          一个服务单元可以包含以下进程：
          零个或一个主进程，零个或一个控制进程，
          任意数量(可以是零个)的其他进程。
          注意，不是所有类型的单元都含有上述三种进程。
          例如，对于 mount 类型的单元来说，
          就仅有控制进程(<code class="filename">/usr/bin/mount</code> 与 <code class="filename">/usr/bin/umount</code>)，
          而没有主进程。
          默认值是 <code class="option">all</code></p></dd><dt id="-s"><span class="term"><code class="option">-s</code>, </span><span class="term"><code class="option">--signal=</code></span><a class="headerlink" title="Permalink to this term" href="#-s">¶</a></dt><dd><p>与 <span class="command"><strong>kill</strong></span> 命令连用，
          表示向目标进程发送哪个信号。
          必须是 <code class="constant">SIGTERM</code>, <code class="constant">SIGINT</code>, <code class="constant">SIGSTOP</code>
          之类众所周知的信号。
          默认值为 <code class="option">SIGTERM</code></p> 。
        </dd><dt id="-f"><span class="term"><code class="option">-f</code>, </span><span class="term"><code class="option">--force</code></span><a class="headerlink" title="Permalink to this term" href="#-f">¶</a></dt><dd><p>当与 <span class="command"><strong>enable</strong></span> 命令连用时，
          表示覆盖所有现存的同名符号链接。</p><p>当与 <span class="command"><strong>edit</strong></span> 命令连用时，
          表示创建所有尚不存在的指定单元。</p><p>当与 <span class="command"><strong>halt</strong></span>, <span class="command"><strong>poweroff</strong></span>, <span class="command"><strong>reboot</strong></span>,
          <span class="command"><strong>kexec</strong></span> 命令连用时，表示跳过单元的正常停止步骤，强制直接执行关机操作。
          如果仅使用此选项一次，那么所有进程都将被强制杀死，并且所有文件系统都将被卸载(或以只读模式重新挂载)。
          这可以算是一种野蛮但还算相对比较安全的快速关机或重启的方法。
          如果连续两次使用此选项，那么将既不杀死进程，也不卸载文件系统，
          而是直接强制关机或重启(但 <span class="command"><strong>kexec</strong></span> 除外)。
          警告：连续两次使用 <code class="option">--force</code> 选项将会导致数据丢失、文件系统不一致等不良后果。
          注意，如果连续两次使用 <code class="option">--force</code> 选项，那么所有操作都将由 <span class="command"><strong>systemctl</strong></span> 自己直接执行，而不会与 systemd 进程通信。
          这意味着，即使 systemd 进程已经崩溃，连续两次使用 <code class="option">--force</code> 选项所指定的操作依然能够执行成功。
          </p></dd><dt id="--message="><span class="term"><code class="option">--message=</code></span><a class="headerlink" title="Permalink to this term" href="#--message=">¶</a></dt><dd><p>当与 <span class="command"><strong>halt</strong></span>, <span class="command"><strong>poweroff</strong></span>, <span class="command"><strong>reboot</strong></span>
          命令一起使用时，用于设置一个解释为什么进行该操作的字符串。
          此字符串将与默认的关机消息一起记录到日志中。</p></dd><dt id="--now"><span class="term"><code class="option">--now</code></span><a class="headerlink" title="Permalink to this term" href="#--now">¶</a></dt><dd><p>当与 <span class="command"><strong>enable</strong></span> 命令连用时，
          表示同时还要启动该单元。
          当与 <span class="command"><strong>disable</strong></span> 或
          <span class="command"><strong>mask</strong></span> 命令连用时，
          表示同时还要停止该单元。</p></dd><dt id="--root="><span class="term"><code class="option">--root=</code></span><a class="headerlink" title="Permalink to this term" href="#--root=">¶</a></dt><dd><p>与
          <span class="command"><strong>enable</strong></span>/<span class="command"><strong>disable</strong></span>/<span class="command"><strong>is-enabled</strong></span>
          等相关命令连用，用于设置寻找单元文件时的根目录。
          使用此选项之后，<span class="command"><strong>systemctl</strong></span> 将会直接操作文件系统，
          而不是通过与 <span class="command"><strong>systemd</strong></span>
          守护进程通信的方式进行操作。</p></dd><dt id="--runtime"><span class="term"><code class="option">--runtime</code></span><a class="headerlink" title="Permalink to this term" href="#--runtime">¶</a></dt><dd><p>
          当与 <span class="command"><strong>enable</strong></span>,
          <span class="command"><strong>disable</strong></span>, <span class="command"><strong>edit</strong></span>
          等相关命令连用时，
          表示仅作临时变更，从而确保这些变更会在重启后丢失。
          这意味着所做的变更将会保存在 <code class="filename">/run</code> 目录下(立即生效但重启后该目录的内容将全部丢失)，
          而不是保存在 <code class="filename">/etc</code> 目录下。
          </p><p>类似的，当与
          <span class="command"><strong>set-property</strong></span> 命令连用时，
          所做的变更亦是临时的，
          这些变更在重启后亦会丢失。</p></dd><dt id="--preset-mode="><span class="term"><code class="option">--preset-mode=</code></span><a class="headerlink" title="Permalink to this term" href="#--preset-mode=">¶</a></dt><dd><p>与
          <span class="command"><strong>preset</strong></span> 或 <span class="command"><strong>preset-all</strong></span>
          命令连用，可设为下列值之一：
          "<code class="literal">full</code>"(默认值) 表示完全按照预设规则启用与停用各单元。
          "<code class="literal">enable-only</code>" 表示仅按照预设规则启用各单元。
          "<code class="literal">disable-only</code>" 表示仅按照预设规则停用各单元。
          </p></dd><dt id="-n"><span class="term"><code class="option">-n</code>, </span><span class="term"><code class="option">--lines=</code></span><a class="headerlink" title="Permalink to this term" href="#-n">¶</a></dt><dd><p>与 <span class="command"><strong>status</strong></span> 命令连用，
          控制日志的显示行数(从最新的一行开始计算)。
          必须设为一个正整数，默认值是"10"。
          </p></dd><dt id="-o"><span class="term"><code class="option">-o</code>, </span><span class="term"><code class="option">--output=</code></span><a class="headerlink" title="Permalink to this term" href="#-o">¶</a></dt><dd><p>与 <span class="command"><strong>status</strong></span> 命令连用，
          控制日志的显示格式。
          详见
          <a href="journalctl.html#"><span class="citerefentry"><span class="refentrytitle">journalctl</span>(1)</span></a>
          手册。默认值为 "<code class="literal">short</code>"</p> 。
        </dd><dt id="--firmware-setup"><span class="term"><code class="option">--firmware-setup</code></span><a class="headerlink" title="Permalink to this term" href="#--firmware-setup">¶</a></dt><dd><p>
          与 <span class="command"><strong>reboot</strong></span> 命令连用，
          要求系统主板的UEFI固件重启到安装模式。
          仅支持某些以UEFI模式启动的主板。
          </p></dd><dt id="--plain"><span class="term"><code class="option">--plain</code></span><a class="headerlink" title="Permalink to this term" href="#--plain">¶</a></dt><dd><p>与 <span class="command"><strong>list-dependencies</strong></span>,
          <span class="command"><strong>list-units</strong></span>, <span class="command"><strong>list-machines</strong></span> 命令连用，
          将输出从默认的树形变为列表型。
          </p></dd><dt id="-H"><span class="term"><code class="option">-H</code>, </span><span class="term"><code class="option">--host=</code></span><a class="headerlink" title="Permalink to this term" href="#-H">¶</a></dt><dd><p><a name="host-text"></a>操作指定的远程主机。可以仅指定一个主机名(hostname)，
      也可以使用 "<code class="literal">username@hostname</code>" 格式。
      hostname 后面还可以加上容器名(以冒号分隔)，
      也就是形如 "<code class="literal">hostname:container</code>" 的格式，
      以表示直接连接到指定主机的指定容器内。
      操作将通过SSH协议进行，以确保安全。
      可以通过
      <span class="command"><strong>machinectl -H
      <em class="replaceable"><code>HOST</code></em></strong></span> 命令列出远程主机上的所有容器名称。</p></dd><dt id="-M"><span class="term"><code class="option">-M</code>, </span><span class="term"><code class="option">--machine=</code></span><a class="headerlink" title="Permalink to this term" href="#-M">¶</a></dt><dd><p><a name="machine-text"></a>在本地容器内执行操作。
      必须明确指定容器的名称。</p></dd><dt id="--no-pager"><span class="term"><code class="option">--no-pager</code></span><a class="headerlink" title="Permalink to this term" href="#--no-pager">¶</a></dt><dd><p>不将程序的输出内容管道(pipe)给分页程序。</p></dd><dt id="--no-legend"><span class="term"><code class="option">--no-legend</code></span><a class="headerlink" title="Permalink to this term" href="#--no-legend">¶</a></dt><dd><p>不输出列标题，
      也就是不在输出列表的头部和尾部显示字段的名称。</p></dd><dt id="-h"><span class="term"><code class="option">-h</code>, </span><span class="term"><code class="option">--help</code></span><a class="headerlink" title="Permalink to this term" href="#-h">¶</a></dt><dd><p><a name="help-text"></a>显示简短的帮助信息并退出。
    </p></dd><dt id="--version"><span class="term"><code class="option">--version</code></span><a class="headerlink" title="Permalink to this term" href="#--version">¶</a></dt><dd><p><a name="version-text"></a>显示简短的版本信息并退出。</p></dd></dl></div></div><div class="refsect1"><a name="id-1.7"></a><h2 id="命令">命令<a class="headerlink" title="Permalink to this headline" href="#%E5%91%BD%E4%BB%A4">¶</a></h2><p>模式(<em class="replaceable"><code>PATTERN</code></em>)参数的语法与文件名匹配语法类似：用"*"匹配任意数量的字符，用"?"匹配单个字符，用"[]"匹配字符范围。
        如果给出了模式(<em class="replaceable"><code>PATTERN</code></em>)参数，那么表示该命令仅作用于单元名称与至少一个模式相匹配的单元。
        </p><div class="refsect2"><a name="id-1.7.3"></a><h3 id="单元命令">单元命令<a class="headerlink" title="Permalink to this headline" href="#%E5%8D%95%E5%85%83%E5%91%BD%E4%BB%A4">¶</a></h3><div class="variablelist"><dl class="variablelist"><dt id="list-units PATTERN…"><span class="term"><span class="command"><strong>list-units [<span class="optional"><em class="replaceable"><code>PATTERN</code></em>…</span>]</strong></span></span><a class="headerlink" title="Permalink to this term" href="#list-units%20PATTERN%E2%80%A6">¶</a></dt><dd><p>列出 <span class="command"><strong>systemd</strong></span> 当前已加载到内存中的单元。
            除非明确使用 <code class="option">--all</code> 选项列出全部单元，
            也就是：直接引用的单元、被依赖关系引用的单元、被应用程序调用的单元、启动失败的单元。
            否则默认仅列出：活动的单元、失败的单元、正处于任务队列中的单元。
            如果给出了模式(<em class="replaceable"><code>PATTERN</code></em>)参数，那么表示该命令仅作用于单元名称与至少一个模式相匹配的单元。
            还可以通过 <code class="option">--type=</code> 与 <code class="option">--state=</code> 选项过滤要列出的单元。
            </p><p>这是默认命令。</p></dd><dt id="list-sockets PATTERN…"><span class="term"><span class="command"><strong>list-sockets [<span class="optional"><em class="replaceable"><code>PATTERN</code></em>…</span>]</strong></span></span><a class="headerlink" title="Permalink to this term" href="#list-sockets%20PATTERN%E2%80%A6">¶</a></dt><dd><p>列出当前已加载到内存中的套接字(socket)单元，并按照监听地址排序。
            如果给出了模式(<em class="replaceable"><code>PATTERN</code></em>)参数，那么表示该命令仅作用于单元名称与至少一个模式相匹配的单元。
            该命令的输出大致像下面这样子：
            </p><pre class="programlisting">
LISTEN           UNIT                        ACTIVATES
/dev/initctl     systemd-initctl.socket      systemd-initctl.service
…
[::]:22          sshd.socket                 sshd.service
kobject-uevent 1 systemd-udevd-kernel.socket systemd-udevd.service

5 sockets listed.</pre><p>
            注意：因为监听地址中有可能包含空格，
            所以不适合使用程序分析该命令的输出。
            </p><p>参见 <code class="option">--show-types</code>, <code class="option">--all</code>, <code class="option">--state=</code> 选项。</p></dd><dt id="list-timers PATTERN…"><span class="term"><span class="command"><strong>list-timers [<span class="optional"><em class="replaceable"><code>PATTERN</code></em>…</span>]</strong></span></span><a class="headerlink" title="Permalink to this term" href="#list-timers%20PATTERN%E2%80%A6">¶</a></dt><dd><p>列出当前已加载到内存中的定时器(timer)单元，并按照下次执行的时间点排序。
            如果给出了模式(<em class="replaceable"><code>PATTERN</code></em>)参数，那么表示该命令仅作用于单元名称与至少一个模式相匹配的单元。
            该命令的输出大致像下面这样子：
            </p><pre class="programlisting">
NEXT                         LEFT          LAST                         PASSED     UNIT                         ACTIVATES
n/a                          n/a           Thu 2017-02-23 13:40:29 EST  3 days ago ureadahead-stop.timer        ureadahead-stop.service
Sun 2017-02-26 18:55:42 EST  1min 14s left Thu 2017-02-23 13:54:44 EST  3 days ago systemd-tmpfiles-clean.timer systemd-tmpfiles-clean.service
Sun 2017-02-26 20:37:16 EST  1h 42min left Sun 2017-02-26 11:56:36 EST  6h ago     apt-daily.timer              apt-daily.service
Sun 2017-02-26 20:57:49 EST  2h 3min left  Sun 2017-02-26 11:56:36 EST  6h ago     snapd.refresh.timer          snapd.refresh.service
            </pre><p>
            </p><p><span class="emphasis"><em>NEXT</em></span> 列显示下次执行的时间点</p><p><span class="emphasis"><em>LEFT</em></span> 列显示距离下次执行还剩多长时间</p><p><span class="emphasis"><em>LAST</em></span> 列显示上次执行的时间点</p><p><span class="emphasis"><em>PASSED</em></span> 列显示距离上次执行过去了多长时间</p><p><span class="emphasis"><em>UNIT</em></span> 列显示定时器单元的名称</p><p><span class="emphasis"><em>ACTIVATES</em></span> 列显示定时器单元将会启动的服务</p><p>参见 <code class="option">--all</code> and <code class="option">--state=</code> 选项。</p></dd><dt id="start PATTERN…"><span class="term"><span class="command"><strong>start <em class="replaceable"><code>PATTERN</code></em>…</strong></span></span><a class="headerlink" title="Permalink to this term" href="#start%20PATTERN%E2%80%A6">¶</a></dt><dd><p>启动(activate)指定的已加载单元(无法启动未加载的单元)。
            </p><p>如果某个单元未被启动，又没有处于失败(failed)状态，
            那么通常是因为该单元没有被加载到内存中，所以根本没有被模式匹配到。
            此外，对于从模板实例化而来的单元，因为 systemd 会在其尚未启动前忽略它们，
            又因为模式(<em class="replaceable"><code>PATTERN</code></em>)参数仅能匹配已加载到内存中的单元的"主名称"(不含单元的"别名")，
            所以，在这个命令中使用包含通配符的模式并没有多少实际意义。</p></dd><dt id="stop PATTERN…"><span class="term"><span class="command"><strong>stop <em class="replaceable"><code>PATTERN</code></em>…</strong></span></span><a class="headerlink" title="Permalink to this term" href="#stop%20PATTERN%E2%80%A6">¶</a></dt><dd><p>停止(deactivate)指定的单元
            </p></dd><dt id="reload PATTERN…"><span class="term"><span class="command"><strong>reload <em class="replaceable"><code>PATTERN</code></em>…</strong></span></span><a class="headerlink" title="Permalink to this term" href="#reload%20PATTERN%E2%80%A6">¶</a></dt><dd><p>
            要求指定的单元重新加载它们的配置。
            注意，这里所说的"配置"是服务进程专属的配置(例如 <code class="filename">httpd.conf</code> 之类)，
            而不是 systemd 的"单元文件"。
            如果你想重新加载 systemd 的"单元文件"，
            那么应该使用 <span class="command"><strong>daemon-reload</strong></span> 命令。
            以 Apache 为例，
            该命令会导致重新加载 <code class="filename">httpd.conf</code> 文件，
            而不是 <code class="filename">apache.service</code> 文件。
            </p><p>不要将此命令与
            <span class="command"><strong>daemon-reload</strong></span> 命令混淆。</p></dd><dt id="restart PATTERN…"><span class="term"><span class="command"><strong>restart <em class="replaceable"><code>PATTERN</code></em>…</strong></span></span><a class="headerlink" title="Permalink to this term" href="#restart%20PATTERN%E2%80%A6">¶</a></dt><dd><p>重新启动(先停止再启动)指定的单元。
            若指定的单元尚未启动，则启动它们。
            </p></dd><dt id="try-restart PATTERN…"><span class="term"><span class="command"><strong>try-restart <em class="replaceable"><code>PATTERN</code></em>…</strong></span></span><a class="headerlink" title="Permalink to this term" href="#try-restart%20PATTERN%E2%80%A6">¶</a></dt><dd><p>重新启动(先停止再启动)指定的已启动单元。
            注意，若指定的单元尚未启动，则不做任何操作。
            </p></dd><dt id="reload-or-restart PATTERN…"><span class="term"><span class="command"><strong>reload-or-restart <em class="replaceable"><code>PATTERN</code></em>…</strong></span></span><a class="headerlink" title="Permalink to this term" href="#reload-or-restart%20PATTERN%E2%80%A6">¶</a></dt><dd><p>首先尝试重新加载指定单元的进程专属配置，
            对于那些加载失败的单元，再继续尝试重新启动它们。
            若指定的单元尚未启动，则启动它们。</p></dd><dt id="try-reload-or-restart PATTERN…"><span class="term"><span class="command"><strong>try-reload-or-restart <em class="replaceable"><code>PATTERN</code></em>…</strong></span></span><a class="headerlink" title="Permalink to this term" href="#try-reload-or-restart%20PATTERN%E2%80%A6">¶</a></dt><dd><p>首先尝试重新加载指定单元的进程专属配置，
            对于那些加载失败的单元，再继续尝试重新启动它们。
            注意，若指定的单元尚未启动，则不做任何操作。</p></dd><dt id="isolate NAME"><span class="term"><span class="command"><strong>isolate <em class="replaceable"><code>NAME</code></em></strong></span></span><a class="headerlink" title="Permalink to this term" href="#isolate%20NAME">¶</a></dt><dd><p>启动指定的单元及其依赖的所有单元，
            同时停止所有其他
            <code class="option">IgnoreOnIsolate=no</code> 的单元("no"是默认值，详见
            <a href="systemd.unit.html#"><span class="citerefentry"><span class="refentrytitle">systemd.unit</span>(5)</span></a> 手册)。
            如果没有给出单元的后缀名，
            那么相当于以 "<code class="literal">.target</code>" 作为后缀名。</p><p>
            这类似于传统上切换SysV运行级的概念。
            该命令会立即停止所有在新目标单元中不需要的进程，
            这其中可能包括当前正在运行的图形环境以及正在使用的终端。
            </p><p>注意，该命令仅可用于
            <code class="option">AllowIsolate=yes</code> 的单元。参见
            <a href="systemd.unit.html#"><span class="citerefentry"><span class="refentrytitle">systemd.unit</span>(5)</span></a>
            手册。</p></dd><dt id="kill PATTERN…"><span class="term"><span class="command"><strong>kill <em class="replaceable"><code>PATTERN</code></em>…</strong></span></span><a class="headerlink" title="Permalink to this term" href="#kill%20PATTERN%E2%80%A6">¶</a></dt><dd><p>
            向指定单元的 <code class="option">--kill-who=</code>
            进程发送 <code class="option">--signal=</code> 信号。
            </p></dd><dt id="is-active PATTERN…"><span class="term"><span class="command"><strong>is-active <em class="replaceable"><code>PATTERN</code></em>…</strong></span></span><a class="headerlink" title="Permalink to this term" href="#is-active%20PATTERN%E2%80%A6">¶</a></dt><dd><p>
            检查指定的单元中，是否有处于活动(active)状态的单元。
            如果存在至少一个处于活动(active)状态的单元，那么返回"0"值，否则返回非零值。
            除非同时使用了 <code class="option">--quiet</code> 选项，
            否则，此命令还会在标准输出上显示单元的状态。
            </p></dd><dt id="is-failed PATTERN…"><span class="term"><span class="command"><strong>is-failed <em class="replaceable"><code>PATTERN</code></em>…</strong></span></span><a class="headerlink" title="Permalink to this term" href="#is-failed%20PATTERN%E2%80%A6">¶</a></dt><dd><p>
            检查指定的单元中，是否有处于失败(failed)状态的单元。
            如果存在至少一个处于失败(failed)状态的单元，那么返回"0"值，否则返回非零值。
            除非同时使用了 <code class="option">--quiet</code> 选项，
            否则，此命令还会在标准输出上显示单元的状态。
            </p></dd><dt id="status PATTERN…|PID…"><span class="term"><span class="command"><strong>status</strong></span> [<span class="optional"><em class="replaceable"><code>PATTERN</code></em>…|<em class="replaceable"><code>PID</code></em>…</span>]</span><a class="headerlink" title="Permalink to this term" href="#status%20PATTERN%E2%80%A6%7CPID%E2%80%A6">¶</a></dt><dd><p>
            如果指定了单元，那么显示指定单元的运行时状态信息，以及这些单元最近的日志数据。
            如果指定了PID，那么显示指定PID所属单元的运行时状态信息，以及这些单元最近的日志数据。
            如果未指定任何单元或PID，那么显示整个系统的状态信息，
            此时若与 <code class="option">--all</code> 连用，
            则同时显示所有已加载单元(可以用 <code class="option">-t</code> 限定单元类型)的状态信息。
            </p><p>
            此命令仅用于输出人类易读的结果，不要将其用于程序分析(应该使用 <span class="command"><strong>show</strong></span> 命令)。
            除非使用了
            <code class="option">--lines</code>
            与
            <code class="option">--full</code> 选项，
            否则默认只输出10行日志，
            并且超长的部分会被省略号截断。此外，
            <span class="command"><strong>journalctl --unit=<em class="replaceable"><code>NAME</code></em></strong></span>
            或
            <span class="command"><strong>journalctl --user-unit=<em class="replaceable"><code>NAME</code></em></strong></span>
            也会对超长的消息使用类似的省略号截断。
            </p><p>
            因为 systemd 仅按需加载单元，所以 <span class="command"><strong>status</strong></span> 命令将会尝试加载单元文件。
            因此，该命令不能用于检测某个单元是否已经被载到内存中。
            如果该命令执行完之后，指定的单元没有任何理由继续保留在内存中，那么将会被立即从内存中清除出去。
            </p><div class="example"><a name="id-1.7.3.2.15.2.4"></a><p class="title"><b>例 1.  systemctl status 命令的输出样例：</b></p><div class="example-contents"><pre class="programlisting">$ systemctl status bluetooth
● bluetooth.service - Bluetooth service
   Loaded: loaded (/usr/lib/systemd/system/bluetooth.service; enabled; vendor preset: enabled)
   Active: active (running) since Wed 2017-01-04 13:54:04 EST; 1 weeks 0 days ago
     Docs: man:bluetoothd(8)
 Main PID: 930 (bluetoothd)
   Status: "Running"
    Tasks: 1
   Memory: 648.0K
      CPU: 435ms
   CGroup: /system.slice/bluetooth.service
           └─930 /usr/lib/bluetooth/bluetoothd

Jan 12 10:46:45 example.com bluetoothd[8900]: Not enough free handles to register service
Jan 12 10:46:45 example.com bluetoothd[8900]: Current Time Service could not be registered
Jan 12 10:46:45 example.com bluetoothd[8900]: gatt-time-server: Input/output error (5)
</pre><p>在彩色终端上，前导点("●")使用不同的颜色来标记单元的不同状态。
            白色表示 "<code class="literal">inactive</code>" 或 "<code class="literal">deactivating</code>" 状态；
            红色表示 "<code class="literal">failed</code>" 或 "<code class="literal">error</code>" 状态；
            绿色表示 "<code class="literal">active</code>" 或 "<code class="literal">reloading</code>" 或 "<code class="literal">activating</code>" 状态。
            </p><p>以"Loaded:"开头的行显示了单元的加载状态：
             "<code class="literal">loaded</code>" 表示已经被载到内存中； "<code class="literal">error</code>" 表示加载失败；
             "<code class="literal">not-found</code>" 表示未找到单元文件； "<code class="literal">masked</code>" 表示已被屏蔽。
            同时还包含了单元文件的路径、启用状态、预设的启用状态。
            要想了解更多单元状态(包括 "<code class="literal">masked</code>" 的含义)，
            可参见对 <span class="command"><strong>is-enabled</strong></span> 命令的解释。
            </p><p>以"Active:"开头的行显示了单元的启动状态：
             "<code class="literal">active</code>" 表示已启动成功； "<code class="literal">inactive</code>" 表示尚未启动；
             "<code class="literal">activating</code>" 表示正在启动中； "<code class="literal">deactivating</code>" 表示正在停止中；
             "<code class="literal">failed</code>" 表示启动失败(崩溃、超时、退出码不为零……)。
            对于启动失败的单元，将会在日志中记录下导致启动失败的原因，
            以方便事后查找故障原因。</p></div></div><br class="example-break"></dd><dt id="show PATTERN…|JOB…"><span class="term"><span class="command"><strong>show</strong></span> [<span class="optional"><em class="replaceable"><code>PATTERN</code></em>…|<em class="replaceable"><code>JOB</code></em>…</span>]</span><a class="headerlink" title="Permalink to this term" href="#show%20PATTERN%E2%80%A6%7CJOB%E2%80%A6">¶</a></dt><dd><p>以"属性=值"的格式显示指定单元或任务的所有属性。
            单元用其名称表示，而任务则用其id表示。
            如果没有指定任何单元或任务，那么显示管理器(systemd)自身的属性。
            除非使用了 <code class="option">--all</code> 选项，否则默认不显示属性值为空的属性。
            可以使用 <code class="option">--property=</code> 选项限定仅显示特定的属性。
            此命令的输出仅适合用于程序分析，而不适合被人类阅读(应该使用 <span class="command"><strong>status</strong></span> 命令)。</p><p>该命令显示的许多属性都直接对应着系统、服务管理器、单元的相应配置。
            注意，该命令显示的属性，一般都是比原始配置更加底层与通用的版本，
            此外，还包含了运行时的状态信息。
            例如，对于服务单元来说，所显示的属性中就包含了运行时才有的
            主进程的标识符("<code class="literal">MainPID</code>")信息；
            同时时间属性的值总是以 "<code class="literal">…USec</code>" 作为时间单位(即使在单元文件中是以 "<code class="literal">…Sec</code>" 作为单位)，
            因为对于系统与服务管理器来说，
            毫秒是更加通用的时间单位。</p></dd><dt id="cat PATTERN…"><span class="term"><span class="command"><strong>cat <em class="replaceable"><code>PATTERN</code></em>…</strong></span></span><a class="headerlink" title="Permalink to this term" href="#cat%20PATTERN%E2%80%A6">¶</a></dt><dd><p>显示指定单元的单元文件内容。
            在显示每个单元文件的内容之前，
            会额外显示一行单元文件的绝对路径。
            注意，该命令显示的是当前文件系统上的单元文件的内容。
            如果在更改了单元文件的内容之后，
            没有使用 <span class="command"><strong>daemon-reload</strong></span> 命令，
            那么该命令所显示的内容
            有可能与已经加载到内存中的单元文件的内容不一致。</p></dd><dt id="set-property NAME ASSIGNMENT…"><span class="term"><span class="command"><strong>set-property <em class="replaceable"><code>NAME</code></em> <em class="replaceable"><code>ASSIGNMENT</code></em>…</strong></span></span><a class="headerlink" title="Permalink to this term" href="#set-property%20NAME%20ASSIGNMENT%E2%80%A6">¶</a></dt><dd><p>
            在运行时修改单元的属性值。
            主要用于修改单元的资源控制属性值而无需直接修改单元文件。
            并非所有属性都可以在运行时被修改，
            但大多数资源控制属性(参见
            <a href="systemd.resource-control.html#"><span class="citerefentry"><span class="refentrytitle">systemd.resource-control</span>(5)</span></a>)可以。
            所作修改会立即生效，并永久保存在磁盘上，以确保永远有效。
            但是如果使用了 <code class="option">--runtime</code> 选项，
            那么此修改仅临时有效，下次重启此单元后，将会恢复到原有的设置。
            设置属性的语法与单元文件中的写法相同。
            </p><p>例如： <span class="command"><strong>systemctl set-property foobar.service CPUShares=777</strong></span></p><p>
            注意，此命令可以同时修改多个属性值，
            只需依次将各个属性用空格分隔即可。
            </p><p>
            与单元文件中的规则相同，
            设为空表示清空当前已存在的列表。
            </p></dd><dt id="help PATTERN…|PID…"><span class="term"><span class="command"><strong>help <em class="replaceable"><code>PATTERN</code></em>…|<em class="replaceable"><code>PID</code></em>…</strong></span></span><a class="headerlink" title="Permalink to this term" href="#help%20PATTERN%E2%80%A6%7CPID%E2%80%A6">¶</a></dt><dd><p>显示指定单元的手册页(若存在)。
            指定PID表示显示该进程所属单元的手册页(若存在)。
            </p></dd><dt id="reset-failed [PATTERN…]"><span class="term"><span class="command"><strong>reset-failed [<em class="replaceable"><code>PATTERN</code></em>…]</strong></span></span><a class="headerlink" title="Permalink to this term" href="#reset-failed%20%5BPATTERN%E2%80%A6%5D">¶</a></dt><dd><p>
            重置指定单元的失败(failed)状态。
            如果未指定任何单元，则重置所有单元的失败(failed)状态。
            当某个单元因为某种原因操作失败(例如退出状态码不为零或进程被强制杀死或启动超时)，
            将会自动进入失败(failed)状态，
            退出状态码与导致故障的原因
            将被记录到日志中以方便日后排查。
            </p></dd><dt id="
            list-dependencies
            NAME
          "><span class="term">
            <span class="command"><strong>list-dependencies</strong></span>
            [<span class="optional"><em class="replaceable"><code>NAME</code></em></span>]
          </span><a class="headerlink" title="Permalink to this term" href="#%0A%20%20%20%20%20%20%20%20%20%20%20%20list-dependencies%0A%20%20%20%20%20%20%20%20%20%20%20%20NAME%0A%20%20%20%20%20%20%20%20%20%20">¶</a></dt><dd><p>显示单元的依赖关系。
            也就是显示由
            <code class="varname">Requires=</code>,
            <code class="varname">Requisite=</code>,
            <code class="varname">ConsistsOf=</code>,
            <code class="varname">Wants=</code>, <code class="varname">BindsTo=</code> 所形成的依赖关系。
            如果没有明确指定单元的名称，
            那么表示显示 <code class="filename">default.target</code> 的依赖关系树。</p><p>默认情况下，仅以递归方式显示 target 单元的依赖关系树，而对于其他类型的单元，仅显示一层依赖关系(不递归)。
            但如果使用了 <code class="option">--all</code> 选项，
            那么将对所有类型的单元都强制递归的显示完整的依赖关系树。</p><p>还可以使用 <code class="option">--reverse</code>,
            <code class="option">--after</code>, <code class="option">--before</code>
            选项指定仅显示特定类型的依赖关系。
            </p></dd></dl></div></div><div class="refsect2"><a name="id-1.7.4"></a><h3 id="单元文件命令">单元文件命令<a class="headerlink" title="Permalink to this headline" href="#%E5%8D%95%E5%85%83%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4">¶</a></h3><div class="variablelist"><dl class="variablelist"><dt id="list-unit-files PATTERN…"><span class="term"><span class="command"><strong>list-unit-files [<span class="optional"><em class="replaceable"><code>PATTERN…</code></em></span>]</strong></span></span><a class="headerlink" title="Permalink to this term" href="#list-unit-files%20PATTERN%E2%80%A6">¶</a></dt><dd><p>列出所有已安装的单元文件及其启用状态(相当于同时使用了 <span class="command"><strong>is-enabled</strong></span> 命令)。
            如果给出了模式(<em class="replaceable"><code>PATTERN</code></em>)参数，
            那么表示该命令仅作用于单元文件名称与至少一个模式相匹配的单元(仅匹配文件名，不匹配路径)。
            </p></dd><dt id="enable NAME…"><span class="term"><span class="command"><strong>enable <em class="replaceable"><code>NAME</code></em>…</strong></span>, </span><span class="term"><span class="command"><strong>enable <em class="replaceable"><code>PATH</code></em>…</strong></span></span><a class="headerlink" title="Permalink to this term" href="#enable%20NAME%E2%80%A6">¶</a></dt><dd><p>启用指定的单元或单元实例(多数时候相当于将这些单元设为"开机时自动启动"或"插入某个硬件时自动启动")。
            这将会按照单元文件中 "<code class="literal">[Install]</code>" 小节的指示，
            在例如 <code class="filename">/etc/systemd/system/multi-user.target.wants/</code>
            这样的目录中，创建指向单元文件自身的软链接。
            创建完软连接之后，systemd 将会自动重新加载自身的配置(相当于执行 <span class="command"><strong>daemon-reload</strong></span> 命令)，以确保所做的变更立即生效。
            注意，除非同时使用了 <code class="option">--now</code> 选项(相当于同时执行 <span class="command"><strong>start</strong></span> 命令)，
            否则启用一个单元<span class="emphasis"><em>并不会</em></span>导致该单元被启动。
            注意，对于形如 <code class="filename">foo@bar.service</code> 这样的单元实例，
            软链接自身的文件名是实例化之后的单元名称，
            但是软连接所指向的目标文件则是该单元的模板文件。</p><p>如果此命令的参数是一个有效的单元名称(<em class="replaceable"><code>NAME</code></em>)，那么将自动搜索所有单元目录。
            如果此命令的参数是一个单元文件的绝对路径(<em class="replaceable"><code>PATH</code></em>)，那么将直接使用指定的单元文件。
            如果参数是一个位于标准单元目录之外的单元文件，
            那么将会在标准单元目录中额外创建一个指向此单元文件的软连接，
            以确保该单元文件能够被 <span class="command"><strong>start</strong></span> 之类的命令找到。</p><p>除非使用了 <code class="option">--quiet</code> 选项，
            否则此命令还会显示对文件系统所执行的操作(Created symlink …)。
            </p><p>此命令是维护 <code class="filename">.{wants,requires}/</code> 目录与单元别名的首选方法。
            注意，此命令仅会按照单元文件中 "<code class="literal">[Install]</code>" 小节预设的名称创建软链接。
            另一方面，系统管理员亦可手动创建所需的软链接，
            特别是在需要创建不同于默认软链接名称的时候。
            不过需要注意的是，系统管理员必须在创建完软连接之后手动执行
            <span class="command"><strong>daemon-reload</strong></span> 命令，
            以确保所做的变更立即生效。
            </p><p>不要将此命令与 <span class="command"><strong>start</strong></span> 命令混淆，它们是相互独立的命令：
            可以启动一个尚未启用的单元，也可以启用一个尚未启动的单元。
            <span class="command"><strong>enable</strong></span> 命令只是设置了单元的启动钩子(通过创建软链接)，
            例如在系统启动时或者某个硬件插入时，自动启动某个单元。
            而 <span class="command"><strong>start</strong></span> 命令则是具体执行单元的启动操作，
            例如对于服务单元来说就是启动守护进程，而对于套接字单元来说则是绑定套接字，等等。</p><p>若与 <code class="option">--user</code> 选项连用，则表示变更仅作用于用户实例，否则默认作用于系统实例(相当于使用 <code class="option">--system</code> 选项)。
            若与 <code class="option">--runtime</code> 选项连用，则表示仅作临时性变更(重启后所有变更都将丢失)，否则默认为永久性变更。
            若与 <code class="option">--global</code> 选项连用，则表示变更作用于所有用户(在全局用户单元目录上操作)，否则默认仅作用于当前用户(在私有用户单元目录上操作)。
            注意，当与 <code class="option">--global</code> 选项连用时，systemd 守护进程不会重新加载自身的配置。</p><p>不可将此命令应用于已被 <span class="command"><strong>mask</strong></span> 命令屏蔽的单元，否则将会导致错误。</p></dd><dt id="disable NAME…"><span class="term"><span class="command"><strong>disable <em class="replaceable"><code>NAME</code></em>…</strong></span></span><a class="headerlink" title="Permalink to this term" href="#disable%20NAME%E2%80%A6">¶</a></dt><dd><p>停用指定的单元或单元实例(多数时候相当于撤销这些单元的"开机时自动启动"以及"插入某个硬件时自动启动")。
            这将会从单元目录中删除所有指向单元自身及所有支持单元的软链接。
            这相当于撤销 <span class="command"><strong>enable</strong></span> 或 <span class="command"><strong>link</strong></span> 命令所做的操作。
            注意，此命令会删除<span class="emphasis"><em>所有</em></span>指向单元自身及所有支持单元的软链接，
            包括手动创建的软连接以及通过 <span class="command"><strong>enable</strong></span> 与 <span class="command"><strong>link</strong></span> 命令创建的软连接。
            注意，虽然 <span class="command"><strong>disable</strong></span> 与 <span class="command"><strong>enable</strong></span> 是一对相反的命令，但是它们的效果并不一定总是完全对称的。
            因为 <span class="command"><strong>disable</strong></span> 删除的软连接数量有可能比上一次 <span class="command"><strong>enable</strong></span> 命令创建的软连接数量更多。</p><p>此命令的参数仅能接受单元的名字，而不能接受单元文件的路径。</p><p>除了停用参数中明确指定的单元之外，那些在被停用单元
            "<code class="literal">[Install]</code>" 小节的 <code class="varname">Also=</code> 选项中列出的所有单元，也同样会被停用。
            也就是说，这个停用动作是沿着 <code class="varname">Also=</code> 选项不断传递的。</p><p>删除完软连接之后，
            systemd 将会自动重新加载自身的配置(相当于执行 <span class="command"><strong>daemon-reload</strong></span> 命令)，以确保所做的变更立即生效。
            注意，除非同时使用了 <code class="option">--now</code> 选项(相当于同时执行 <span class="command"><strong>stop</strong></span> 命令)，
            否则停用一个单元<span class="emphasis"><em>并不会</em></span>导致该单元被停止。</p><p>除非使用了 <code class="option">--quiet</code> 选项，
            否则此命令还会显示对文件系统所执行的操作(Removed symlink …)。
            </p><p>有关 <code class="option">--system</code>, <code class="option">--user</code>, <code class="option">--runtime</code>,
             <code class="option">--global</code> 选项的影响，参见上面对 <span class="command"><strong>enable</strong></span> 命令的解释。</p></dd><dt id="reenable NAME…"><span class="term"><span class="command"><strong>reenable <em class="replaceable"><code>NAME</code></em>…</strong></span></span><a class="headerlink" title="Permalink to this term" href="#reenable%20NAME%E2%80%A6">¶</a></dt><dd><p>重新启用指定的单元或单元实例。
            这相当于先使用 <span class="command"><strong>disable</strong></span> 命令之后再使用 <span class="command"><strong>enable</strong></span> 命令。
            通常用于按照单元文件中 "<code class="literal">[Install]</code>" 小节的指示重置软链接名称。
            此命令的参数仅能接受单元的名字，而不能接受单元文件的路径。</p></dd><dt id="preset NAME…"><span class="term"><span class="command"><strong>preset <em class="replaceable"><code>NAME</code></em>…</strong></span></span><a class="headerlink" title="Permalink to this term" href="#preset%20NAME%E2%80%A6">¶</a></dt><dd><p>按照预设文件(*.preset)的指示，重置指定单元的启用(enable)/停用(disable)状态。
            其效果等价于按照预设规则，对列出的单元依次使用
            <span class="command"><strong>disable</strong></span> 或
            <span class="command"><strong>enable</strong></span> 命令。
            </p><p>可以使用 <code class="option">--preset-mode=</code> 选项控制如何参照预设文件：
            既启用又停用、仅启用、仅停用</p><p>如果指定单元的 "<code class="literal">[Install]</code>" 小节不包含必要的启用信息，
            那么此命令将会悄无声息的忽略该单元。 <em class="replaceable"><code>NAME</code></em> 必须是一个真实的单元名称，
            别名将会被悄无声息的忽略。</p><p>有关预设文件的更多说明，详见
            <a href="systemd.preset.html#"><span class="citerefentry"><span class="refentrytitle">systemd.preset</span>(5)</span></a>
            手册与
            <a class="ulink" href="https://www.freedesktop.org/wiki/Software/systemd/Preset" target="_top">Preset</a>
            文档。</p></dd><dt id="preset-all"><span class="term"><span class="command"><strong>preset-all</strong></span></span><a class="headerlink" title="Permalink to this term" href="#preset-all">¶</a></dt><dd><p>按照预设文件(*.preset)的指示，
            重置全部单元的启用(enable)/停用(disable)状态(参见上文)。</p><p>可以使用 <code class="option">--preset-mode=</code> 选项控制如何参照预设文件：
            既启用又停用、仅启用、仅停用
            </p></dd><dt id="is-enabled NAME…"><span class="term"><span class="command"><strong>is-enabled <em class="replaceable"><code>NAME</code></em>…</strong></span></span><a class="headerlink" title="Permalink to this term" href="#is-enabled%20NAME%E2%80%A6">¶</a></dt><dd><p>检查是否有至少一个指定的单元或单元实例
            已经被启用(使用 <span class="command"><strong>enable</strong></span> 命令)。
            如果有，那么返回"0"，否则返回非零。
            除非使用了 <code class="option">--quiet</code> 选项，
            否则此命令还会显示指定的单元或单元实例的当前启用状态(见下表)。
            要想显示已安装的 target 单元，可以使用 <code class="option">--full</code> 选项。
            </p><div class="table"><a name="id-1.7.4.2.7.2.2"></a><p class="title"><b>表 1. <span class="command">is-enabled</span> 命令的输出</b></p><div class="table-contents"><table class="table" summary="is-enabled 命令的输出" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>状态</th><th>含义</th><th>返回值</th></tr></thead><tbody><tr><td>"<code class="literal">enabled</code>"</td><td>已经通过 <code class="filename">/etc/systemd/system/</code> 目录下的 <code class="varname">Alias=</code> 别名、 <code class="filename">.wants/</code> 或 <code class="filename">.requires/</code> 软连接被永久启用</td><td>0</td></tr><tr><td>"<code class="literal">enabled-runtime</code>"</td><td>已经通过 <code class="filename">/run/systemd/system/</code> 目录下的 <code class="varname">Alias=</code> 别名、 <code class="filename">.wants/</code> 或 <code class="filename">.requires/</code> 软连接被临时启用</td><td>0</td></tr><tr><td>"<code class="literal">linked</code>"</td><td>虽然单元文件本身不在标准单元目录中，但是指向此单元文件的一个或多个软连接已经存在于 <code class="filename">/etc/systemd/system/</code> 永久目录中</td><td>&gt; 0</td></tr><tr><td>"<code class="literal">linked-runtime</code>"</td><td>虽然单元文件本身不在标准单元目录中，但是指向此单元文件的一个或多个软连接已经存在于 <code class="filename">/run/systemd/system/</code> 临时目录中</td><td>&gt; 0</td></tr><tr><td>"<code class="literal">masked</code>"</td><td>已经被 <code class="filename">/etc/systemd/system/</code> 目录永久屏蔽(软连接指向 <code class="filename">/dev/null</code> 文件)，因此 <span class="command"><strong>start</strong></span> 操作会失败</td><td>&gt; 0</td></tr><tr><td>"<code class="literal">masked-runtime</code>"</td><td>已经被 <code class="filename">/run/systemd/systemd/</code> 目录临时屏蔽(软连接指向 <code class="filename">/dev/null</code> 文件)，因此 <span class="command"><strong>start</strong></span> 操作会失败</td><td>&gt; 0</td></tr><tr><td>"<code class="literal">static</code>"</td><td>尚未被启用，并且单元文件的 "<code class="literal">[Install]</code>" 小节中没有可用于 <span class="command"><strong>enable</strong></span> 命令的选项</td><td>0</td></tr><tr><td>"<code class="literal">indirect</code>"</td><td>尚未被启用，但是单元文件的 "<code class="literal">[Install]</code>" 小节中 <code class="varname">Also=</code> 选项的值列表非空(也就是列表中的某些单元可能已被启用)、或者它拥有一个不在 <code class="varname">Also=</code> 列表中的其他名称的别名软连接。对于模版单元来说，表示已经启用了一个不同于 <code class="varname">DefaultInstance=</code> 的实例。</td><td>0</td></tr><tr><td>"<code class="literal">disabled</code>"</td><td>尚未被启用，但是单元文件的 "<code class="literal">[Install]</code>" 小节中存在可用于 <span class="command"><strong>enable</strong></span> 命令的选项</td><td>&gt; 0</td></tr><tr><td>"<code class="literal">generated</code>"</td><td>单元文件是被单元生成器动态生成的(参见 <a href="systemd.generator.html#"><span class="citerefentry"><span class="refentrytitle">systemd.generator</span>(7)</span></a> 手册)。被生成的单元文件可能并未被直接启用，而是被单元生成器隐含的启用了。</td><td>0</td></tr><tr><td>"<code class="literal">transient</code>"</td><td>单元文件是被运行时API动态临时生成的。该临时单元可能并未被启用。</td><td>0</td></tr><tr><td>"<code class="literal">bad</code>"</td><td>单元文件不正确或者出现其他错误。 <span class="command"><strong>is-enabled</strong></span> 不会返回此状态，而是会显示一条出错信息。 <span class="command"><strong>list-unit-files</strong></span> 命令有可能会显示此单元。</td><td>&gt; 0</td></tr></tbody></table></div></div><br class="table-break"></dd><dt id="mask NAME…"><span class="term"><span class="command"><strong>mask <em class="replaceable"><code>NAME</code></em>…</strong></span></span><a class="headerlink" title="Permalink to this term" href="#mask%20NAME%E2%80%A6">¶</a></dt><dd><p>屏蔽指定的单元或单元实例。
            也就是在单元目录中创建指向 <code class="filename">/dev/null</code> 的同名符号连接，从而在根本上确保无法启动这些单元。
            这比 <span class="command"><strong>disable</strong></span> 命令更彻底，可以通杀一切启动方法(包括手动启动)，所以应该谨慎使用该命令。
            若与 <code class="option">--runtime</code> 选项连用，则表示仅作临时性屏蔽(重启后屏蔽将失效)，否则默认为永久性屏蔽。
            除非使用了 <code class="option">--now</code> 选项(相当于同时执行 <span class="command"><strong>stop</strong></span> 命令)，否则仅屏蔽一个单元并不会导致该单元被停止。
            此命令的参数仅能接受单元的名字，而不能接受单元文件的路径。
            </p></dd><dt id="unmask NAME…"><span class="term"><span class="command"><strong>unmask <em class="replaceable"><code>NAME</code></em>…</strong></span></span><a class="headerlink" title="Permalink to this term" href="#unmask%20NAME%E2%80%A6">¶</a></dt><dd><p>解除对指定单元或单元实例的屏蔽，这是 <span class="command"><strong>mask</strong></span> 命令的反动作。
            也就是在单元目录中删除指向 <code class="filename">/dev/null</code> 的同名符号连接。
            此命令的参数仅能接受单元的名字，而不能接受单元文件的路径。</p></dd><dt id="link PATH…"><span class="term"><span class="command"><strong>link <em class="replaceable"><code>PATH</code></em>…</strong></span></span><a class="headerlink" title="Permalink to this term" href="#link%20PATH%E2%80%A6">¶</a></dt><dd><p>将不在标准单元目录中的单元文件(通过软链接)连接到标准单元目录中去。
            <em class="replaceable"><code>PATH</code></em> 参数必须是单元文件的绝对路径。该命令的结果可以通过 <span class="command"><strong>disable</strong></span> 命令撤消。
            通过该命令，可以让一个不在标准单元目录中的单元文件，也可以像位于标准单元目录中的常规单元文件一样，
            被 <span class="command"><strong>start</strong></span>, <span class="command"><strong>stop</strong></span> … 等各种命令操作。</p></dd><dt id="revert NAME…"><span class="term"><span class="command"><strong>revert <em class="replaceable"><code>NAME</code></em>…</strong></span></span><a class="headerlink" title="Permalink to this term" href="#revert%20NAME%E2%80%A6">¶</a></dt><dd><p>
            将指定的单元恢复成初始版本。
            这将会删除对指定单元的所有修改。
            例如，对于 "<code class="literal">foo.service</code>" 单元来说，
            将会删除所有 <code class="filename">foo.service.d/</code> 目录。
            如果指定的单元在 <code class="filename">/usr/lib/</code> 目录中
            还存在单元文件的初始版本，那么还会进一步删除
            <code class="filename">/etc/</code> 与 <code class="filename">/run/</code> 目录中
            所有用来覆盖初始单元文件的软连接与自定义单元文件。
            如果指定的单元已经被屏蔽，那么将会被解除屏蔽。
            </p><p>从效果上看，该命令相当于撤销 <span class="command"><strong>edit</strong></span>,
            <span class="command"><strong>set-property</strong></span>, <span class="command"><strong>mask</strong></span> 命令所做的操作，
            并且将指定单元的配置恢复成软件包提供的初始值。</p></dd><dt id="add-wants TARGET
          NAME…"><span class="term"><span class="command"><strong>add-wants <em class="replaceable"><code>TARGET</code></em>
          <em class="replaceable"><code>NAME</code></em>…</strong></span>, </span><span class="term"><span class="command"><strong>add-requires <em class="replaceable"><code>TARGET</code></em>
          <em class="replaceable"><code>NAME</code></em>…</strong></span></span><a class="headerlink" title="Permalink to this term" href="#add-wants%20TARGET%0A%20%20%20%20%20%20%20%20%20%20NAME%E2%80%A6">¶</a></dt><dd><p>将指定的单元或单元实例(<em class="replaceable"><code>NAME</code></em>)
            作为 "<code class="literal">Wants=</code>" 或 "<code class="literal">Requires=</code>" 依赖，
            添加到 <em class="replaceable"><code>TARGET</code></em> 单元中。</p><p>关于 <code class="option">--system</code>,
            <code class="option">--user</code>, <code class="option">--runtime</code>,
            <code class="option">--global</code> 选项的影响，
            参见前文对 <span class="command"><strong>enable</strong></span> 命令的解释。</p></dd><dt id="edit NAME…"><span class="term"><span class="command"><strong>edit <em class="replaceable"><code>NAME</code></em>…</strong></span></span><a class="headerlink" title="Permalink to this term" href="#edit%20NAME%E2%80%A6">¶</a></dt><dd><p>
            调用文本编辑器(参见下面的"环境变量"小节)修改指定的单元或单元实例。
            </p><p>若使用了 <code class="option">--full</code> 选项，则表示使用新编辑的单元文件完全取代原始单元文件，
            否则默认将新编辑的单元配置片段(位于 <code class="filename">.d/</code> 目录)附加到原始单元文件的末尾。</p><p>如果使用了 <code class="option">--force</code> 选项，并且某些指定的单元文件不存在，
            那么将会强制打开一个新的空单元文件以供编辑。</p><p>注意，在编辑过程中，编辑器实际操作的只是临时文件，
            仅在编辑器正常退出时，临时文件的内容才会被实际写入到目标文件中。</p><p>注意，如果在编辑器退出时，临时文件的内容为空，
            则表示取消编辑动作(而不是写入一个空文件)。</p><p>
            编辑动作完成之后，systemd 将会自动重新加载自身的配置(相当于执行 <span class="command"><strong>daemon-reload</strong></span> 命令)，以确保所做的变更立即生效。
            </p><p>
            关于 <code class="option">--system</code>,
            <code class="option">--user</code>, <code class="option">--runtime</code>,
            <code class="option">--global</code> 选项的影响，
            参见前文对 <span class="command"><strong>enable</strong></span> 命令的解释。
            </p><p>注意：(1)该命令不可用于编辑远程主机上的单元文件。
            (2)禁止在编辑 <code class="filename">/etc</code> 中的原始单元文件时使用 <code class="option">--runtime</code> 选项，
            因为 <code class="filename">/etc</code> 中的单元文件优先级高于 <code class="filename">/run</code> 中的单元文件。
            </p></dd><dt id="get-default"><span class="term"><span class="command"><strong>get-default</strong></span></span><a class="headerlink" title="Permalink to this term" href="#get-default">¶</a></dt><dd><p>显示默认的启动目标。
            这将显示 <code class="filename">default.target</code>
            软链接所指向的实际单元文件的名称。</p></dd><dt id="set-default NAME"><span class="term"><span class="command"><strong>set-default <em class="replaceable"><code>NAME</code></em></strong></span></span><a class="headerlink" title="Permalink to this term" href="#set-default%20NAME">¶</a></dt><dd><p>设置默认的启动目标。
            这会将 <code class="filename">default.target</code> 软链接指向
            <em class="replaceable"><code>NAME</code></em> 单元。</p></dd></dl></div></div><div class="refsect2"><a name="id-1.7.5"></a><h3 id="机器命令">机器命令<a class="headerlink" title="Permalink to this headline" href="#%E6%9C%BA%E5%99%A8%E5%91%BD%E4%BB%A4">¶</a></h3><div class="variablelist"><dl class="variablelist"><dt id="list-machines PATTERN…"><span class="term"><span class="command"><strong>list-machines [<span class="optional"><em class="replaceable"><code>PATTERN</code></em>…</span>]</strong></span></span><a class="headerlink" title="Permalink to this term" href="#list-machines%20PATTERN%E2%80%A6">¶</a></dt><dd><p>
            列出主机和所有运行中的本地容器，以及它们的状态。
            如果给出了模式(<em class="replaceable"><code>PATTERN</code></em>)参数，
            那么仅显示容器名称与至少一个模式匹配的本地容器。
            </p></dd></dl></div></div><div class="refsect2"><a name="id-1.7.6"></a><h3 id="任务(job)命令">任务(job)命令<a class="headerlink" title="Permalink to this headline" href="#%E4%BB%BB%E5%8A%A1(job)%E5%91%BD%E4%BB%A4">¶</a></h3><div class="variablelist"><dl class="variablelist"><dt id="list-jobs PATTERN…"><span class="term"><span class="command"><strong>list-jobs [<span class="optional"><em class="replaceable"><code>PATTERN…</code></em></span>]</strong></span></span><a class="headerlink" title="Permalink to this term" href="#list-jobs%20PATTERN%E2%80%A6">¶</a></dt><dd><p>列出正在运行中的任务。
            如果给出了模式(<em class="replaceable"><code>PATTERN</code></em>)参数，
            那么仅显示单元名称与至少一个模式匹配的任务。</p><p>当与 <code class="option">--after</code> 或 <code class="option">--before</code> 连用时，
            输出列表将会包含正在等待哪些任务完成，或哪些任务正在等待此处的任务完成。
            详见前文。</p></dd><dt id="cancel JOB…"><span class="term"><span class="command"><strong>cancel <em class="replaceable"><code>JOB</code></em>…</strong></span></span><a class="headerlink" title="Permalink to this term" href="#cancel%20JOB%E2%80%A6">¶</a></dt><dd><p>据给定的任务ID撤消任务。
            如果没有给出任务ID，
            那么表示撤消所有尚未执行的任务。</p></dd></dl></div></div><div class="refsect2"><a name="id-1.7.7"></a><h3 id="环境变量命令">环境变量命令<a class="headerlink" title="Permalink to this headline" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%91%BD%E4%BB%A4">¶</a></h3><div class="variablelist"><dl class="variablelist"><dt id="show-environment"><span class="term"><span class="command"><strong>show-environment</strong></span></span><a class="headerlink" title="Permalink to this term" href="#show-environment">¶</a></dt><dd><p>显示所有 systemd 环境变量及其值。
            这些环境变量会被传递给所有由 systemd 派生的进程。
            显示格式遵守shell脚本语法，可以直接用于shell脚本中。
            如果环境变量的值中不包含任何特殊字符以及空白字符，
            那么将直接按照 "<code class="literal">VARIABLE=value</code>" 格式显示，并且不使用任何转义序列。
            如果环境变量的值中包含任何特殊字符或及空白字符，
            那么将按照 "<code class="literal">VARIABLE=$'value'</code>"
            格式(以美元符号开头的单引号转义序列)显示。
            这种格式可以兼容
            <a href="http://linux.die.net/man/1/bash"><span class="citerefentry"><span class="refentrytitle">bash</span>(1)</span></a>,
            <a href="http://linux.die.net/man/1/zsh"><span class="citerefentry"><span class="refentrytitle">zsh</span>(1)</span></a>,
            <a href="http://linux.die.net/man/1/ksh"><span class="citerefentry"><span class="refentrytitle">ksh</span>(1)</span></a>,
            以及
            <a href="http://linux.die.net/man/1/busybox"><span class="citerefentry"><span class="refentrytitle">busybox</span>(1)</span></a> 中的
            <a href="http://linux.die.net/man/1/ash"><span class="citerefentry"><span class="refentrytitle">ash</span>(1)</span></a> ；
            但是不兼容
            <a href="http://linux.die.net/man/1/dash"><span class="citerefentry"><span class="refentrytitle">dash</span>(1)</span></a>
            与
            <a href="http://linux.die.net/man/1/fish"><span class="citerefentry"><span class="refentrytitle">fish</span>(1)</span></a>
            </p></dd><dt id="set-environment VARIABLE=VALUE…"><span class="term"><span class="command"><strong>set-environment <em class="replaceable"><code>VARIABLE=VALUE</code></em>…</strong></span></span><a class="headerlink" title="Permalink to this term" href="#set-environment%20VARIABLE=VALUE%E2%80%A6">¶</a></dt><dd><p>设置指定的 systemd 环境变量。
            </p></dd><dt id="unset-environment VARIABLE…"><span class="term"><span class="command"><strong>unset-environment <em class="replaceable"><code>VARIABLE</code></em>…</strong></span></span><a class="headerlink" title="Permalink to this term" href="#unset-environment%20VARIABLE%E2%80%A6">¶</a></dt><dd><p>撤消指定的 systemd 环境变量。
            如果仅指定了变量名，那么表示无条件的撤消该变量(无论其值是什么)。
            如果以 VARIABLE=VALUE 格式同时给出了变量值，
            那么表示仅当 VARIABLE 的值恰好等于 VALUE 时，
            才撤消 VARIABLE 变量。</p></dd><dt id="
            import-environment
            VARIABLE…
          "><span class="term">
            <span class="command"><strong>import-environment</strong></span>
            [<span class="optional"><em class="replaceable"><code>VARIABLE…</code></em></span>]
          </span><a class="headerlink" title="Permalink to this term" href="#%0A%20%20%20%20%20%20%20%20%20%20%20%20import-environment%0A%20%20%20%20%20%20%20%20%20%20%20%20VARIABLE%E2%80%A6%0A%20%20%20%20%20%20%20%20%20%20">¶</a></dt><dd><p>
            导入指定的客户端环境变量。
            如果未指定任何参数，
            则表示导入全部客户端环境变量。


            </p></dd></dl></div></div><div class="refsect2"><a name="id-1.7.8"></a><h3 id="systemd 生命周期命令">systemd 生命周期命令<a class="headerlink" title="Permalink to this headline" href="#systemd%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%91%BD%E4%BB%A4">¶</a></h3><div class="variablelist"><dl class="variablelist"><dt id="daemon-reload"><span class="term"><span class="command"><strong>daemon-reload</strong></span></span><a class="headerlink" title="Permalink to this term" href="#daemon-reload">¶</a></dt><dd><p>
            重新加载 systemd 守护进程的配置。
            具体是指：重新运行所有的生成器(<a href="systemd.generator.html#"><span class="citerefentry"><span class="refentrytitle">systemd.generator</span>(7)</span></a>)，
            重新加载所有单元文件，重建整个依赖关系树。
            在重新加载过程中，
            所有由 systemd 代为监听的用户套接字都始终保持可访问状态。
            </p><p>不要将此命令与
            <span class="command"><strong>reload</strong></span> 命令混淆。</p></dd><dt id="daemon-reexec"><span class="term"><span class="command"><strong>daemon-reexec</strong></span></span><a class="headerlink" title="Permalink to this term" href="#daemon-reexec">¶</a></dt><dd><p>重新执行 systemd 守护进程。
            具体是指：首先序列化 systemd 状态，
            接着重新执行 systemd 守护进程并反序列化原有状态。
            此命令仅供调试和升级 systemd 使用。
            有时候也作为 <span class="command"><strong>daemon-reload</strong></span> 命令的重量级版本使用。
            在重新执行过程中，
            所有由 systemd 代为监听的用户套接字都始终保持可访问状态。
            </p></dd></dl></div></div><div class="refsect2"><a name="id-1.7.9"></a><h3 id="系统命令">系统命令<a class="headerlink" title="Permalink to this headline" href="#%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4">¶</a></h3><div class="variablelist"><dl class="variablelist"><dt id="is-system-running"><span class="term"><span class="command"><strong>is-system-running</strong></span></span><a class="headerlink" title="Permalink to this term" href="#is-system-running">¶</a></dt><dd><p>
            检查当前系统是否处于正常运行状态(running)，若正常则返回"0"，否则返回大于零的正整数。
            所谓正常运行状态是指：
            系统完成了全部的启动操作，整个系统已经处于完全可用的状态，
            特别是没有处于启动/关闭/维护状态，并且没有任何单元处于失败(failed)状态。
            除非使用了 <code class="option">--quiet</code> 选项，
            否则此命令还会在标准输出上显示系统的当前状态，
            如下表所示：</p><div class="table"><a name="id-1.7.9.2.1.2.2"></a><p class="title"><b>表 2. <span class="command">is-system-running</span> 命令的输出</b></p><div class="table-contents"><table class="table" summary="is-system-running 命令的输出" border="1"><colgroup><col class="name"><col class="description"><col class="exit-code"></colgroup><thead><tr><th>状态</th><th>含义</th><th>返回值</th></tr></thead><tbody><tr><td><code class="varname">initializing</code></td><td><p>启动的早期阶段。也就是尚未到达
                    <code class="filename">basic.target</code>/<code class="filename">rescue.target</code>/<code class="filename">emergency.target</code>
                    之前的阶段。
                    </p></td><td>&gt; 0</td></tr><tr><td><code class="varname">starting</code></td><td><p>启动的晚期阶段。
                    也就是任务队列首次达到空闲之前的阶段，
                    或者已经启动到了某个救援 target 中。</p></td><td>&gt; 0</td></tr><tr><td><code class="varname">running</code></td><td><p>完成了全部的启动操作，整个系统已经处于完全可用的状态，
                    并且没有任何单元处于失败(failed)状态。</p></td><td>0</td></tr><tr><td><code class="varname">degraded</code></td><td><p>完成了全部的启动操作，系统已经可用，
                    但是某些单元处于失败(failed)状态。</p></td><td>&gt; 0</td></tr><tr><td><code class="varname">maintenance</code></td><td><p>启动了 <code class="filename">rescue.target</code>/<code class="filename">emergency.target</code> 目标。
                    </p></td><td>&gt; 0</td></tr><tr><td><code class="varname">stopping</code></td><td><p>系统正处于关闭过程中。
                    </p></td><td>&gt; 0</td></tr><tr><td><code class="varname">offline</code></td><td><p>
                    整个系统已经处于完全可用的状态，
                    但init进程(PID=1)不是 systemd
                    </p></td><td>&gt; 0</td></tr><tr><td><code class="varname">unknown</code></td><td><p>由于资源不足或未知原因，
                    无法检测系统的当前状态
                    </p></td><td>&gt; 0</td></tr></tbody></table></div></div><br class="table-break"></dd><dt id="default"><span class="term"><span class="command"><strong>default</strong></span></span><a class="headerlink" title="Permalink to this term" href="#default">¶</a></dt><dd><p>进入默认模式。相当于执行 <span class="command"><strong>systemctl isolate default.target</strong></span> 命令。
            此操作默认为阻塞模式，但可以使用 <code class="option">--no-block</code> 选项转变为无阻塞模式。</p></dd><dt id="rescue"><span class="term"><span class="command"><strong>rescue</strong></span></span><a class="headerlink" title="Permalink to this term" href="#rescue">¶</a></dt><dd><p>进入救援模式。相当于执行 <span class="command"><strong>systemctl isolate rescue.target</strong></span> 命令。
            此操作默认为阻塞模式，但可以使用 <code class="option">--no-block</code> 选项转变为无阻塞模式。</p></dd><dt id="emergency"><span class="term"><span class="command"><strong>emergency</strong></span></span><a class="headerlink" title="Permalink to this term" href="#emergency">¶</a></dt><dd><p>进入紧急维修模式。相当于执行 <span class="command"><strong>systemctl isolate
            emergency.target</strong></span> 命令。此操作默认为阻塞模式，
            但可以使用 <code class="option">--no-block</code> 选项转变为无阻塞模式。</p></dd><dt id="halt"><span class="term"><span class="command"><strong>halt</strong></span></span><a class="headerlink" title="Permalink to this term" href="#halt">¶</a></dt><dd><p>关闭系统，但不切断电源。差不多相当于执行 <span class="command"><strong>systemctl start halt.target
            --job-mode=replace-irreversibly --no-block</strong></span> 命令，并同时向所有用户显示一条警告信息。
            这是一个无阻塞命令，也就是将关闭操作排入任务队列之后，不等待其完成就立即返回。
            注意，此命令仅关闭操作系统内核，但不切断硬件电源。
            若想彻底切断硬件电源，应该使用下面的 <span class="command"><strong>systemctl poweroff</strong></span> 命令。</p><p>若仅使用一次 <code class="option">--force</code> 选项，
            则跳过单元的正常停止步骤而直接杀死所有进程，强制卸载所有文件系统(或以只读模式重新挂载)，并立即关闭系统。
            若使用了两次 <code class="option">--force</code> 选项，
            则跳过杀死进程和卸载文件系统的步骤，并立即关闭系统，这会导致数据丢失、文件系统不一致等不良后果。
            注意，如果连续两次使用 <code class="option">--force</code> 选项，那么所有操作都将由 <span class="command"><strong>systemctl</strong></span> 自己直接执行，而不会与 systemd 进程通信。
            这意味着，即使 systemd 进程已经崩溃，连续两次使用 <code class="option">--force</code> 选项所指定的操作依然能够执行成功。
            </p></dd><dt id="poweroff"><span class="term"><span class="command"><strong>poweroff</strong></span></span><a class="headerlink" title="Permalink to this term" href="#poweroff">¶</a></dt><dd><p>关闭系统，同时切断电源。差不多相当于执行 <span class="command"><strong>systemctl start
            poweroff.target --job-mode=replace-irreversibly --no-block</strong></span> 命令，并同时向所有用户显示一条警告信息。
            这是一个无阻塞命令，也就是将关闭操作排入任务队列之后，不等待其完成就立即返回。
            </p><p>若仅使用一次 <code class="option">--force</code> 选项，
            则跳过单元的正常停止步骤而直接杀死所有进程，强制卸载所有文件系统(或以只读模式重新挂载)，并立即关闭系统。
            若使用了两次 <code class="option">--force</code> 选项，
            则跳过杀死进程和卸载文件系统的步骤，并立即关闭系统，这会导致数据丢失、文件系统不一致等不良后果。
            注意，如果连续两次使用 <code class="option">--force</code> 选项，
            那么所有操作都将由 <span class="command"><strong>systemctl</strong></span> 自己直接执行，而不会与 systemd 进程通信。
            这意味着，即使 systemd 进程已经崩溃，连续两次使用 <code class="option">--force</code> 选项所指定的操作依然能够执行成功。</p></dd><dt id="reboot arg"><span class="term"><span class="command"><strong>reboot [<span class="optional"><em class="replaceable"><code>arg</code></em></span>]</strong></span></span><a class="headerlink" title="Permalink to this term" href="#reboot%20arg">¶</a></dt><dd><p>关闭系统，然后重新启动。差不多相当于执行 <span class="command"><strong>systemctl start reboot.target
            --job-mode=replace-irreversibly --no-block</strong></span> 命令，并同时向所有用户显示一条警告信息。
            这是一个无阻塞命令，也就是将重启操作排入任务队列之后，不等待其完成就立即返回。
            </p><p>若仅使用一次 <code class="option">--force</code> 选项，
            则跳过单元的正常停止步骤而直接杀死所有进程，强制卸载所有文件系统(或以只读模式重新挂载)，并立即关闭系统。
            若使用了两次 <code class="option">--force</code> 选项，
            则跳过杀死进程和卸载文件系统的步骤，并立即关闭系统，这会导致数据丢失、文件系统不一致等不良后果。
            注意，如果连续两次使用 <code class="option">--force</code> 选项，
            那么所有操作都将由 <span class="command"><strong>systemctl</strong></span> 自己直接执行，而不会与 systemd 进程通信。
            这意味着，即使 systemd 进程已经崩溃，连续两次使用 <code class="option">--force</code> 选项所指定的操作依然能够执行成功。</p><p>若给出了可选的 <em class="replaceable"><code>arg</code></em> 参数，那么将会被作为可选参数传递给
             <a href="http://man7.org/linux/man-pages/man2/reboot.2.html"><span class="citerefentry"><span class="refentrytitle">reboot</span>(2)</span></a>
            系统调用。其取值范围依赖于特定的硬件平台。例如 "<code class="literal">recovery</code>"
            有可能表示触发系统恢复动作，而 "<code class="literal">fota</code>" 有可能表示
            <span class="quote">“<span class="quote">firmware over the air</span>”</span> 固件更新。</p></dd><dt id="kexec"><span class="term"><span class="command"><strong>kexec</strong></span></span><a class="headerlink" title="Permalink to this term" href="#kexec">¶</a></dt><dd><p>关闭系统，并通过内核的 <span class="command"><strong>kexec</strong></span> 接口重新启动。相当于执行
            <span class="command"><strong>systemctl start kexec.target --job-mode=replace-irreversibly --no-block</strong></span> 命令。
            这是一个无阻塞命令，也就是将重启操作排入任务队列之后，不等待其完成就立即返回。
            </p><p>若使用了 <code class="option">--force</code> 选项，
            则跳过服务的正常关闭步骤而直接杀死所有进程，
            强制卸载所有文件系统(或只读挂载)，并立即关闭系统。</p></dd><dt id="exit EXIT_CODE"><span class="term"><span class="command"><strong>exit [<span class="optional"><em class="replaceable"><code>EXIT_CODE</code></em></span>]</strong></span></span><a class="headerlink" title="Permalink to this term" href="#exit%20EXIT_CODE">¶</a></dt><dd><p>退出服务管理器。此命令仅可用于 systemd 用户实例(也就是以
             <code class="option">--user</code> 选项启动的实例)或容器，相当于执行
            <span class="command"><strong>poweroff</strong></span> 命令。
            这是一个无阻塞命令，也就是将退出操作排入任务队列之后，不等待其完成就立即返回。</p><p>默认退出码为零，但也可以使用
            <em class="replaceable"><code>EXIT_CODE</code></em> 指定退出码(必须是整数)。</p></dd><dt id="switch-root ROOT INIT"><span class="term"><span class="command"><strong>switch-root <em class="replaceable"><code>ROOT</code></em> [<span class="optional"><em class="replaceable"><code>INIT</code></em></span>]</strong></span></span><a class="headerlink" title="Permalink to this term" href="#switch-root%20ROOT%20INIT">¶</a></dt><dd><p>
            将系统的根文件系统切换到 <em class="replaceable"><code>ROOT</code></em> 目录，
            并执行新系统上的 <em class="replaceable"><code>INIT</code></em> 程序(PID=1)。
            此命令仅应该在初始内存盘("initrd")中使用。
            如果未指定 <em class="replaceable"><code>INIT</code></em> 参数或者参数值为空，
            那么表示自动在 <em class="replaceable"><code>ROOT</code></em> 目录下搜索 systemd 二进制程序，
            并将其用作 <em class="replaceable"><code>INIT</code></em> 程序，
            同时"initrd"中 systemd 的状态将会传递给新的 systemd 进程，
            从而允许在新系统中对原"initrd"中的各种服务状态进行内省。</p></dd><dt id="suspend"><span class="term"><span class="command"><strong>suspend</strong></span></span><a class="headerlink" title="Permalink to this term" href="#suspend">¶</a></dt><dd><p>休眠到内存。
            相当于启动 <code class="filename">suspend.target</code> 目标。
            这是一个无阻塞命令，也就是将休眠操作排入任务队列之后，不等待其完成就立即返回。</p></dd><dt id="hibernate"><span class="term"><span class="command"><strong>hibernate</strong></span></span><a class="headerlink" title="Permalink to this term" href="#hibernate">¶</a></dt><dd><p>休眠到硬盘。
            相当于启动 <code class="filename">hibernate.target</code> 目标。
            这是一个无阻塞命令，也就是将休眠操作排入任务队列之后，不等待其完成就立即返回。</p></dd><dt id="hybrid-sleep"><span class="term"><span class="command"><strong>hybrid-sleep</strong></span></span><a class="headerlink" title="Permalink to this term" href="#hybrid-sleep">¶</a></dt><dd><p>进入混合休眠模式。也就是同时休眠到内存和硬盘。
            相当于启动 <code class="filename">hybrid-sleep.target</code> 目标。
            这是一个无阻塞命令，也就是将休眠操作排入任务队列之后，不等待其完成就立即返回。</p></dd></dl></div></div><div class="refsect2"><a name="id-1.7.10"></a><h3 id="参数语法">参数语法<a class="headerlink" title="Permalink to this headline" href="#%E5%8F%82%E6%95%B0%E8%AF%AD%E6%B3%95">¶</a></h3><p>
      单元命令的参数可能是一个单独的单元名称(<em class="replaceable"><code>NAME</code></em>)，
      也可能是多个匹配模式(<em class="replaceable"><code>PATTERN</code></em>…)。
      对于第一种情况，如果省略单元名称的后缀，那么默认以 "<code class="literal">.service</code>" 为后缀，
      除非那个命令只能用于某种特定类型的单元。例如
      </p><pre class="programlisting"># systemctl start sshd</pre><p> 等价于
      </p><pre class="programlisting"># systemctl start sshd.service</pre><p> ，
      而
      </p><pre class="programlisting"># systemctl isolate default</pre><p>
      等价于
      </p><pre class="programlisting"># systemctl isolate default.target</pre><p> ，因为 isolate 命令只能用于 .target 单元。
      注意，设备文件路径(绝对路径)会自动转化为 device 单元名称，其他路径(绝对路径)会自动转化为 mount 单元名称。
      例如，如下命令
      </p><pre class="programlisting"># systemctl status /dev/sda
# systemctl status /home</pre><p>
      分别等价于
      </p><pre class="programlisting"># systemctl status dev-sda.device
# systemctl status home.mount</pre><p>
      对于第二种情况，可以在模式中使用shell风格的匹配符，对所有已加载到内存中的单元的主名称(primary name)进行匹配。
      如果没有使用匹配符并且省略了单元后缀，那么处理方式与第一种情况完全相同。
      这就意味着：如果没有使用匹配符，那么该模式就等价于一个单独的单元名称(<em class="replaceable"><code>NAME</code></em>)，只表示一个明确的单元。
      如果使用了匹配符，那么该模式就可以匹配任意数量的单元(包括零个)。</p><p>模式使用
      <a href="http://man7.org/linux/man-pages/man3/fnmatch.3.html"><span class="citerefentry"><span class="refentrytitle">fnmatch</span>(3)</span></a> 语法，
      也就是可以使用shell风格的
      "<code class="literal">*</code>", "<code class="literal">?</code>",
      "<code class="literal">[]</code>" 匹配符(详见
      <a href="http://man7.org/linux/man-pages/man7/glob.7.html"><span class="citerefentry"><span class="refentrytitle">glob</span>(7)</span></a>)。
      模式将基于所有已加载到内存中的单元的主名称(primary name)进行匹配，
      如果某个模式未能匹配到任何单元，那么将会被悄无声息的忽略掉。
      例如
      </p><pre class="programlisting"># systemctl stop sshd@*.service</pre><p>
      命令将会停止所有 <code class="filename">sshd@.service</code> 的实例单元。
      注意，单元的别名(软连接)以及未被加载到内存中的单元，不在匹配范围内(也就是不作为匹配目标)。
      </p><p>对于单元文件命令，<em class="replaceable"><code>NAME</code></em> 参数必须是单元名称(完整的全称或省略了后缀的简称)或单元文件的绝对路径。
      例如：
      </p><pre class="programlisting"># systemctl enable foo.service</pre><p>
      或
      </p><pre class="programlisting"># systemctl link /path/to/foo.service</pre><p>
      </p></div></div><div class="refsect1"><a name="id-1.8"></a><h2 id="退出状态">退出状态<a class="headerlink" title="Permalink to this headline" href="#%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81">¶</a></h2><p>返回值为 0 表示成功，
    非零返回值表示失败代码。</p></div><div class="refsect1"><a name="id-1.9"></a><h2 id="环境变量">环境变量<a class="headerlink" title="Permalink to this headline" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">¶</a></h2><div class="variablelist"><dl class="variablelist"><dt id="$SYSTEMD_EDITOR"><span class="term"><code class="varname">$SYSTEMD_EDITOR</code></span><a class="headerlink" title="Permalink to this term" href="#%24SYSTEMD_EDITOR">¶</a></dt><dd><p>编辑单元文件时所使用的编辑器，会覆盖
        <code class="varname">$EDITOR</code> 与 <code class="varname">$VISUAL</code> 的值。
        如果 <code class="varname">$SYSTEMD_EDITOR</code>, <code class="varname">$EDITOR</code>,
        <code class="varname">$VISUAL</code>
        都不存在或无法使用，
        那么将会依次尝试使用
        <a href="http://linux.die.net/man/1/editor"><span class="citerefentry"><span class="refentrytitle">editor</span>(1)</span></a>,
        <a href="http://linux.die.net/man/1/nano"><span class="citerefentry"><span class="refentrytitle">nano</span>(1)</span></a>,
        <a href="http://linux.die.net/man/1/vim"><span class="citerefentry"><span class="refentrytitle">vim</span>(1)</span></a>,
        <a href="http://linux.die.net/man/1/vi"><span class="citerefentry"><span class="refentrytitle">vi</span>(1)</span></a>  编辑器。
        </p></dd></dl></div><dt id="$SYSTEMD_PAGER"><span class="term"><code class="varname">$SYSTEMD_PAGER</code></span><a class="headerlink" title="Permalink to this term" href="#%24SYSTEMD_PAGER">¶</a></dt><dd><p>指定分页程序。仅在未指定 <code class="option">--no-pager</code> 选项时有意义。
      此变量会覆盖 <code class="varname">$PAGER</code> 的值。如果 <code class="varname">$SYSTEMD_PAGER</code> 与 <code class="varname">$PAGER</code> 都未设置，
      那么将会依次尝试如下常见的分页程序：
      <a href="http://man7.org/linux/man-pages/man1/less.1.html"><span class="citerefentry"><span class="refentrytitle">less</span>(1)</span></a>,
      <a href="http://man7.org/linux/man-pages/man1/more.1.html"><span class="citerefentry"><span class="refentrytitle">more</span>(1)</span></a>,
      如果最终仍未找到分页程序，那么将不使用分页。
      将此变量设为空字符串或 "<code class="literal">cat</code>" 等价于使用 <code class="option">--no-pager</code> 选项。</p></dd><dt id="$SYSTEMD_LESS"><span class="term"><code class="varname">$SYSTEMD_LESS</code></span><a class="headerlink" title="Permalink to this term" href="#%24SYSTEMD_LESS">¶</a></dt><dd><p>用于覆盖默认传递给 <span class="command"><strong>less</strong></span>
      程序的命令行选项("<code class="literal">FRSXMK</code>")。</p></dd><dt id="$SYSTEMD_LESSCHARSET"><span class="term"><code class="varname">$SYSTEMD_LESSCHARSET</code></span><a class="headerlink" title="Permalink to this term" href="#%24SYSTEMD_LESSCHARSET">¶</a></dt><dd><p>用于覆盖默认传递给 <span class="command"><strong>less</strong></span> 程序的字符集。
      (如果终端兼容 UTF-8 ，那么默认值是 "<code class="literal">utf-8</code>" )</p></dd></div><div class="refsect1"><a name="id-1.10"></a><h2 id="参见">参见<a class="headerlink" title="Permalink to this headline" href="#%E5%8F%82%E8%A7%81">¶</a></h2><p>
      <a href="systemd.html#"><span class="citerefentry"><span class="refentrytitle">systemd</span>(1)</span></a>,
      <a href="journalctl.html#"><span class="citerefentry"><span class="refentrytitle">journalctl</span>(1)</span></a>,
      <a href="loginctl.html#"><span class="citerefentry"><span class="refentrytitle">loginctl</span>(1)</span></a>,
      <a href="machinectl.html#"><span class="citerefentry"><span class="refentrytitle">machinectl</span>(1)</span></a>,
      <a href="systemd.unit.html#"><span class="citerefentry"><span class="refentrytitle">systemd.unit</span>(5)</span></a>,
      <a href="systemd.resource-control.html#"><span class="citerefentry"><span class="refentrytitle">systemd.resource-control</span>(5)</span></a>,
      <a href="systemd.special.html#"><span class="citerefentry"><span class="refentrytitle">systemd.special</span>(7)</span></a>,
      <a href="http://man7.org/linux/man-pages/man1/wall.1.html"><span class="citerefentry"><span class="refentrytitle">wall</span>(1)</span></a>,
      <a href="systemd.preset.html#"><span class="citerefentry"><span class="refentrytitle">systemd.preset</span>(5)</span></a>,
      <a href="systemd.generator.html#"><span class="citerefentry"><span class="refentrytitle">systemd.generator</span>(7)</span></a>,
      <a href="http://man7.org/linux/man-pages/man7/glob.7.html"><span class="citerefentry"><span class="refentrytitle">glob</span>(7)</span></a>
    </p></div></div></body></html>
