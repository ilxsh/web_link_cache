<!DOCTYPE html>
<!-- saved from url=(0045)https://www.cnblogs.com/firege/p/9435349.html -->
<html lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="origin">
    <meta property="og:description" content="本章参考资料：《STM32F76xxx参考手册》、《STM32F76xxx规格书》、库帮助文档《STM32F779xx_User_Manual.chm》及《SPI总线协议介绍》。 若对SPI通讯协议不">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <title>第24章 QSPI—读写串行FLASH - 野火_firege - 博客园</title>
    
    <link rel="stylesheet" href="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/blog-common.min.css">
    <link id="MainCss" rel="stylesheet" href="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/bundle-banlieue13.min.css">
    
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/bundle-banlieue13-mobile.min.css">
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/firege/rss">
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/firege/rsd.xml">
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/firege/wlwmanifest.xml">
    <script src="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/amp4ads-host-v0.js.download"></script><script src="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/pubads_impl_rendering_2019082901.js.download"></script><script async="" src="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/analytics.js.download"></script><script src="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/jquery-2.2.0.min.js.download"></script>
    <script src="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/blog-common.min.js.download"></script>
    <script>
        var currentBlogId = 267886;
        var currentBlogApp = 'firege';
        var cb_enable_mathjax = false;
        var isLogined = false;
    </script>
    
    
    
<link rel="preload" href="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/f.txt" as="script"><script type="text/javascript" src="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/f.txt"></script><script src="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/pubads_impl_2019082901.js.download" async=""></script><link rel="prefetch" href="https://tpc.googlesyndication.com/safeframe/1-0-35/html/container.html"></head>
<body>
    <a name="top"></a>
    
    
<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
	<a href="https://www.cnblogs.com/firege/"><img id="blogLogo" src="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/logo.gif" alt="返回主页"></a>			
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/firege/">野火_firege</a>
</h1>
<h2>
【秉火STM32-开源共享】：www.firebbs.cn
</h2>




		
	</div><!--end: blogTitle 博客的标题和副标题 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="navigator">
			
<ul id="navList">
	<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
	<li>
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/firege/">
首页</a>
</li>
	<li>

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
	<li>
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/%E9%87%8E%E7%81%AB_firege">
联系</a></li>
	<li>
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
	<li>
<a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/firege/rss/">
订阅</a>
	
<a id="blog_nav_rss_image" href="https://www.cnblogs.com/firege/rss/">
    <img src="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/xml.gif" alt="订阅">
</a></li>
</ul>



			<div class="blogStats">
				
				<!--done-->
随笔- 
81&nbsp;
文章- 
0&nbsp;
评论- 
10&nbsp;



				
			</div><!--end: blogStats -->
		</div><!--end: navigator 博客导航栏 -->
		<div id="post_detail">
<!--done-->
<div id="topics">
	<div class="post">
		<h1 class="postTitle">
			
<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/firege/p/9435349.html">第24章 QSPI—读写串行FLASH</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			
<div id="cnblogs_post_body" class="blogpost-body ">
    <p class="21"><span style="font-family: 宋体;">本章参考资料：《</span>STM32F76xxx<span style="font-family: 宋体;">参考手册》、《</span><span style="font-family: &#39;Times New Roman&#39;;">STM32F76xxx</span><span style="font-family: 宋体;">规格书》、库帮助文档《</span>STM32F779xx_User_Manual.chm<span style="font-family: 宋体;">》及《</span>SPI<span style="font-family: 宋体;">总线协议介绍》。</span></p>
<p class="21"><span style="font-family: 宋体;">若对</span>SPI<span style="font-family: 宋体;">通讯协议不了解，可先阅读《</span><span style="font-family: &#39;Times New Roman&#39;;">SPI</span><span style="font-family: 宋体;">总线协议介绍》文档的内容学习。</span></p>
<p class="21"><span style="font-family: 宋体;">关于</span>FLASH<span style="font-family: 宋体;">存储器，请参考“</span>常用存储器介绍”章节，实验中<span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">芯片的具体参数，请参考其规格书《</span><span style="font-family: &#39;Times New Roman&#39;;">W25Q128</span><span style="font-family: 宋体;">》来了解。</span></p>
<h3>24.1 &nbsp;QSPI<span style="font-family: 黑体;">协议简介</span></h3>
<p class="21">QSPI<span style="font-family: 宋体;">是</span><span style="font-family: &#39;Times New Roman&#39;;">Queued SPI</span><span style="font-family: 宋体;">的简写，是</span><span style="font-family: &#39;Times New Roman&#39;;">Motorola</span><span style="font-family: 宋体;">公司推出的</span><span style="font-family: &#39;Times New Roman&#39;;">SPI</span><span style="font-family: 宋体;">接口的扩展，比</span><span style="font-family: &#39;Times New Roman&#39;;">SPI</span><span style="font-family: 宋体;">应用更加广泛。在</span><span style="font-family: &#39;Times New Roman&#39;;">SPI</span><span style="font-family: 宋体;">协议的基础上，</span><span style="font-family: &#39;Times New Roman&#39;;">Motorola</span><span style="font-family: 宋体;">公司对其功能进行了增强，增加了队列传输机制，推出了队列串行外围接口协议（即</span><span style="font-family: &#39;Times New Roman&#39;;">QSPI</span><span style="font-family: 宋体;">协议）。</span><span style="font-family: &#39;Times New Roman&#39;;">QSPI </span><span style="font-family: 宋体;">是一种专用的通信接口，连接单、双或四（条数据线） </span><span style="font-family: &#39;Times New Roman&#39;;">SPI Flash </span><span style="font-family: 宋体;">存储介质。</span></p>
<p class="21">该接口可以在以下三种模式下工作：</p>
<p class="21">①&nbsp;<span style="font-family: 宋体;">间接模式：使用</span> QSPI <span style="font-family: 宋体;">寄存器执行全部操作</span></p>
<p class="21">②&nbsp;<span style="font-family: 宋体;">状态轮询模式：周期性读取外部</span> Flash <span style="font-family: 宋体;">状态寄存器，而且标志位置 </span><span style="font-family: &#39;Times New Roman&#39;;">1 </span><span style="font-family: 宋体;">时会产生中断（如擦除或烧写完成，会产生中断）</span></p>
<p class="21">③&nbsp;<span style="font-family: 宋体;">内存映射模式：外部</span> Flash <span style="font-family: 宋体;">映射到微控制器地址空间，从而系统将其视作内部存储器</span></p>
<p class="21"><span style="font-family: 宋体;">采用双闪存模式时，将同时访问两个</span> Quad-SPI Flash<span style="font-family: 宋体;">，吞吐量和容量均可提高二倍。</span></p>
<h4>1.1.1 &nbsp;QSPI<span style="font-family: 黑体;">功能框图</span></h4>
<p class="21">QSPI<span style="font-family: 宋体;">功能框图，双闪存模式禁止见</span><span style="font-family: 宋体;">图</span> 24-1。</p>
<p align="center"><img src="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/896704-20180807100039910-1259137463.png" alt=""></p>
<p>&nbsp;</p>
<p align="center">&nbsp;</p>
<p align="center"><span style="font-family: 黑体;">图</span> 24-1&nbsp;QUADSPI <span style="font-family: 黑体;">功能框图（双闪存模式禁止）</span></p>
<p class="21"><span style="font-family: 宋体;">我们的开发板采用的是双闪存禁止的模式连接单片</span>QSPI Flash<span style="font-family: 宋体;">。</span><span style="font-family: &#39;Times New Roman&#39;;">QSPI </span><span style="font-family: 宋体;">使用 </span><span style="font-family: &#39;Times New Roman&#39;;">6 </span><span style="font-family: 宋体;">个信号连接</span><span style="font-family: &#39;Times New Roman&#39;;">Flash</span><span style="font-family: 宋体;">，分别是四个数据线</span><span style="font-family: &#39;Times New Roman&#39;;">BK1_IO0~BK1_IO3</span><span style="font-family: 宋体;">，一个时钟输出</span><span style="font-family: &#39;Times New Roman&#39;;">CLK</span><span style="font-family: 宋体;">，一个片选输出（低电平有效）</span><span style="font-family: &#39;Times New Roman&#39;;">BK1_nCS</span><span style="font-family: 宋体;">，它们的作用介绍如下：</span></p>
<p class="19" align="justify">(1)&nbsp;BK1_nCS<span style="font-family: 宋体;">：片选输出（低电平有效），适用于</span> FLASH 1<span style="font-family: 宋体;">。如果 </span><span style="font-family: &#39;Times New Roman&#39;;">QSPI </span><span style="font-family: 宋体;">始终在双闪存模式下工作，则其也可用于 </span><span style="font-family: &#39;Times New Roman&#39;;">FLASH 2</span><span style="font-family: 宋体;">从设备选择信号线</span>。QSPI<span style="font-family: 宋体;">通讯以</span>BK1_nCS线置低电平为开始信号，以BK1_nCS线被拉高作为结束信号。</p>
<p class="19" align="justify">(2)&nbsp;CLK：时钟输出，适用于两个存储器<span style="font-family: 宋体;">，用于通讯数据同步。它由通讯主机产生，决定了通讯的速率，不同的设备支持的最高时钟频率不一样，如</span>STM32<span style="font-family: 宋体;">的</span><span style="font-family: &#39;Times New Roman&#39;;">QSPI</span><span style="font-family: 宋体;">时钟频率最大为</span><span style="font-family: &#39;Times New Roman&#39;;">f</span><sub>pclk</sub>/2<span style="font-family: 宋体;">，两个设备之间通讯时，通讯速率受限于低速设备。</span></p>
<p class="19" align="justify">(3)&nbsp;BK1_IO0<span style="font-family: 宋体;">：在双线 </span><span style="font-family: &#39;Times New Roman&#39;;">/ </span><span style="font-family: 宋体;">四线模式中为双向 </span><span style="font-family: &#39;Times New Roman&#39;;">IO</span><span style="font-family: 宋体;">，单线模式中为串行输出，适用于</span>FLASH 1。</p>
<p class="19" align="justify">(4)&nbsp;BK1_IO1<span style="font-family: 宋体;">：在双线 </span><span style="font-family: &#39;Times New Roman&#39;;">/ </span><span style="font-family: 宋体;">四线模式中为双向 </span><span style="font-family: &#39;Times New Roman&#39;;">IO</span><span style="font-family: 宋体;">，单线模式中为串行输入，适用于</span>FLASH 1。</p>
<p class="19" align="justify">(5)&nbsp;BK1_IO2<span style="font-family: 宋体;">：</span><span style="font-family: 宋体;">在四线模式中为双向</span> IO<span style="font-family: 宋体;">，适用于 </span><span style="font-family: &#39;Times New Roman&#39;;">FLASH 1</span><span style="font-family: 宋体;">。</span></p>
<p class="19" align="justify">(6)&nbsp;BK1_IO3<span style="font-family: 宋体;">：</span><span style="font-family: 宋体;">在四线模式中为双向</span> IO<span style="font-family: 宋体;">，适用于 </span><span style="font-family: &#39;Times New Roman&#39;;">FLASH 1</span><span style="font-family: 宋体;">。</span></p>
<p class="19" align="justify">&nbsp;</p>
<p class="19" align="justify"><strong>24.1.2 &nbsp;QSPI命令序列</strong></p>
<p class="21">QUADSPI <span style="font-family: 宋体;">通过命令与 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">通信 每条命令包括指令、地址、交替字节、空指令和数据这五个阶段 任一阶段均可跳过，但至少要包含指令、地址、交替字节或数据阶段之一。</span><span style="font-family: &#39;Times New Roman&#39;;">nCS </span><span style="font-family: 宋体;">在每条指令开始前下降，在每条指令完成后再次上升。先看看</span><span style="font-family: &#39;Times New Roman&#39;;">QSPI</span><span style="font-family: 宋体;">四线模式下的读命令时序，见</span><span style="font-family: 宋体;">图</span> 24-2。</p>
<p class="21">&nbsp;</p>
<p align="center">&nbsp;<img src="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/896704-20180807100103114-502084897.png" alt=""></p>
<p>&nbsp;</p>
<p align="center"><span style="font-family: 黑体;">图</span> 24-2&nbsp;<span style="font-family: 黑体;">四线模式下的读命令时序</span></p>
<h5>1.&nbsp;指令阶段</h5>
<p class="21"><span style="font-family: 宋体;">这一阶段，将在</span> QUADSPI_CCR[7:0] <span style="font-family: 宋体;">寄存器的 </span><span style="font-family: &#39;Times New Roman&#39;;">INSTRUCTION </span><span style="font-family: 宋体;">字段中配置的一条 </span><span style="font-family: &#39;Times New Roman&#39;;">8 </span><span style="font-family: 宋体;">位指令发送到 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash</span><span style="font-family: 宋体;">，指定待执行操作的类型。</span></p>
<p class="21"><span style="font-family: 宋体;">尽管大多数</span> Flash <span style="font-family: 宋体;">从 </span><span style="font-family: &#39;Times New Roman&#39;;">IO0/SO </span><span style="font-family: 宋体;">信号（单线 </span><span style="font-family: &#39;Times New Roman&#39;;">SPI </span><span style="font-family: 宋体;">模式）只能以一次 </span><span style="font-family: &#39;Times New Roman&#39;;">1 </span><span style="font-family: 宋体;">位的方式接收指令，但指令阶段可选择一次发送 </span><span style="font-family: &#39;Times New Roman&#39;;">2 </span><span style="font-family: 宋体;">位（在双线 </span><span style="font-family: &#39;Times New Roman&#39;;">SPI </span><span style="font-family: 宋体;">模式中通过 </span><span style="font-family: &#39;Times New Roman&#39;;">IO0/IO1</span><span style="font-family: 宋体;">）或一次发送 </span><span style="font-family: &#39;Times New Roman&#39;;">4 </span><span style="font-family: 宋体;">位（在四线</span><span style="font-family: &#39;Times New Roman&#39;;">SPI </span><span style="font-family: 宋体;">模式中通过 </span><span style="font-family: &#39;Times New Roman&#39;;">IO0/IO1/IO2/IO3</span><span style="font-family: 宋体;">）。这可通过 </span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI_CCR[9:8] </span><span style="font-family: 宋体;">寄存器中的 </span><span style="font-family: &#39;Times New Roman&#39;;">IMODE[1:0]</span><span style="font-family: 宋体;">字段进行配置。</span></p>
<p class="21"><span style="font-family: 宋体;">若</span> IMODE = 00<span style="font-family: 宋体;">，则跳过指令阶段，命令序列从地址阶段（如果存在）开始。</span></p>
<p class="21">&nbsp;</p>
<h5>1.&nbsp;地址阶段</h5>
<p class="21"><span style="font-family: 宋体;">在地址阶段，将</span>1-4<span style="font-family: 宋体;">字节发送到</span><span style="font-family: &#39;Times New Roman&#39;;">Flash</span><span style="font-family: 宋体;">，指示操作地址。待发送的地址字节数在</span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI_CCR[13:12]</span><span style="font-family: 宋体;">寄存器的</span><span style="font-family: &#39;Times New Roman&#39;;">ADSIZE[1:0]</span><span style="font-family: 宋体;">字段中进行配置。在间接模式和自动轮询模式下，待发送的地址字节在</span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI_AR</span><span style="font-family: 宋体;">寄存器的</span><span style="font-family: &#39;Times New Roman&#39;;">ADDRESS[31:0]</span><span style="font-family: 宋体;">中指定在内存映射模式下，则通过 </span><span style="font-family: &#39;Times New Roman&#39;;">AHB</span><span style="font-family: 宋体;">（来自于 </span><span style="font-family: &#39;Times New Roman&#39;;">Cortex ® </span><span style="font-family: 宋体;">或 </span><span style="font-family: &#39;Times New Roman&#39;;">DMA</span><span style="font-family: 宋体;">）直接给出地址。地址阶段可一次发送</span><span style="font-family: &#39;Times New Roman&#39;;">1 </span><span style="font-family: 宋体;">位（在单线</span><span style="font-family: &#39;Times New Roman&#39;;">SPI</span><span style="font-family: 宋体;">模式中通过</span><span style="font-family: &#39;Times New Roman&#39;;">SO</span><span style="font-family: 宋体;">）、</span><span style="font-family: &#39;Times New Roman&#39;;">2</span><span style="font-family: 宋体;">位（在双线</span><span style="font-family: &#39;Times New Roman&#39;;">SPI</span><span style="font-family: 宋体;">模式中通过</span><span style="font-family: &#39;Times New Roman&#39;;">IO0/IO1</span><span style="font-family: 宋体;">）或</span><span style="font-family: &#39;Times New Roman&#39;;">4</span><span style="font-family: 宋体;">位（在四线 </span><span style="font-family: &#39;Times New Roman&#39;;">SPI </span><span style="font-family: 宋体;">模式中通过 </span><span style="font-family: &#39;Times New Roman&#39;;">IO0/IO1/IO2/IO3</span><span style="font-family: 宋体;">）。这可通过</span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI_CCR[11:10]</span><span style="font-family: 宋体;">寄存器中的</span><span style="font-family: &#39;Times New Roman&#39;;">ADMODE[1:0]</span><span style="font-family: 宋体;">字段进行配置。</span></p>
<p class="21"><span style="font-family: 宋体;">若</span> ADMODE = 00<span style="font-family: 宋体;">，则跳过地址阶段，命令序列直接进入下一阶段（如果存在）。</span></p>
<h5>2.&nbsp;交替字节阶段</h5>
<p class="21"><span style="font-family: 宋体;">在交替字节阶段，将</span> 1-4 <span style="font-family: 宋体;">字节发送到 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash</span><span style="font-family: 宋体;">，一般用于控制操作模式。待发送的交替字节数在 </span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI_CCR[17:16] </span><span style="font-family: 宋体;">寄存器的 </span><span style="font-family: &#39;Times New Roman&#39;;">ABSIZE[1:0] </span><span style="font-family: 宋体;">字段中进行配置。待发送的字节在</span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI_ABR </span><span style="font-family: 宋体;">寄存器中指定。</span></p>
<p class="21"><span style="font-family: 宋体;">交替字节阶段可一次发送</span> 1 <span style="font-family: 宋体;">位（在单线 </span><span style="font-family: &#39;Times New Roman&#39;;">SPI </span><span style="font-family: 宋体;">模式中通过 </span><span style="font-family: &#39;Times New Roman&#39;;">SO</span><span style="font-family: 宋体;">）、</span><span style="font-family: &#39;Times New Roman&#39;;">2 </span><span style="font-family: 宋体;">位（在双线 </span><span style="font-family: &#39;Times New Roman&#39;;">SPI </span><span style="font-family: 宋体;">模式中通过 </span><span style="font-family: &#39;Times New Roman&#39;;">IO0/IO1</span><span style="font-family: 宋体;">）或 </span><span style="font-family: &#39;Times New Roman&#39;;">4 </span><span style="font-family: 宋体;">位（在四线 </span><span style="font-family: &#39;Times New Roman&#39;;">SPI </span><span style="font-family: 宋体;">模式中通过 </span><span style="font-family: &#39;Times New Roman&#39;;">IO0/IO1/IO2/IO3</span><span style="font-family: 宋体;">）。这可通过</span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI_CCR[15:14] </span><span style="font-family: 宋体;">寄存器中的 </span><span style="font-family: &#39;Times New Roman&#39;;">ABMODE[1:0] </span><span style="font-family: 宋体;">字段进行配置。</span></p>
<p class="21"><span style="font-family: 宋体;">若</span> ABMODE = 00<span style="font-family: 宋体;">，则跳过交替字节阶段，命令序列直接进入下一阶段（如果存在）。交替字节阶段存在仅需发送单个半字节而不是一个全字节的情况，比如采用双线模式并且仅使用两个周期发送交替字节时。在这种情况下，固件可采用四线模式 </span><span style="font-family: &#39;Times New Roman&#39;;">(ABMODE = 11) </span><span style="font-family: 宋体;">并发送一个字节，方法是 </span><span style="font-family: &#39;Times New Roman&#39;;">ALTERNATE </span><span style="font-family: 宋体;">的位 </span><span style="font-family: &#39;Times New Roman&#39;;">7 </span><span style="font-family: 宋体;">和 </span><span style="font-family: &#39;Times New Roman&#39;;">3 </span><span style="font-family: 宋体;">置“</span><span style="font-family: &#39;Times New Roman&#39;;">1</span><span style="font-family: 宋体;">”（</span><span style="font-family: &#39;Times New Roman&#39;;">IO3 </span><span style="font-family: 宋体;">保持高电平）且位 </span><span style="font-family: &#39;Times New Roman&#39;;">6 </span><span style="font-family: 宋体;">和 </span><span style="font-family: &#39;Times New Roman&#39;;">2 </span><span style="font-family: 宋体;">置“</span><span style="font-family: &#39;Times New Roman&#39;;">0</span><span style="font-family: 宋体;">”（</span><span style="font-family: &#39;Times New Roman&#39;;">IO2 </span><span style="font-family: 宋体;">线保持低电平）。此时，半字节的高 </span><span style="font-family: &#39;Times New Roman&#39;;">2 </span><span style="font-family: 宋体;">位存放在 </span><span style="font-family: &#39;Times New Roman&#39;;">ALTERNATE </span><span style="font-family: 宋体;">的位 </span><span style="font-family: &#39;Times New Roman&#39;;">4:3</span><span style="font-family: 宋体;">，低 </span><span style="font-family: &#39;Times New Roman&#39;;">2</span><span style="font-family: 宋体;">位存放在位 </span><span style="font-family: &#39;Times New Roman&#39;;">1 </span><span style="font-family: 宋体;">和 </span><span style="font-family: &#39;Times New Roman&#39;;">0 </span><span style="font-family: 宋体;">中。例如，如果半字节 </span><span style="font-family: &#39;Times New Roman&#39;;">2 (0010) </span><span style="font-family: 宋体;">通过 </span><span style="font-family: &#39;Times New Roman&#39;;">IO0/IO1 </span><span style="font-family: 宋体;">发送，则 </span><span style="font-family: &#39;Times New Roman&#39;;">ALTERNATE </span><span style="font-family: 宋体;">应设置为 </span><span style="font-family: &#39;Times New Roman&#39;;">0x8A (1000_1010)</span><span style="font-family: 宋体;">。</span></p>
<h5>3.&nbsp;空指令周期阶段</h5>
<p class="21"><span style="font-family: 宋体;">在空指令周期阶段，给定的</span> 1-31 <span style="font-family: 宋体;">个周期内不发送或接收任何数据，目的是当采用更高的时钟频率时，给 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">留出准备数据阶段的时间。这一阶段中给定的周期数在</span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI_CCR[22:18] </span><span style="font-family: 宋体;">寄存器的 </span><span style="font-family: &#39;Times New Roman&#39;;">DCYC[4:0] </span><span style="font-family: 宋体;">字段中指定。在 </span><span style="font-family: &#39;Times New Roman&#39;;">SDR </span><span style="font-family: 宋体;">和 </span><span style="font-family: &#39;Times New Roman&#39;;">DDR </span><span style="font-family: 宋体;">模式下，持续时间被指定为一定个数的全时钟周期。若 </span><span style="font-family: &#39;Times New Roman&#39;;">DCYC </span><span style="font-family: 宋体;">为零，则跳过空指令周期阶段，命令序列直接进入数据阶段（如果存在）。空指令周期阶段的操作模式由 </span><span style="font-family: &#39;Times New Roman&#39;;">DMODE </span><span style="font-family: 宋体;">确定。为确保数据信号从输出模式转变为输入模式有足够的“周转”时间，使用双线和四线模式从</span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">接收数据时，至少需要指定一个空指令周期。</span></p>
<h5>4.&nbsp;数据阶段</h5>
<p class="21"><span style="font-family: 宋体;">在数据阶段，可从</span> Flash <span style="font-family: 宋体;">接收或向其发送任意数量的字节。</span></p>
<p class="21"><span style="font-family: 宋体;">在间接模式和自动轮询模式下，待发送</span>/<span style="font-family: 宋体;">接收的字节数在 </span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI_DLR </span><span style="font-family: 宋体;">寄存器中指定。在间接写入模式下，发送到 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">的数据必须写入 </span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI_DR </span><span style="font-family: 宋体;">寄存器。在间接读取模式下，通过读取 </span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI_DR </span><span style="font-family: 宋体;">寄存器获得从 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">接收的数据。在内存映射模式下，读取的数据通过 </span><span style="font-family: &#39;Times New Roman&#39;;">AHB </span><span style="font-family: 宋体;">直接发送回 </span><span style="font-family: &#39;Times New Roman&#39;;">Cortex </span><span style="font-family: 宋体;">或 </span><span style="font-family: &#39;Times New Roman&#39;;">DMA</span><span style="font-family: 宋体;">。数据阶段可一次发送</span><span style="font-family: &#39;Times New Roman&#39;;">/</span><span style="font-family: 宋体;">接收 </span><span style="font-family: &#39;Times New Roman&#39;;">1 </span><span style="font-family: 宋体;">位（在单线 </span><span style="font-family: &#39;Times New Roman&#39;;">SPI </span><span style="font-family: 宋体;">模式中通过 </span><span style="font-family: &#39;Times New Roman&#39;;">SO</span><span style="font-family: 宋体;">）、</span><span style="font-family: &#39;Times New Roman&#39;;">2 </span><span style="font-family: 宋体;">位（在双线 </span><span style="font-family: &#39;Times New Roman&#39;;">SPI </span><span style="font-family: 宋体;">模式中通过 </span><span style="font-family: &#39;Times New Roman&#39;;">IO0/IO1</span><span style="font-family: 宋体;">）或 </span><span style="font-family: &#39;Times New Roman&#39;;">4 </span><span style="font-family: 宋体;">位（在四线 </span><span style="font-family: &#39;Times New Roman&#39;;">SPI </span><span style="font-family: 宋体;">模式中通过 </span><span style="font-family: &#39;Times New Roman&#39;;">IO0/IO1/IO2/IO3</span><span style="font-family: 宋体;">）。这可通过</span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI_CCR[15:14] </span><span style="font-family: 宋体;">寄存器中的 </span><span style="font-family: &#39;Times New Roman&#39;;">ABMODE[1:0] </span><span style="font-family: 宋体;">字段进行配置。若 </span><span style="font-family: &#39;Times New Roman&#39;;">DMODE = 00</span><span style="font-family: 宋体;">，则跳过数据阶段，命令序列在拉高 </span><span style="font-family: &#39;Times New Roman&#39;;">nCS </span><span style="font-family: 宋体;">时立即完成。这一配置仅可用于仅间接写入模式。</span></p>
<p align="center">&nbsp;</p>
<h3>24.2 &nbsp;QUADSPI <span style="font-family: 黑体;">信号接口协议模式</span></h3>
<h4>24.2.1 &nbsp;<span style="font-family: 黑体;">单线</span> SPI <span style="font-family: 黑体;">模式</span></h4>
<p class="21"><span style="font-family: 宋体;">传统</span> SPI <span style="font-family: 宋体;">模式允许串行发送</span><span style="font-family: &#39;Times New Roman&#39;;">/</span><span style="font-family: 宋体;">接收单独的 </span><span style="font-family: &#39;Times New Roman&#39;;">1 </span><span style="font-family: 宋体;">位。在此模式下，数据通过 </span><span style="font-family: &#39;Times New Roman&#39;;">SO </span><span style="font-family: 宋体;">信号（其 </span><span style="font-family: &#39;Times New Roman&#39;;">I/O </span><span style="font-family: 宋体;">与</span><span style="font-family: &#39;Times New Roman&#39;;">IO0 </span><span style="font-family: 宋体;">共享）发送到 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash</span><span style="font-family: 宋体;">。从 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">接收到的数据通过 </span><span style="font-family: &#39;Times New Roman&#39;;">SI</span><span style="font-family: 宋体;">（其 </span><span style="font-family: &#39;Times New Roman&#39;;">I/O </span><span style="font-family: 宋体;">与 </span><span style="font-family: &#39;Times New Roman&#39;;">IO1 </span><span style="font-family: 宋体;">共享）送达。通过将（</span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI_CCR </span><span style="font-family: 宋体;">中的）</span><span style="font-family: &#39;Times New Roman&#39;;">IMODE/ADMODE/ABMODE/DMODE </span><span style="font-family: 宋体;">字段设置为 </span><span style="font-family: &#39;Times New Roman&#39;;">01</span><span style="font-family: 宋体;">，可对不同的命令阶段分别进行配置，以使用此单个位模式。在每个已配置为单线模式的阶段中：</span></p>
<ul>
<li>IO0 (SO) 处于输出模式</li>
<li>IO1 (SI) 处于输入模式（高阻抗）</li>
<li>IO2 <span style="font-family: 宋体;">处于输出模式并强制置</span>“0”<span style="font-family: 宋体;">（以禁止</span>“写保护”功能）</li>
<li>IO3 <span style="font-family: 宋体;">处于输出模式并强制置</span>“1”<span style="font-family: 宋体;">（以禁止</span>“保持”功能）</li>
</ul>
<p class="21"><span style="font-family: 宋体;">若</span> DMODE = 01<span style="font-family: 宋体;">，这对于空指令阶段也同样如此。</span></p>
<h4>24.2.2 &nbsp;<span style="font-family: 黑体;">双线</span> SPI <span style="font-family: 黑体;">模式</span></h4>
<p class="21"><span style="font-family: 宋体;">在双线模式下，通过</span> IO0/IO1 <span style="font-family: 宋体;">信号同时发送</span><span style="font-family: &#39;Times New Roman&#39;;">/</span><span style="font-family: 宋体;">接收两位。通过将 </span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI_CCR </span><span style="font-family: 宋体;">寄存器的 </span><span style="font-family: &#39;Times New Roman&#39;;">IMODE/ADMODE/ABMODE/DMODE </span><span style="font-family: 宋体;">字段设置为 </span><span style="font-family: &#39;Times New Roman&#39;;">10</span><span style="font-family: 宋体;">，可对不同的命令阶段分别进行配置，以使用双线 </span><span style="font-family: &#39;Times New Roman&#39;;">SPI </span><span style="font-family: 宋体;">模式。在每个已配置为单线模式的阶段中：</span></p>
<ul>
<li>IO0/IO1 <span style="font-family: 宋体;">在数据阶段进行读取操作时处于高阻态（输入），在其他情况下为输出</span></li>
<li>IO2 <span style="font-family: 宋体;">处于输出模式并强制置</span>“0”</li>
<li>IO3 <span style="font-family: 宋体;">处于输出模式并强制置</span>“1”&nbsp;</li>
</ul>
<p class="21"><span style="font-family: 宋体;">在空指令阶段，若</span> DMODE = 01<span style="font-family: 宋体;">，则 </span><span style="font-family: &#39;Times New Roman&#39;;">IO0/IO1 </span><span style="font-family: 宋体;">始终保持高阻态。</span></p>
<h4>24.2.3 &nbsp;<span style="font-family: 黑体;">四线</span> SPI <span style="font-family: 黑体;">模式</span></h4>
<p class="21"><span style="font-family: 宋体;">在四线模式下，通过</span> IO0/IO1/IO2/IO3 <span style="font-family: 宋体;">信号同时发送</span><span style="font-family: &#39;Times New Roman&#39;;">/</span><span style="font-family: 宋体;">接收四位。通过将 </span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI_CCR </span><span style="font-family: 宋体;">寄存器的 </span><span style="font-family: &#39;Times New Roman&#39;;">IMODE/ADMODE/ABMODE/DMODE </span><span style="font-family: 宋体;">字段设置为 </span><span style="font-family: &#39;Times New Roman&#39;;">11</span><span style="font-family: 宋体;">，可对不同的命令阶段分别进行配置，以使用四线 </span><span style="font-family: &#39;Times New Roman&#39;;">SPI </span><span style="font-family: 宋体;">模式。在每个已配置为四线模式的阶段中，</span><span style="font-family: &#39;Times New Roman&#39;;">IO0/IO1/IO2/IO3 </span><span style="font-family: 宋体;">在数据阶段进行读取操作时均处于高阻态（输入），在其他情况下为输出。在空指令阶段中，若 </span><span style="font-family: &#39;Times New Roman&#39;;">DMODE = 11</span><span style="font-family: 宋体;">，则 </span><span style="font-family: &#39;Times New Roman&#39;;">IO0/IO1/IO2/IO3 </span><span style="font-family: 宋体;">均为高阻态。</span><span style="font-family: &#39;Times New Roman&#39;;">IO2 </span><span style="font-family: 宋体;">和 </span><span style="font-family: &#39;Times New Roman&#39;;">IO3 </span><span style="font-family: 宋体;">仅用于 </span><span style="font-family: &#39;Times New Roman&#39;;">Quad SPI </span><span style="font-family: 宋体;">模式 如果未配置任何阶段使用四线 </span><span style="font-family: &#39;Times New Roman&#39;;">SPI </span><span style="font-family: 宋体;">模式，即使 </span><span style="font-family: &#39;Times New Roman&#39;;">UADSPI</span><span style="font-family: 宋体;">激活，对应 </span><span style="font-family: &#39;Times New Roman&#39;;">IO2 </span><span style="font-family: 宋体;">和 </span><span style="font-family: &#39;Times New Roman&#39;;">IO3 </span><span style="font-family: 宋体;">的引脚也可用于其他功能。</span></p>
<h4>24.2.4 &nbsp;SDR <span style="font-family: 黑体;">模式</span></h4>
<p class="21"><span style="font-family: 宋体;">默认情况下，</span>DDRM <span style="font-family: 宋体;">位 </span><span style="font-family: &#39;Times New Roman&#39;;">(QUADSPI_CCR[31]) </span><span style="font-family: 宋体;">为 </span><span style="font-family: &#39;Times New Roman&#39;;">0</span><span style="font-family: 宋体;">，</span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI </span><span style="font-family: 宋体;">在单倍数据速率 </span><span style="font-family: &#39;Times New Roman&#39;;">(SDR) </span><span style="font-family: 宋体;">模式下工作。在 </span><span style="font-family: &#39;Times New Roman&#39;;">SDR </span><span style="font-family: 宋体;">模式下，当 </span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI </span><span style="font-family: 宋体;">驱动 </span><span style="font-family: &#39;Times New Roman&#39;;">IO0/SO</span><span style="font-family: 宋体;">、</span><span style="font-family: &#39;Times New Roman&#39;;">IO1</span><span style="font-family: 宋体;">、</span><span style="font-family: &#39;Times New Roman&#39;;">IO2</span><span style="font-family: 宋体;">、</span><span style="font-family: &#39;Times New Roman&#39;;">IO3 </span><span style="font-family: 宋体;">信号时，这些信号仅在 </span><span style="font-family: &#39;Times New Roman&#39;;">CLK</span><span style="font-family: 宋体;">的下降沿发生转变。在 </span><span style="font-family: &#39;Times New Roman&#39;;">SDR </span><span style="font-family: 宋体;">模式下接收数据时，</span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI </span><span style="font-family: 宋体;">假定 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">也通过 </span><span style="font-family: &#39;Times New Roman&#39;;">CLK </span><span style="font-family: 宋体;">的下降沿发送数据。默认情况下 </span><span style="font-family: &#39;Times New Roman&#39;;">(SSHIFT = 0 </span><span style="font-family: 宋体;">时</span><span style="font-family: &#39;Times New Roman&#39;;">)</span><span style="font-family: 宋体;">，将使用 </span><span style="font-family: &#39;Times New Roman&#39;;">CLK </span><span style="font-family: 宋体;">后续的边沿（上升沿）对信号进行采样。</span></p>
<h4>24.2.5 &nbsp;DDR <span style="font-family: 黑体;">模式</span></h4>
<p class="21"><span style="font-family: 宋体;">若</span> DDRM <span style="font-family: 宋体;">位 </span><span style="font-family: &#39;Times New Roman&#39;;">(QUADSPI_CCR[31]) </span><span style="font-family: 宋体;">置 </span><span style="font-family: &#39;Times New Roman&#39;;">1</span><span style="font-family: 宋体;">，则 </span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI </span><span style="font-family: 宋体;">在双倍数据速率 </span><span style="font-family: &#39;Times New Roman&#39;;">(DDR) </span><span style="font-family: 宋体;">模式下工作。在 </span><span style="font-family: &#39;Times New Roman&#39;;">DDR </span><span style="font-family: 宋体;">模式下，当 </span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI </span><span style="font-family: 宋体;">在地址</span><span style="font-family: &#39;Times New Roman&#39;;">/</span><span style="font-family: 宋体;">交替字节</span><span style="font-family: &#39;Times New Roman&#39;;">/</span><span style="font-family: 宋体;">数据阶段驱动 </span><span style="font-family: &#39;Times New Roman&#39;;">IO0/SO</span><span style="font-family: 宋体;">、</span><span style="font-family: &#39;Times New Roman&#39;;">IO1</span><span style="font-family: 宋体;">、</span><span style="font-family: &#39;Times New Roman&#39;;">IO2</span><span style="font-family: 宋体;">、</span><span style="font-family: &#39;Times New Roman&#39;;">IO3 </span><span style="font-family: 宋体;">信号时，将在 </span><span style="font-family: &#39;Times New Roman&#39;;">CLK </span><span style="font-family: 宋体;">的每个上升沿和下降沿发送 </span><span style="font-family: &#39;Times New Roman&#39;;">1 </span><span style="font-family: 宋体;">位。指令阶段不受 </span><span style="font-family: &#39;Times New Roman&#39;;">DDRM </span><span style="font-family: 宋体;">的影响。始终通过 </span><span style="font-family: &#39;Times New Roman&#39;;">CLK </span><span style="font-family: 宋体;">的下降沿发送指令。在 </span><span style="font-family: &#39;Times New Roman&#39;;">DDR </span><span style="font-family: 宋体;">模式下接收数据时，</span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI </span><span style="font-family: 宋体;">假定 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">通过 </span><span style="font-family: &#39;Times New Roman&#39;;">CLK </span><span style="font-family: 宋体;">的上升沿和下降沿均发送数据。若 </span><span style="font-family: &#39;Times New Roman&#39;;">DDRM = 1</span><span style="font-family: 宋体;">，固件必须清零 </span><span style="font-family: &#39;Times New Roman&#39;;">SSHIFT </span><span style="font-family: 宋体;">位 </span><span style="font-family: &#39;Times New Roman&#39;;">(QUADSPI_CR[4])</span><span style="font-family: 宋体;">。因此，在半个 </span><span style="font-family: &#39;Times New Roman&#39;;">CLK </span><span style="font-family: 宋体;">周期后（下一个反向边沿）对信号采样。四线模式下</span><span style="font-family: &#39;Times New Roman&#39;;">DDR</span><span style="font-family: 宋体;">命令时序见</span><span style="font-family: 宋体;">图</span> 24-3。</p>
<p align="center"><img src="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/896704-20180807100137137-598414568.png" alt=""></p>
<p align="center">&nbsp;</p>
<p align="center"><span style="font-family: 黑体;">图</span> 24-3&nbsp;<span style="font-family: 黑体;">四线模式下</span>DDR<span style="font-family: 黑体;">命令时序</span></p>
<p class="21">&nbsp;</p>
<h4>24.2.6 &nbsp;双闪存模式</h4>
<p><span style="font-family: 宋体;">若</span> DFM <span style="font-family: 宋体;">位 </span><span style="font-family: &#39;Times New Roman&#39;;">(QUADSPI_CR[6]) </span><span style="font-family: 宋体;">为 </span><span style="font-family: &#39;Times New Roman&#39;;">1</span><span style="font-family: 宋体;">，</span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI </span><span style="font-family: 宋体;">处于双闪存模式。</span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI </span><span style="font-family: 宋体;">使用两个外部四线 </span><span style="font-family: &#39;Times New Roman&#39;;">SPI Flash</span><span style="font-family: 宋体;">（</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH 1 </span><span style="font-family: 宋体;">和 </span><span style="font-family: &#39;Times New Roman&#39;;">FLASH 2</span><span style="font-family: 宋体;">），在每个周期中发送</span><span style="font-family: &#39;Times New Roman&#39;;">/</span><span style="font-family: 宋体;">接收 </span><span style="font-family: &#39;Times New Roman&#39;;">8 </span><span style="font-family: 宋体;">位（在 </span><span style="font-family: &#39;Times New Roman&#39;;">DDR </span><span style="font-family: 宋体;">模式下为</span><span style="font-family: &#39;Times New Roman&#39;;">16 </span><span style="font-family: 宋体;">位），能够有效地将吞吐量和容量扩大一倍。每个 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">使用同一个 </span><span style="font-family: &#39;Times New Roman&#39;;">CLK </span><span style="font-family: 宋体;">并可选择使用同一个 </span><span style="font-family: &#39;Times New Roman&#39;;">nCS </span><span style="font-family: 宋体;">信号，但其 </span><span style="font-family: &#39;Times New Roman&#39;;">IO0</span><span style="font-family: 宋体;">、</span><span style="font-family: &#39;Times New Roman&#39;;">IO1</span><span style="font-family: 宋体;">、</span><span style="font-family: &#39;Times New Roman&#39;;">IO2 </span><span style="font-family: 宋体;">和 </span><span style="font-family: &#39;Times New Roman&#39;;">IO3 </span><span style="font-family: 宋体;">信号是各自独立的。双闪存模式可与单比特模式、双比特模式以及四比特模式结合使用，也可与 </span><span style="font-family: &#39;Times New Roman&#39;;">SDR </span><span style="font-family: 宋体;">或 </span><span style="font-family: &#39;Times New Roman&#39;;">DDR </span><span style="font-family: 宋体;">模</span></p>
<p><span style="font-family: 宋体;">式相结合。</span>Flash <span style="font-family: 宋体;">的大小在 </span><span style="font-family: &#39;Times New Roman&#39;;">FSIZE[4:0] (QUADSPI_DCR[20:16]) </span><span style="font-family: 宋体;">中指定，指定的值应能够反映 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">的总容量，即单个组件容量的 </span><span style="font-family: &#39;Times New Roman&#39;;">2 </span><span style="font-family: 宋体;">倍。如果地址 </span><span style="font-family: &#39;Times New Roman&#39;;">X </span><span style="font-family: 宋体;">为偶数，</span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI </span><span style="font-family: 宋体;">赋给地址 </span><span style="font-family: &#39;Times New Roman&#39;;">X </span><span style="font-family: 宋体;">的字节是存放于 </span><span style="font-family: &#39;Times New Roman&#39;;">FLASH 1 </span><span style="font-family: 宋体;">的地址 </span><span style="font-family: &#39;Times New Roman&#39;;">X/2 </span><span style="font-family: 宋体;">中的字节，</span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI </span><span style="font-family: 宋体;">赋给地址 </span><span style="font-family: &#39;Times New Roman&#39;;">X+1 </span><span style="font-family: 宋体;">的字节是存放于 </span><span style="font-family: &#39;Times New Roman&#39;;">FLASH 2 </span><span style="font-family: 宋体;">的地址 </span><span style="font-family: &#39;Times New Roman&#39;;">X/2 </span><span style="font-family: 宋体;">中的字节。也就是说，偶地址中的字节存储于 </span><span style="font-family: &#39;Times New Roman&#39;;">FLASH 1</span><span style="font-family: 宋体;">，奇地址中的字节存储于 </span><span style="font-family: &#39;Times New Roman&#39;;">FLASH 2</span><span style="font-family: 宋体;">。</span></p>
<p><span style="font-family: 宋体;">在双闪存模式下读取</span> Flash <span style="font-family: 宋体;">状态寄存器时，需要读取的字节数是单闪存模式下的 </span><span style="font-family: &#39;Times New Roman&#39;;">2 </span><span style="font-family: 宋体;">倍。这意味着在状态寄存器获取指令到达后，如果每个 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">给出 </span><span style="font-family: &#39;Times New Roman&#39;;">8 </span><span style="font-family: 宋体;">个有效位，则 </span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI </span><span style="font-family: 宋体;">必须配置为 </span><span style="font-family: &#39;Times New Roman&#39;;">2 </span><span style="font-family: 宋体;">个字节（</span><span style="font-family: &#39;Times New Roman&#39;;">16 </span><span style="font-family: 宋体;">位）的数据长度，它将从每个 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">接收 </span><span style="font-family: &#39;Times New Roman&#39;;">1 </span><span style="font-family: 宋体;">个字节。如果每个 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">给出一个 </span><span style="font-family: &#39;Times New Roman&#39;;">16 </span><span style="font-family: 宋体;">位的状态，则 </span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI </span><span style="font-family: 宋体;">必须配置为读取 </span><span style="font-family: &#39;Times New Roman&#39;;">4 </span><span style="font-family: 宋体;">字节，以在双闪存模式下可获取两个</span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">的所有状态位。结果（在数据寄存器中）的最低有效字节是 </span><span style="font-family: &#39;Times New Roman&#39;;">FLASH 1 </span><span style="font-family: 宋体;">状态寄存器的最低有效字节，而下一个字节是 </span><span style="font-family: &#39;Times New Roman&#39;;">FLASH 2 </span><span style="font-family: 宋体;">状态寄存器的最低有效字节。数据寄存器的第三个字节是 </span><span style="font-family: &#39;Times New Roman&#39;;">FLASH 1 </span><span style="font-family: 宋体;">的第二个字节，第四个字节是 </span><span style="font-family: &#39;Times New Roman&#39;;">FLASH 2 </span><span style="font-family: 宋体;">的第二个字节（</span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">具有 </span><span style="font-family: &#39;Times New Roman&#39;;">16 </span><span style="font-family: 宋体;">位状态寄存器时）。</span></p>
<p><span style="font-family: 宋体;">偶数个字节必须始终在双闪存模式下访问。因此，若</span> DRM = 1<span style="font-family: 宋体;">，则数据长度字段</span><span style="font-family: &#39;Times New Roman&#39;;">(QUADSPI_DLR[0]) </span><span style="font-family: 宋体;">的位 </span><span style="font-family: &#39;Times New Roman&#39;;">0 </span><span style="font-family: 宋体;">始终保持为 </span><span style="font-family: &#39;Times New Roman&#39;;">1</span><span style="font-family: 宋体;">。</span></p>
<p><span style="font-family: 宋体;">在双闪存模式下，</span>FLASH 1 <span style="font-family: 宋体;">接口信号的行为基本上与正常模式下相同。在指令、地址、交替字节以及空指令周期阶段，</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH 2 </span><span style="font-family: 宋体;">接口信号具有与 </span><span style="font-family: &#39;Times New Roman&#39;;">FLASH 1 </span><span style="font-family: 宋体;">接口信号完全相同的波形。也就是说，每个 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">总是接收相同的指令与地址。然后，在数据阶段，</span><span style="font-family: &#39;Times New Roman&#39;;">BK1_IOx </span><span style="font-family: 宋体;">和</span><span style="font-family: &#39;Times New Roman&#39;;">BK2_IOx </span><span style="font-family: 宋体;">总线并行传输数据，但发送到 </span><span style="font-family: &#39;Times New Roman&#39;;">FLASH 1</span><span style="font-family: 宋体;">（或从其接收）的数据与 </span><span style="font-family: &#39;Times New Roman&#39;;">FLASH 2 </span><span style="font-family: 宋体;">中的不同。</span></p>
<h3>24.3 &nbsp;QUADSPI <span style="font-family: 黑体;">间接模式</span></h3>
<p><span style="font-family: 宋体;">在间接模式下，通过写入</span> QUADSPI <span style="font-family: 宋体;">寄存器来触发命令；并通过读写数据寄存器来传输数据，就如同对待其他通信外设那样。</span></p>
<p><span style="font-family: 宋体;">若</span> FMODE = 00 (QUADSPI_CCR[27:26])<span style="font-family: 宋体;">，则 </span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI </span><span style="font-family: 宋体;">处于间接写入模式，字节在数据阶段中发送到 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash</span><span style="font-family: 宋体;">。通过写入数据寄存器 </span><span style="font-family: &#39;Times New Roman&#39;;">(QUADSPI_DR) </span><span style="font-family: 宋体;">的方式提供数据。</span></p>
<p><span style="font-family: 宋体;">若</span> FMODE = 01<span style="font-family: 宋体;">，则 </span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI </span><span style="font-family: 宋体;">处于间接读取模式，在数据阶段中从 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">接收字节。通过读取 </span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI_DR </span><span style="font-family: 宋体;">来获取数据。</span></p>
<p><span style="font-family: 宋体;">读取</span>/<span style="font-family: 宋体;">写入的字节数在数据长度寄存器 </span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI_DLR) </span><span style="font-family: 宋体;">中指定。</span></p>
<p><span style="font-family: 宋体;">如果</span> QUADSPI_DLR =0xFFFF_FFFF<span style="font-family: 宋体;">（全为“</span><span style="font-family: &#39;Times New Roman&#39;;">1</span><span style="font-family: 宋体;">”），则数据长度视为未定义，</span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI </span><span style="font-family: 宋体;">将继续传输数据，直到到达（由 </span><span style="font-family: &#39;Times New Roman&#39;;">FSIZE </span><span style="font-family: 宋体;">定义的）</span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">的结尾。如果不传输任何字节，</span><span style="font-family: &#39;Times New Roman&#39;;">DMODE (QUADSPI_CCR[25:24])</span><span style="font-family: 宋体;">应设置为 </span><span style="font-family: &#39;Times New Roman&#39;;">00</span><span style="font-family: 宋体;">。如果 </span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI_DLR = 0xFFFF_FFFF </span><span style="font-family: 宋体;">并且 </span><span style="font-family: &#39;Times New Roman&#39;;">FSIZE = 0x1F</span><span style="font-family: 宋体;">（最大值指示一个 </span><span style="font-family: &#39;Times New Roman&#39;;">4GB </span><span style="font-family: 宋体;">的</span><span style="font-family: &#39;Times New Roman&#39;;">Flash</span><span style="font-family: 宋体;">），在此特殊情况下，传输将无限继续下去，仅在出现终止请求或 </span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI </span><span style="font-family: 宋体;">被禁止后停止。在读取最后一个存储器地址后（地址为 </span><span style="font-family: &#39;Times New Roman&#39;;">0xFFFF_FFFF</span><span style="font-family: 宋体;">），将从地址 </span><span style="font-family: &#39;Times New Roman&#39;;">= 0x0000_0000</span><span style="font-family: 宋体;">开始继续读取。</span></p>
<p><span style="font-family: 宋体;">当发送或接收的字节数达到编程设定值时，如果</span> TCIE = 1<span style="font-family: 宋体;">，则 </span><span style="font-family: &#39;Times New Roman&#39;;">TCF </span><span style="font-family: 宋体;">置 </span><span style="font-family: &#39;Times New Roman&#39;;">1 </span><span style="font-family: 宋体;">并产生中断。在数据数量不确定的情况下，将根据 </span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI_CR </span><span style="font-family: 宋体;">中定义的 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">大小，在达到外部 </span><span style="font-family: &#39;Times New Roman&#39;;">SPI </span><span style="font-family: 宋体;">的限制时，</span><span style="font-family: &#39;Times New Roman&#39;;">TCF </span><span style="font-family: 宋体;">置 </span><span style="font-family: &#39;Times New Roman&#39;;">1</span><span style="font-family: 宋体;">。</span></p>
<h4>24.3.1 &nbsp;触发命令启动</h4>
<p><span style="font-family: 宋体;">从本质上讲，在固件给出命令所需的最后一点信息时，命令即会启动。根据</span> QUADSPI <span style="font-family: 宋体;">的配置，在间接模式下有三种触发命令启动的方式。在出现以下情形时，命令立即启动：</span></p>
<p class="19">1、&nbsp;<span style="font-family: 宋体;">对</span> INSTRUCTION[7:0] (QUADSPI_CCR) <span style="font-family: 宋体;">执行写入操作，如果没有地址是必需的（当</span><span style="font-family: &#39;Times New Roman&#39;;">ADMODE = 00</span><span style="font-family: 宋体;">）并且不需要固件提供数据（当 </span><span style="font-family: &#39;Times New Roman&#39;;">FMODE = 01 </span><span style="font-family: 宋体;">或 </span><span style="font-family: &#39;Times New Roman&#39;;">DMODE = 00</span><span style="font-family: 宋体;">）；</span></p>
<p class="19">2、&nbsp;<span style="font-family: 宋体;">对</span> ADDRESS[31:0] (QUADSPI_AR) <span style="font-family: 宋体;">执行写入操作，如果地址是必需的（当 </span><span style="font-family: &#39;Times New Roman&#39;;">ADMODE =00</span><span style="font-family: 宋体;">）并且不需要固件提供数据 （当 </span><span style="font-family: &#39;Times New Roman&#39;;">FMODE = 01 </span><span style="font-family: 宋体;">或 </span><span style="font-family: &#39;Times New Roman&#39;;">DMODE = 00</span><span style="font-family: 宋体;">）；</span></p>
<p class="19">3、&nbsp;<span style="font-family: 宋体;">对</span> DATA[31:0] (QUADSPI_DR) <span style="font-family: 宋体;">执行写入操作，如果地址是必需的（当 </span><span style="font-family: &#39;Times New Roman&#39;;">ADMODE != 00</span><span style="font-family: 宋体;">）并且需要固件提供数据（当 </span><span style="font-family: &#39;Times New Roman&#39;;">FMODE = 00 </span><span style="font-family: 宋体;">并且 </span><span style="font-family: &#39;Times New Roman&#39;;">DMODE != 00</span><span style="font-family: 宋体;">）。</span></p>
<p><span style="font-family: 宋体;">写入交替字节寄存器</span> (QUADSPI_ABR) <span style="font-family: 宋体;">始终不会触发命令启动。如果需要交替字节，必须预先进行编程。如果命令启动，</span><span style="font-family: &#39;Times New Roman&#39;;">BUSY </span><span style="font-family: 宋体;">位（</span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI_SR </span><span style="font-family: 宋体;">的位 </span><span style="font-family: &#39;Times New Roman&#39;;">5</span><span style="font-family: 宋体;">）将自动置 </span><span style="font-family: &#39;Times New Roman&#39;;">1</span><span style="font-family: 宋体;">。</span></p>
<h4>24.3.2 &nbsp;FIFO <span style="font-family: 黑体;">和数据管理</span></h4>
<p><span style="font-family: 宋体;">在间接模式中，数据将通过</span> QUADSPI <span style="font-family: 宋体;">内部的一个 </span><span style="font-family: &#39;Times New Roman&#39;;">32 </span><span style="font-family: 宋体;">字节 </span><span style="font-family: &#39;Times New Roman&#39;;">FIFO</span><span style="font-family: 宋体;">。</span><span style="font-family: &#39;Times New Roman&#39;;">FLEVEL[5:0](QUADSPI_SR[13:8]) </span><span style="font-family: 宋体;">指示 </span><span style="font-family: &#39;Times New Roman&#39;;">FIFO </span><span style="font-family: 宋体;">目前保存了多少字节。</span></p>
<p><span style="font-family: 宋体;">在间接写入模式下</span> (FMODE = 00)<span style="font-family: 宋体;">，固件写入 </span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI_DR </span><span style="font-family: 宋体;">时，将在 </span><span style="font-family: &#39;Times New Roman&#39;;">FIFO </span><span style="font-family: 宋体;">中加入数据。字写入将在 </span><span style="font-family: &#39;Times New Roman&#39;;">FIFO </span><span style="font-family: 宋体;">中增加 </span><span style="font-family: &#39;Times New Roman&#39;;">4 </span><span style="font-family: 宋体;">个字节，半字写入增加 </span><span style="font-family: &#39;Times New Roman&#39;;">2 </span><span style="font-family: 宋体;">个字节，而字节写入仅增加 </span><span style="font-family: &#39;Times New Roman&#39;;">1 </span><span style="font-family: 宋体;">个字节。如果固件在 </span><span style="font-family: &#39;Times New Roman&#39;;">FIFO </span><span style="font-family: 宋体;">中加入的数据过多（超过 </span><span style="font-family: &#39;Times New Roman&#39;;">DL[31:0] </span><span style="font-family: 宋体;">指示的值），将在写入操作结束（</span><span style="font-family: &#39;Times New Roman&#39;;">TCF</span><span style="font-family: 宋体;">置 </span><span style="font-family: &#39;Times New Roman&#39;;">1</span><span style="font-family: 宋体;">）时从 </span><span style="font-family: &#39;Times New Roman&#39;;">FIFO </span><span style="font-family: 宋体;">中清除超出的字节。</span></p>
<p><span style="font-family: 宋体;">对</span> QUADSPI_DR <span style="font-family: 宋体;">的字节</span><span style="font-family: &#39;Times New Roman&#39;;">/</span><span style="font-family: 宋体;">半字访问必须仅针对该 </span><span style="font-family: &#39;Times New Roman&#39;;">32 </span><span style="font-family: 宋体;">位寄存器的最低有效字节</span><span style="font-family: &#39;Times New Roman&#39;;">/</span><span style="font-family: 宋体;">半字。</span><span style="font-family: &#39;Times New Roman&#39;;">FTHRES[3:0] </span><span style="font-family: 宋体;">用于定义 </span><span style="font-family: &#39;Times New Roman&#39;;">FIFO </span><span style="font-family: 宋体;">的阈值 如果达到阈值，</span><span style="font-family: &#39;Times New Roman&#39;;">FTF</span><span style="font-family: 宋体;">（</span><span style="font-family: &#39;Times New Roman&#39;;">FIFO </span><span style="font-family: 宋体;">阈值标志）置 </span><span style="font-family: &#39;Times New Roman&#39;;">1 </span><span style="font-family: 宋体;">在间接读取模式下，从 </span><span style="font-family: &#39;Times New Roman&#39;;">FIFO </span><span style="font-family: 宋体;">中读取的有效字节数超过阈值时，</span><span style="font-family: &#39;Times New Roman&#39;;">FTF </span><span style="font-family: 宋体;">置 </span><span style="font-family: &#39;Times New Roman&#39;;">1</span><span style="font-family: 宋体;">。从 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">中读取最后一个字节后，如果 </span><span style="font-family: &#39;Times New Roman&#39;;">FIFO </span><span style="font-family: 宋体;">中依然有数据，则无论 </span><span style="font-family: &#39;Times New Roman&#39;;">FTHRES </span><span style="font-family: 宋体;">的设置为何，</span><span style="font-family: &#39;Times New Roman&#39;;">FTF </span><span style="font-family: 宋体;">也都会置 </span><span style="font-family: &#39;Times New Roman&#39;;">1</span><span style="font-family: 宋体;">。在间接写入模式下，当 </span><span style="font-family: &#39;Times New Roman&#39;;">FIFO </span><span style="font-family: 宋体;">中的空字节数超过阈值时，</span><span style="font-family: &#39;Times New Roman&#39;;">FTF </span><span style="font-family: 宋体;">置 </span><span style="font-family: &#39;Times New Roman&#39;;">1</span><span style="font-family: 宋体;">。</span></p>
<p><span style="font-family: 宋体;">如果</span> FTIE = 1<span style="font-family: 宋体;">，则 </span><span style="font-family: &#39;Times New Roman&#39;;">FTF </span><span style="font-family: 宋体;">置 </span><span style="font-family: &#39;Times New Roman&#39;;">1 </span><span style="font-family: 宋体;">时产生中断。如果 </span><span style="font-family: &#39;Times New Roman&#39;;">DMAEN = 1</span><span style="font-family: 宋体;">，则 </span><span style="font-family: &#39;Times New Roman&#39;;">FTF </span><span style="font-family: 宋体;">置 </span><span style="font-family: &#39;Times New Roman&#39;;">1 </span><span style="font-family: 宋体;">时启动数据传送。如果阈值条件不再为“真”（</span><span style="font-family: &#39;Times New Roman&#39;;">CPU </span><span style="font-family: 宋体;">或 </span><span style="font-family: &#39;Times New Roman&#39;;">DMA </span><span style="font-family: 宋体;">传输了足够的数据后），则 </span><span style="font-family: &#39;Times New Roman&#39;;">FTF </span><span style="font-family: 宋体;">由 </span><span style="font-family: &#39;Times New Roman&#39;;">HW </span><span style="font-family: 宋体;">清零。在间接模式下，当 </span><span style="font-family: &#39;Times New Roman&#39;;">FIFO </span><span style="font-family: 宋体;">已满，</span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI </span><span style="font-family: 宋体;">将暂时停止从 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">读取字节以避免上溢。请注意，只有在 </span><span style="font-family: &#39;Times New Roman&#39;;">FIFO </span><span style="font-family: 宋体;">中的 </span><span style="font-family: &#39;Times New Roman&#39;;">4 </span><span style="font-family: 宋体;">个字节为空 </span><span style="font-family: &#39;Times New Roman&#39;;">(FLEVEL </span><span style="font-family: 宋体;">≤ </span><span style="font-family: &#39;Times New Roman&#39;;">11) </span><span style="font-family: 宋体;">时才会重新开始读取 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash</span><span style="font-family: 宋体;">。因此，若</span><span style="font-family: &#39;Times New Roman&#39;;">FTHRES </span><span style="font-family: 宋体;">≥ </span><span style="font-family: &#39;Times New Roman&#39;;">13</span><span style="font-family: 宋体;">，应用程序必须读取足够的字节以确保 </span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI </span><span style="font-family: 宋体;">再次从 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">检索数据。否则，只要 </span><span style="font-family: &#39;Times New Roman&#39;;">11 &lt; FLEVEL &lt; FTHRES</span><span style="font-family: 宋体;">，</span><span style="font-family: &#39;Times New Roman&#39;;">FTF </span><span style="font-family: 宋体;">标志将保持为“</span><span style="font-family: &#39;Times New Roman&#39;;">0</span><span style="font-family: 宋体;">”。</span></p>
<h3>24.4 &nbsp;QUADSPI Flash <span style="font-family: 黑体;">配置</span></h3>
<p><span style="font-family: 宋体;">外部</span> SPI Flash<span style="font-family: 宋体;">的参数可以通过配置寄存器 </span><span style="font-family: &#39;Times New Roman&#39;;">(QUADSPI_DCR)</span><span style="font-family: 宋体;">实现。这里配置</span><span style="font-family: &#39;Times New Roman&#39;;">Flash</span><span style="font-family: 宋体;">的容量是设置</span><span style="font-family: &#39;Times New Roman&#39;;">FSIZE[4:0] </span><span style="font-family: 宋体;">字段，使用下面的公式定义外部存储器的大小： </span></p>
<p align="center">&nbsp;</p>
<p align="center">FSIZE+1 <span style="font-family: 宋体;">是对 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">寻址所需的地址位数。在间接模式下，</span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">容量最高可达 </span><span style="font-family: &#39;Times New Roman&#39;;">4GB</span><span style="font-family: 宋体;">（使用</span><span style="font-family: &#39;Times New Roman&#39;;">32 </span><span style="font-family: 宋体;">位进行寻址），但在内存映射模式下的可寻址空间限制为 </span><span style="font-family: &#39;Times New Roman&#39;;">256MB</span><span style="font-family: 宋体;">。如果 </span><span style="font-family: &#39;Times New Roman&#39;;">DFM = 1</span><span style="font-family: 宋体;">，</span><span style="font-family: &#39;Times New Roman&#39;;">FSIZE </span><span style="font-family: 宋体;">表示两个 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">容量的总和。</span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI </span><span style="font-family: 宋体;">连续执行两条命令时，它在两条命令之间将片选信号 </span><span style="font-family: &#39;Times New Roman&#39;;">(nCS) </span><span style="font-family: 宋体;">置为高电平默认仅一个 </span><span style="font-family: &#39;Times New Roman&#39;;">CLK </span><span style="font-family: 宋体;">周期时长。如果 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">需要命令之间的时间更长，可使用片选高电平时间 </span><span style="font-family: &#39;Times New Roman&#39;;">(CSHT) </span><span style="font-family: 宋体;">字段指定 </span><span style="font-family: &#39;Times New Roman&#39;;">nCS </span><span style="font-family: 宋体;">必须保持高电平的最少 </span><span style="font-family: &#39;Times New Roman&#39;;">CLK </span><span style="font-family: 宋体;">周期数（最大为 </span><span style="font-family: &#39;Times New Roman&#39;;">8</span><span style="font-family: 宋体;">）。时钟模式 </span><span style="font-family: &#39;Times New Roman&#39;;">(CKMODE) </span><span style="font-family: 宋体;">位指示命令之间的 </span><span style="font-family: &#39;Times New Roman&#39;;">CLK </span><span style="font-family: 宋体;">信号逻辑电平（</span><span style="font-family: &#39;Times New Roman&#39;;">nCS = 1 </span><span style="font-family: 宋体;">时）。</span></p>
<h3>24.5 &nbsp;QSPI<span style="font-family: 黑体;">初始化结构体详解</span></h3>
<p class="21"><span style="font-family: 宋体;">跟其它外设一样，</span>STM32 HAL<span style="font-family: 宋体;">库提供了</span><span style="font-family: &#39;Times New Roman&#39;;">QSPI</span><span style="font-family: 宋体;">初始化结构体及初始化函数来配置</span><span style="font-family: &#39;Times New Roman&#39;;">SPI</span><span style="font-family: 宋体;">外设。初始化结构体及函数定义在库文件“</span><span style="font-family: &#39;Times New Roman&#39;;">stm32f7xx_hal_spi.h</span><span style="font-family: 宋体;">”及“</span><span style="font-family: &#39;Times New Roman&#39;;">stm32f7xx_hal _spi.c</span><span style="font-family: 宋体;">”中，编程时我们可以结合这两个文件内的注释使用或参考库帮助文档。了解初始化结构体后我们就能对</span><span style="font-family: &#39;Times New Roman&#39;;">SPI</span><span style="font-family: 宋体;">外设运用自如了，见</span><span style="font-family: 宋体;">代码清单</span> 241<span style="font-family: 宋体;">。</span></p>
<p><span style="font-family: 黑体;">代码清单</span> 241&nbsp;QSPI_InitTypeDef初始化结构体</p>
<p>1 typedef&nbsp;struct&nbsp;{</p>
<p>&nbsp;2 &nbsp;&nbsp;&nbsp;&nbsp;uint32_t&nbsp;ClockPrescaler; &nbsp;&nbsp;&nbsp;&nbsp;//<span style="font-family: 宋体;">预分频因子</span></p>
<p>&nbsp;3 &nbsp;&nbsp;&nbsp;&nbsp;uint32_t&nbsp;FifoThreshold; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//FIFO<span style="font-family: 宋体;">中的阈值</span></p>
<p>&nbsp;4 &nbsp;&nbsp;&nbsp;&nbsp;uint32_t&nbsp;SampleShifting; &nbsp;&nbsp;&nbsp;&nbsp;//<span style="font-family: 宋体;">采样移位</span></p>
<p>&nbsp;5 &nbsp;&nbsp;&nbsp;&nbsp;uint32_t&nbsp;FlashSize; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Flash<span style="font-family: 宋体;">大小</span></p>
<p>&nbsp;6 &nbsp;&nbsp;&nbsp;&nbsp;uint32_t&nbsp;ChipSelectHighTime; //<span style="font-family: 宋体;">片选高电平时间</span></p>
<p>&nbsp;7 &nbsp;&nbsp;&nbsp;&nbsp;uint32_t&nbsp;ClockMode; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<span style="font-family: 宋体;">时钟模式</span></p>
<p>&nbsp;8 &nbsp;&nbsp;&nbsp;&nbsp;uint32_t&nbsp;FlashID; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Flash ID</p>
<p>&nbsp;9 &nbsp;&nbsp;&nbsp;&nbsp;uint32_t&nbsp;DualFlash; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<span style="font-family: 宋体;">双闪存模式</span></p>
<p class="21">10 } QSPI_InitTypeDef;</p>
<p class="21"><span style="font-family: 宋体;">这些结构体成员说明如下，其中括号内的文字是对应参数在</span>STM32 HAL<span style="font-family: 宋体;">库中定义的宏：</span></p>
<p class="23">(1)&nbsp;ClockPrescaler</p>
<p class="21">本成员设置预分频因子，对应寄存器QUADSPI_CR&nbsp;[31:24]<span style="font-family: 宋体;">即</span>PRESCALER[7:0]<span style="font-family: 宋体;">，取值范围是</span>0<span style="font-family: 宋体;">—</span><span style="font-family: &#39;Times New Roman&#39;;">255</span><span style="font-family: 宋体;">，可以实现</span><span style="font-family: &#39;Times New Roman&#39;;">1</span><span style="font-family: 宋体;">—</span><span style="font-family: &#39;Times New Roman&#39;;">256</span><span style="font-family: 宋体;">级别的分频。仅可在 </span><span style="font-family: &#39;Times New Roman&#39;;">BUSY = 0 </span><span style="font-family: 宋体;">时修改该字段。</span></p>
<p class="23">(2)&nbsp;FifoThreshold</p>
<p class="21">本成员设置FIFO <span style="font-family: 宋体;">阈值级别，对应寄存器</span>QUADSPI_CR&nbsp;[12:8]<span style="font-family: 宋体;">即</span><span style="font-family: &#39;Times New Roman&#39;;">FTHRES[4:0]</span><span style="font-family: 宋体;">，定义在间接模式下</span> FIFO <span style="font-family: 宋体;">中将导致 </span><span style="font-family: &#39;Times New Roman&#39;;">FIFO </span><span style="font-family: 宋体;">阈值标志（</span><span style="font-family: &#39;Times New Roman&#39;;">FTF</span><span style="font-family: 宋体;">，</span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI_SR[2]</span><span style="font-family: 宋体;">）置 </span><span style="font-family: &#39;Times New Roman&#39;;">1 </span><span style="font-family: 宋体;">的字节数阈值。</span></p>
<p class="23">(3)&nbsp;SampleShifting</p>
<p class="21">本成员设置采样，对应寄存器QUADSPI_CR&nbsp;[4]<span style="font-family: 宋体;">，默认情况下，</span>QUADSPI <span style="font-family: 宋体;">在 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">驱动数据后过半个 </span><span style="font-family: &#39;Times New Roman&#39;;">CLK </span><span style="font-family: 宋体;">周期开始采集数据。使用该位，可考虑外部信号延迟，推迟数据采集。可以取值</span><span style="font-family: &#39;Times New Roman&#39;;">0</span><span style="font-family: 宋体;">：不发生移位；</span><span style="font-family: &#39;Times New Roman&#39;;">1</span><span style="font-family: 宋体;">：移位半个周期。在 </span><span style="font-family: &#39;Times New Roman&#39;;">DDR </span><span style="font-family: 宋体;">模式下 </span><span style="font-family: &#39;Times New Roman&#39;;">(DDRM = 1)</span><span style="font-family: 宋体;">，固件必须确保 </span><span style="font-family: &#39;Times New Roman&#39;;">SSHIFT = 0</span><span style="font-family: 宋体;">。</span></p>
<p class="23">(4)&nbsp;FlashSize</p>
<p class="21">本成员设置FLASH<span style="font-family: 宋体;">大小，对应寄存器</span>QUADSPI_CCR&nbsp;[20:16]<span style="font-family: 宋体;">的</span><span style="font-family: &#39;Times New Roman&#39;;">FSIZE[4:0]</span><span style="font-family: 宋体;">位</span><span style="font-family: 宋体;">。定义外部存储器的大小，简介模式</span>Flash<span style="font-family: 宋体;">容量最高可达</span><span style="font-family: &#39;Times New Roman&#39;;">4GB</span><span style="font-family: 宋体;">（</span><span style="font-family: &#39;Times New Roman&#39;;">32</span><span style="font-family: 宋体;">位寻址），但是在内存映射模式下限制为</span><span style="font-family: &#39;Times New Roman&#39;;">256MB</span><span style="font-family: 宋体;">，如果是双闪存则可以达到</span><span style="font-family: &#39;Times New Roman&#39;;">512MB</span><span style="font-family: 宋体;">。</span></p>
<p class="23">(5)&nbsp;ChipSelectHighTime</p>
<p class="21">本成员设置片选高电平时间，对应寄存器QUADSPI_CR&nbsp;[10:8]<span style="font-family: 宋体;">的</span><span style="font-family: &#39;Times New Roman&#39;;">CSHT[2:0]</span><span style="font-family: 宋体;">位</span><span style="font-family: 宋体;">，定义片选</span> (nCS) <span style="font-family: 宋体;">在发送至 </span><span style="font-family: &#39;Times New Roman&#39;;">Flash </span><span style="font-family: 宋体;">的命令之间必须保持高电平的最少 </span><span style="font-family: &#39;Times New Roman&#39;;">CLK </span><span style="font-family: 宋体;">周期数。可以取值</span><span style="font-family: &#39;Times New Roman&#39;;">1~8</span><span style="font-family: 宋体;">个周期。</span></p>
<p class="23">(6)&nbsp;ClockMode</p>
<p class="21">本成员设置时钟模式，对应寄存器QUADSPI_CR&nbsp;[0]<span style="font-family: 宋体;">位</span><span style="font-family: 宋体;">，指示</span>CLK<span style="font-family: 宋体;">在命令之间的电平，可以选模式</span><span style="font-family: &#39;Times New Roman&#39;;">0</span><span style="font-family: 宋体;">，</span><span style="font-family: &#39;Times New Roman&#39;;">1</span><span style="font-family: 宋体;">： </span><span style="font-family: &#39;Times New Roman&#39;;">nCS </span><span style="font-family: 宋体;">为高电平（片选释放）时，</span><span style="font-family: &#39;Times New Roman&#39;;">CLK </span><span style="font-family: 宋体;">必须保持低电平；或者模式</span><span style="font-family: &#39;Times New Roman&#39;;">3 </span><span style="font-family: 宋体;">，</span><span style="font-family: &#39;Times New Roman&#39;;">1</span><span style="font-family: 宋体;">：</span><span style="font-family: &#39;Times New Roman&#39;;">nCS </span><span style="font-family: 宋体;">为高电平（片选释放）时，</span><span style="font-family: &#39;Times New Roman&#39;;">CLK </span><span style="font-family: 宋体;">必须保持高电平。</span></p>
<p class="23">(7)&nbsp;FlashID</p>
<p class="21"><span style="font-family: 宋体;">本成员用于选择</span>Flash1<span style="font-family: 宋体;">或者</span><span style="font-family: &#39;Times New Roman&#39;;">Flash2</span><span style="font-family: 宋体;">，单闪存模式下选择需要访问的</span>flash<span style="font-family: 宋体;">。</span></p>
<p class="23">(8)&nbsp;DualFlash</p>
<p class="21">本成员用于激活双闪存模式<span style="font-family: 宋体;">，</span>0<span style="font-family: 宋体;">：禁止双闪存模式；</span><span style="font-family: &#39;Times New Roman&#39;;">1</span><span style="font-family: 宋体;">：使能双闪存模式。双闪存模式可以使系统吞吐量和容量扩大一倍。</span></p>
<p><span style="font-family: 黑体;">代码清单</span> 242&nbsp;QSPI_CommandTypeDe通信配置命令结构体</p>
<p>1 typedef&nbsp;struct&nbsp;{</p>
<p>&nbsp;2 &nbsp;&nbsp;&nbsp;&nbsp;uint32_t&nbsp;Instruction; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<span style="font-family: 宋体;">指令</span></p>
<p>&nbsp;3 &nbsp;&nbsp;&nbsp;&nbsp;uint32_t&nbsp;Address; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<span style="font-family: 宋体;">地址</span></p>
<p>&nbsp;4 &nbsp;&nbsp;&nbsp;&nbsp;uint32_t&nbsp;AlternateBytes; &nbsp;&nbsp;&nbsp;&nbsp;//<span style="font-family: 宋体;">交替字节</span></p>
<p>&nbsp;5 &nbsp;&nbsp;&nbsp;&nbsp;uint32_t&nbsp;AddressSize; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<span style="font-family: 宋体;">地址长度</span></p>
<p>&nbsp;6 &nbsp;&nbsp;&nbsp;&nbsp;uint32_t&nbsp;AlternateBytesSize; //<span style="font-family: 宋体;">交替字节长度</span></p>
<p>&nbsp;7 &nbsp;&nbsp;&nbsp;&nbsp;uint32_t&nbsp;DummyCycles; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<span style="font-family: 宋体;">空指令周期</span></p>
<p>&nbsp;8 &nbsp;&nbsp;&nbsp;&nbsp;uint32_t&nbsp;InstructionMode; &nbsp;&nbsp;&nbsp;//<span style="font-family: 宋体;">指令模式</span></p>
<p>&nbsp;9 &nbsp;&nbsp;&nbsp;&nbsp;uint32_t&nbsp;AddressMode; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<span style="font-family: 宋体;">地址模式</span></p>
<p>10 &nbsp;&nbsp;&nbsp;&nbsp;uint32_t&nbsp;AlternateByteMode; &nbsp;//<span style="font-family: 宋体;">交替字节模式</span></p>
<p>11 &nbsp;&nbsp;&nbsp;&nbsp;uint32_t&nbsp;DataMode; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<span style="font-family: 宋体;">数据模式</span></p>
<p>12 &nbsp;&nbsp;&nbsp;&nbsp;uint32_t&nbsp;NbData; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<span style="font-family: 宋体;">数据长度</span></p>
<p>13 &nbsp;&nbsp;&nbsp;&nbsp;uint32_t&nbsp;DdrMode; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<span style="font-family: 宋体;">双倍数据速率模式</span></p>
<p>14 &nbsp;&nbsp;&nbsp;&nbsp;uint32_t&nbsp;DdrHoldHalfCycle; &nbsp;&nbsp;//DDR<span style="font-family: 宋体;">保持周期</span></p>
<p>15 &nbsp;&nbsp;&nbsp;&nbsp;uint32_t&nbsp;SIOOMode; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<span style="font-family: 宋体;">仅发送指令一次模式</span></p>
<p class="21">16 } QSPI_CommandTypeDef;&nbsp;</p>
<p class="21"><span style="font-family: 宋体;">这些结构体成员说明如下，其中括号内的文字是对应参数在</span>STM32 HAL<span style="font-family: 宋体;">库中定义的宏：</span></p>
<p class="23">(1)&nbsp;Instruction</p>
<p class="21"><span style="font-family: 宋体;">本成员设置通信指令，指定要发送到外部</span> SPI <span style="font-family: 宋体;">设备的指令。仅可在 </span><span style="font-family: &#39;Times New Roman&#39;;">BUSY = 0 </span><span style="font-family: 宋体;">时修改该字段。</span></p>
<p class="23">(2)&nbsp;Address</p>
<p class="21"><span style="font-family: 宋体;">本成员指定要发送到外部</span> Flash <span style="font-family: 宋体;">的地址，</span><span style="font-family: &#39;Times New Roman&#39;;">BUSY = 0 </span><span style="font-family: 宋体;">或 </span><span style="font-family: &#39;Times New Roman&#39;;">FMODE = 11</span><span style="font-family: 宋体;">（内存映射模式）时，将忽略写入该字段。在双闪存模式下，由于地址始终为偶地址，</span><span style="font-family: &#39;Times New Roman&#39;;">ADDRESS[0] </span><span style="font-family: 宋体;">自动保持为“</span><span style="font-family: &#39;Times New Roman&#39;;">0</span><span style="font-family: 宋体;">”。</span></p>
<p class="23">(3)&nbsp;AlternateBytes</p>
<p class="21"><span style="font-family: 宋体;">本成员指定要在地址后立即发送到外部</span> SPI <span style="font-family: 宋体;">设备的可选数据，仅可在 </span><span style="font-family: &#39;Times New Roman&#39;;">BUSY = 0 </span><span style="font-family: 宋体;">时修改该字段。</span></p>
<p class="23">(4)&nbsp;AddressSize</p>
<p class="21"><span style="font-family: 宋体;">本成员定义地址长度，可以是</span>8<span style="font-family: 宋体;">位，</span><span style="font-family: &#39;Times New Roman&#39;;">16</span><span style="font-family: 宋体;">位，</span><span style="font-family: &#39;Times New Roman&#39;;">24</span><span style="font-family: 宋体;">位或者</span><span style="font-family: &#39;Times New Roman&#39;;">32</span><span style="font-family: 宋体;">位。</span></p>
<p class="23">(5)&nbsp;AlternateBytesSize</p>
<p class="21"><span style="font-family: 宋体;">本成员定义交替字节长度，可以是</span>8<span style="font-family: 宋体;">位，</span><span style="font-family: &#39;Times New Roman&#39;;">16</span><span style="font-family: 宋体;">位，</span><span style="font-family: &#39;Times New Roman&#39;;">24</span><span style="font-family: 宋体;">位或者</span><span style="font-family: &#39;Times New Roman&#39;;">32</span><span style="font-family: 宋体;">位。</span></p>
<p class="23">(6)&nbsp;DummyCycles</p>
<p class="21"><span style="font-family: 宋体;">本成员定义空指令阶段的持续时间，在</span> SDR <span style="font-family: 宋体;">和 </span><span style="font-family: &#39;Times New Roman&#39;;">DDR </span><span style="font-family: 宋体;">模式下，它指定 </span><span style="font-family: &#39;Times New Roman&#39;;">CLK </span><span style="font-family: 宋体;">周期数 </span><span style="font-family: &#39;Times New Roman&#39;;">(0-31)</span><span style="font-family: 宋体;">。</span></p>
<p class="23">(7)&nbsp;InstructionMode</p>
<p class="21"><span style="font-family: 宋体;">本成员定义指令阶段的操作模式，</span>00<span style="font-family: 宋体;">：无指令；</span><span style="font-family: &#39;Times New Roman&#39;;">01</span><span style="font-family: 宋体;">：单线传输指令；</span><span style="font-family: &#39;Times New Roman&#39;;">10</span><span style="font-family: 宋体;">：双线传输指令；</span><span style="font-family: &#39;Times New Roman&#39;;">11</span><span style="font-family: 宋体;">：四线传输指令。</span></p>
<p class="23">(8)&nbsp;AddressMode</p>
<p class="21"><span style="font-family: 宋体;">本成员定义地址阶段的操作模式，</span>00<span style="font-family: 宋体;">：无地址；</span><span style="font-family: &#39;Times New Roman&#39;;">01</span><span style="font-family: 宋体;">：单线传输地址；</span><span style="font-family: &#39;Times New Roman&#39;;">10</span><span style="font-family: 宋体;">：双线传输地址；</span><span style="font-family: &#39;Times New Roman&#39;;">11</span><span style="font-family: 宋体;">：四线传输地址。</span></p>
<p class="23">(9)&nbsp;AlternateByteMode</p>
<p class="21"><span style="font-family: 宋体;">本成员定义交替字节阶段的操作模式</span>00<span style="font-family: 宋体;">：无交替字节；</span><span style="font-family: &#39;Times New Roman&#39;;">01</span><span style="font-family: 宋体;">：单线传输交替字节；</span><span style="font-family: &#39;Times New Roman&#39;;">10</span><span style="font-family: 宋体;">：双线传输交替字节；</span><span style="font-family: &#39;Times New Roman&#39;;">11</span><span style="font-family: 宋体;">：四线传输交替字节。</span></p>
<p class="23">(10)&nbsp;DataMode</p>
<p class="21"><span style="font-family: 宋体;">本成员定义数据阶段的操作模式，</span>00<span style="font-family: 宋体;">：无数据；</span><span style="font-family: &#39;Times New Roman&#39;;">01</span><span style="font-family: 宋体;">：单线传输数据；</span><span style="font-family: &#39;Times New Roman&#39;;">10</span><span style="font-family: 宋体;">：双线传输数据；</span><span style="font-family: &#39;Times New Roman&#39;;">11</span><span style="font-family: 宋体;">：四线传输数据。该字段还定义空指令阶段的操作模式。</span></p>
<p class="23">(11)&nbsp;NbData</p>
<p class="21"><span style="font-family: 宋体;">本成员设置数据长度，在间接模式和状态轮询模式下待检索的数据数量（值</span> + 1<span style="font-family: 宋体;">）。对状态轮询模式应使用不大于 </span><span style="font-family: &#39;Times New Roman&#39;;">3 </span><span style="font-family: 宋体;">的值（表示 </span><span style="font-family: &#39;Times New Roman&#39;;">4 </span><span style="font-family: 宋体;">字节）。</span></p>
<p class="23">(12)&nbsp;DdrMode</p>
<p class="21"><span style="font-family: 宋体;">本成员为地址、交替字节和数据阶段设置</span> DDR <span style="font-family: 宋体;">模式，</span><span style="font-family: &#39;Times New Roman&#39;;">0</span><span style="font-family: 宋体;">：禁止 </span><span style="font-family: &#39;Times New Roman&#39;;">DDR </span><span style="font-family: 宋体;">模式；</span><span style="font-family: &#39;Times New Roman&#39;;">1</span><span style="font-family: 宋体;">：使能 </span><span style="font-family: &#39;Times New Roman&#39;;">DDR </span><span style="font-family: 宋体;">模式。</span></p>
<p class="23">(13)&nbsp;DdrHoldHalfCycle</p>
<p class="21"><span style="font-family: 宋体;">本成员设置</span>DDR <span style="font-family: 宋体;">模式下数据输出延迟 </span><span style="font-family: &#39;Times New Roman&#39;;">1/4 </span><span style="font-family: 宋体;">个 </span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI </span><span style="font-family: 宋体;">输出时钟周期，</span><span style="font-family: &#39;Times New Roman&#39;;">0</span><span style="font-family: 宋体;">：使用模拟延迟来延迟数据输出；</span><span style="font-family: &#39;Times New Roman&#39;;">1</span><span style="font-family: 宋体;">：数据输出延迟 </span><span style="font-family: &#39;Times New Roman&#39;;">1/4 </span><span style="font-family: 宋体;">个 </span><span style="font-family: &#39;Times New Roman&#39;;">QUADSPI </span><span style="font-family: 宋体;">输出时钟周期。仅在 </span><span style="font-family: &#39;Times New Roman&#39;;">DDR </span><span style="font-family: 宋体;">模式下激活。</span></p>
<p class="23">(14)&nbsp;SIOOMode</p>
<p class="21"><span style="font-family: 宋体;">本成员设置仅发送指令一次模式，。</span>IMODE = 00 <span style="font-family: 宋体;">时，该位不起作用。</span><span style="font-family: &#39;Times New Roman&#39;;">0</span><span style="font-family: 宋体;">：在每个事务中发送指令；</span><span style="font-family: &#39;Times New Roman&#39;;">1</span><span style="font-family: 宋体;">：仅为第一条命令发送指令。</span></p>
<h3>24.6 &nbsp;QSPI<span style="font-family: 黑体;">—读写串行</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 黑体;">实验</span></h3>
<p class="21">FLSAH<span style="font-family: 宋体;">存储器又称闪存，它与</span><span style="font-family: &#39;Times New Roman&#39;;">EEPROM</span><span style="font-family: 宋体;">都是掉电后数据不丢失的存储器，但</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">存储器容量普遍大于</span><span style="font-family: &#39;Times New Roman&#39;;">EEPROM</span><span style="font-family: 宋体;">，现在基本取代了它的地位。我们生活中常用的</span><span style="font-family: &#39;Times New Roman&#39;;">U</span><span style="font-family: 宋体;">盘、</span><span style="font-family: &#39;Times New Roman&#39;;">SD</span><span style="font-family: 宋体;">卡、</span><span style="font-family: &#39;Times New Roman&#39;;">SSD</span><span style="font-family: 宋体;">固态硬盘以及我们</span><span style="font-family: &#39;Times New Roman&#39;;">STM32</span><span style="font-family: 宋体;">芯片内部用于存储程序的设备，都是</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">类型的存储器。在存储控制上，最主要的区别是</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">芯片只能一大片一大片地擦写，而在“</span><span style="font-family: &#39;Times New Roman&#39;;">I2C</span><span style="font-family: 宋体;">章节”中我们了解到</span><span style="font-family: &#39;Times New Roman&#39;;">EEPROM</span><span style="font-family: 宋体;">可以单个字节擦写。</span></p>
<p class="21"><span style="font-family: 宋体;">本小节以一种使用</span>QSPI<span style="font-family: 宋体;">通讯的串行</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">存储芯片的读写实验为大家讲解</span><span style="font-family: &#39;Times New Roman&#39;;">STM32</span><span style="font-family: 宋体;">的</span><span style="font-family: &#39;Times New Roman&#39;;">QSPI</span><span style="font-family: 宋体;">使用方法。实验中</span><span style="font-family: &#39;Times New Roman&#39;;">STM32</span><span style="font-family: 宋体;">的</span><span style="font-family: &#39;Times New Roman&#39;;">QSPI</span><span style="font-family: 宋体;">外设采用主模式，通过查询事件的方式来确保正常通讯。</span></p>
<h4>24.6.1 &nbsp;硬件设计</h4>
<p style="text-align: center;">&nbsp;<img src="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/896704-20180807100240241-1587150545.png" alt=""></p>
<p>&nbsp;</p>
<p align="center"><span style="font-family: 黑体;">图</span> 24-4&nbsp;SPI<span style="font-family: 黑体;">串行</span><span style="font-family: Cambria;">FLASH</span><span style="font-family: 黑体;">硬件连接图</span></p>
<p class="21"><span style="font-family: 宋体;">本实验板中的</span>FLASH<span style="font-family: 宋体;">芯片</span><span style="font-family: &#39;Times New Roman&#39;;">(</span><span style="font-family: 宋体;">型号：</span><span style="font-family: &#39;Times New Roman&#39;;">W25Q128)</span><span style="font-family: 宋体;">是一种使用</span><span style="font-family: &#39;Times New Roman&#39;;">QSPI/SPI</span><span style="font-family: 宋体;">通讯协议的</span><span style="font-family: &#39;Times New Roman&#39;;">NOR FLASH</span><span style="font-family: 宋体;">存储器，它的</span><span style="font-family: &#39;Times New Roman&#39;;">CS/CLK/D0/D1/D2/D3</span><span style="font-family: 宋体;">引脚分别连接到了</span><span style="font-family: &#39;Times New Roman&#39;;">STM32</span><span style="font-family: 宋体;">对应的</span><span style="font-family: &#39;Times New Roman&#39;;">QSPI</span><span style="font-family: 宋体;">引脚</span>QUADSPI_BK1_NCS/&nbsp;QUADSPI_CLK&nbsp;/&nbsp;QUADSPI_BK1_IO0/&nbsp;QUADSPI_BK1_IO1/&nbsp;QUADSPI_BK1_IO2/&nbsp;QUADSPI_BK1_IO3<span style="font-family: 宋体;">上，这些引脚都是</span><span style="font-family: &#39;Times New Roman&#39;;">STM32</span><span style="font-family: 宋体;">的复用引脚。</span></p>
<p class="21"><span style="font-family: 宋体;">关于</span>FLASH<span style="font-family: 宋体;">芯片的更多信息，可参考其数据手册《</span><span style="font-family: &#39;Times New Roman&#39;;">W25Q128</span><span style="font-family: 宋体;">》来了解。若您使用的实验板</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">的型号或控制引脚不一样，只需根据我们的工程修改即可，程序的控制原理相同。</span></p>
<h4>24.6.2 &nbsp;软件设计</h4>
<p class="21"><span style="font-family: 宋体;">为了使工程更加有条理，我们把读写</span>FLASH<span style="font-family: 宋体;">相关的代码独立分开存储，方便以后移植。在“工程模板”之上新建“</span><span style="font-family: &#39;Times New Roman&#39;;">bsp_qspi_flash.c</span><span style="font-family: 宋体;">”及“</span><span style="font-family: &#39;Times New Roman&#39;;">bsp_qspi_ flash.h</span><span style="font-family: 宋体;">”文件，这些文件也可根据您的喜好命名，它们不属于</span><span style="font-family: &#39;Times New Roman&#39;;">STM32 HAL</span><span style="font-family: 宋体;">库的内容，是由我们自己根据应用需要编写的。</span></p>
<h5>1.&nbsp;编程要点</h5>
<p class="19">(1)&nbsp;初始化通讯使用的目标引脚及端口时钟；</p>
<p class="19">(2)&nbsp;<span style="font-family: 宋体;">使能</span>SPI<span style="font-family: 宋体;">外设的时钟；</span></p>
<p class="19">(3)&nbsp;<span style="font-family: 宋体;">配置</span>SPI<span style="font-family: 宋体;">外设的模式、地址、速率等参数并使能</span><span style="font-family: &#39;Times New Roman&#39;;">SPI</span><span style="font-family: 宋体;">外设；</span></p>
<p class="19">(4)&nbsp;<span style="font-family: 宋体;">编写基本</span>SPI<span style="font-family: 宋体;">按字节收发的函数；</span></p>
<p class="19">(5)&nbsp;<span style="font-family: 宋体;">编写对</span>FLASH<span style="font-family: 宋体;">擦除及读写操作的的函数；</span></p>
<p class="19">(6)&nbsp;编写测试程序，对读写数据进行校验。</p>
<h5>2.&nbsp;代码分析</h5>
<h6><strong><span style="font-family: 宋体;">控制</span>FLASH<span style="font-family: 宋体;">的指令</span></strong></h6>
<p class="21">FLASH<span style="font-family: 宋体;">芯片自定义了很多指令，我们通过控制</span><span style="font-family: &#39;Times New Roman&#39;;">STM32</span><span style="font-family: 宋体;">利用</span><span style="font-family: &#39;Times New Roman&#39;;">QSPI</span><span style="font-family: 宋体;">总线向</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">芯片发送指令，</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">芯片收到后就会执行相应的操作。</span></p>
<p class="21"><span style="font-family: 宋体;">而这些指令，对主机端</span>(STM32)<span style="font-family: 宋体;">来说，只是它遵守最基本的</span><span style="font-family: &#39;Times New Roman&#39;;">QSPI</span><span style="font-family: 宋体;">通讯协议发送出的数据，但在设备端</span><span style="font-family: &#39;Times New Roman&#39;;">(FLASH</span><span style="font-family: 宋体;">芯片</span><span style="font-family: &#39;Times New Roman&#39;;">)</span><span style="font-family: 宋体;">把这些数据解释成不同的意义，所以才成为指令。查看</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">芯片的数据手册《</span><span style="font-family: &#39;Times New Roman&#39;;">W25Q128</span><span style="font-family: 宋体;">》，可了解各种它定义的各种</span>指令的功能及指令格式，见<span style="font-family: 宋体;">表</span> 24-1。</p>
<p align="center"><span style="font-family: 黑体;">表</span> 24-1&nbsp;FLASH<span style="font-family: 黑体;">常用芯片指令表</span><span style="font-family: Cambria;">(</span><span style="font-family: 黑体;">摘自规格书《</span><span style="font-family: Cambria;">W25Q128</span><span style="font-family: 黑体;">》</span><span style="font-family: Cambria;">)</span></p>
<table border="0" cellspacing="0">
<tbody>
<tr>
<td valign="top" width="143">
<p class="18">指令</p>
</td>
<td valign="top" width="88">
<p class="18">第一字节<span style="font-family: &#39;Times New Roman&#39;;">(</span><span style="font-family: 黑体;">指令编码</span><span style="font-family: &#39;Times New Roman&#39;;">)</span></p>
</td>
<td valign="top" width="75">
<p class="18">第二字节</p>
</td>
<td valign="top" width="77">
<p class="18">第三字节</p>
</td>
<td valign="top" width="82">
<p class="18">第四字节</p>
</td>
<td valign="top" width="75">
<p class="18">第五字节</p>
</td>
<td valign="top" width="165">
<p class="18">第六字节</p>
</td>
<td valign="top" width="134">
<p class="18">第七<span style="font-family: &#39;Times New Roman&#39;;">-N</span><span style="font-family: 黑体;">字节</span></p>
</td>
</tr>
<tr>
<td valign="top" width="143">
<p class="24">Write Enable</p>
</td>
<td valign="top" width="88">
<p class="24">06h</p>
</td>
<td valign="top" width="75">
<p class="24">　</p>
</td>
<td valign="top" width="77">
<p class="24">　</p>
</td>
<td valign="top" width="82">
<p class="24">　</p>
</td>
<td valign="top" width="75">
<p class="24">　</p>
</td>
<td valign="top" width="165">
<p class="24">　</p>
</td>
<td valign="top" width="134">
<p class="24">　</p>
</td>
</tr>
<tr>
<td valign="top" width="143">
<p class="24">Write Disable</p>
</td>
<td valign="top" width="88">
<p class="24">04h</p>
</td>
<td valign="top" width="75">
<p class="24">　</p>
</td>
<td valign="top" width="77">
<p class="24">　</p>
</td>
<td valign="top" width="82">
<p class="24">　</p>
</td>
<td valign="top" width="75">
<p class="24">　</p>
</td>
<td valign="top" width="165">
<p class="24">　</p>
</td>
<td valign="top" width="134">
<p class="24">　</p>
</td>
</tr>
<tr>
<td valign="top" width="143">
<p class="24">Read Status&nbsp;Register</p>
</td>
<td valign="top" width="88">
<p class="24">05h</p>
</td>
<td valign="top" width="75">
<p class="24">(S7–S0)</p>
</td>
<td valign="top" width="77">
<p class="24">　</p>
</td>
<td valign="top" width="82">
<p class="24">　</p>
</td>
<td valign="top" width="75">
<p class="24">　</p>
</td>
<td valign="top" width="165">
<p class="24">　</p>
</td>
<td valign="top" width="134">
<p class="24">&nbsp;</p>
</td>
</tr>
<tr>
<td valign="top" width="143">
<p class="24">Write Status&nbsp;Register</p>
</td>
<td valign="top" width="88">
<p class="24">01h</p>
</td>
<td valign="top" width="75">
<p class="24">(S7–S0)</p>
</td>
<td valign="top" width="77">
<p class="24">　</p>
</td>
<td valign="top" width="82">
<p class="24">　</p>
</td>
<td valign="top" width="75">
<p class="24">　</p>
</td>
<td valign="top" width="165">
<p class="24">　</p>
</td>
<td valign="top" width="134">
<p class="24">　</p>
</td>
</tr>
<tr>
<td valign="top" width="143">
<p class="24">Read Data</p>
</td>
<td valign="top" width="88">
<p class="24">03h</p>
</td>
<td valign="top" width="75">
<p class="24">A23–A16</p>
</td>
<td valign="top" width="77">
<p class="24">A15–A8</p>
</td>
<td valign="top" width="82">
<p class="24">A7–A0</p>
</td>
<td valign="top" width="75">
<p class="24">(D7–D0)</p>
</td>
<td valign="top" width="165">
<p class="24">(Next byte)</p>
</td>
<td valign="top" width="134">
<p class="24">continuous</p>
</td>
</tr>
<tr>
<td valign="top" width="143">
<p class="24">Fast Read</p>
</td>
<td valign="top" width="88">
<p class="24">0Bh</p>
</td>
<td valign="top" width="75">
<p class="24">A23–A16</p>
</td>
<td valign="top" width="77">
<p class="24">A15–A8</p>
</td>
<td valign="top" width="82">
<p class="24">A7–A0</p>
</td>
<td valign="top" width="75">
<p class="24">dummy</p>
</td>
<td valign="top" width="165">
<p class="24">(D7–D0)</p>
</td>
<td valign="top" width="134">
<p class="24">(Next Byte)&nbsp;continuous</p>
</td>
</tr>
<tr>
<td valign="top" width="143">
<p class="24">Fast Read Dual&nbsp;Output</p>
</td>
<td valign="center" width="88">
<p class="24">3Bh</p>
</td>
<td valign="center" width="75">
<p class="24">A23–A16</p>
</td>
<td valign="center" width="77">
<p class="24">A15–A8</p>
</td>
<td valign="center" width="82">
<p class="24">A7–A0</p>
</td>
<td valign="center" width="75">
<p class="24">dummy</p>
</td>
<td valign="top" width="165">
<p class="24">I/O = (D6,D4,D2,D0) O = (D7,D5,D3,D1)</p>
</td>
<td valign="top" width="134">
<p class="24">(one byte&nbsp;per 4 clocks, continuous)</p>
</td>
</tr>
<tr>
<td valign="top" width="143">
<p class="24">Page Program</p>
</td>
<td valign="top" width="88">
<p class="24">02h</p>
</td>
<td valign="top" width="75">
<p class="24">A23–A16</p>
</td>
<td valign="top" width="77">
<p class="24">A15–A8</p>
</td>
<td valign="top" width="82">
<p class="24">A7–A0</p>
</td>
<td valign="top" width="75">
<p class="24">D7–D0</p>
</td>
<td valign="top" width="165">
<p class="24">Next byte</p>
</td>
<td valign="top" width="134">
<p class="24">Up to 256 bytes</p>
</td>
</tr>
<tr>
<td valign="top" width="143">
<p class="24">Block Erase(64KB)</p>
</td>
<td valign="top" width="88">
<p class="24">D8h</p>
</td>
<td valign="top" width="75">
<p class="24">A23–A16</p>
</td>
<td valign="top" width="77">
<p class="24">A15–A8</p>
</td>
<td valign="top" width="82">
<p class="24">A7–A0</p>
</td>
<td valign="top" width="75">
<p class="24">　</p>
</td>
<td valign="top" width="165">
<p class="24">　</p>
</td>
<td valign="top" width="134">
<p class="24">　</p>
</td>
</tr>
<tr>
<td valign="top" width="143">
<p class="24">Sector Erase(4KB)</p>
</td>
<td valign="top" width="88">
<p class="24">20h</p>
</td>
<td valign="top" width="75">
<p class="24">A23–A16</p>
</td>
<td valign="top" width="77">
<p class="24">A15–A8</p>
</td>
<td valign="top" width="82">
<p class="24">A7–A0</p>
</td>
<td valign="top" width="75">
<p class="24">　</p>
</td>
<td valign="top" width="165">
<p class="24">　</p>
</td>
<td valign="top" width="134">
<p class="24">　</p>
</td>
</tr>
<tr>
<td valign="top" width="143">
<p class="24">Chip Erase</p>
</td>
<td valign="top" width="88">
<p class="24">C7h</p>
</td>
<td valign="top" width="75">
<p class="24">　</p>
</td>
<td valign="top" width="77">
<p class="24">　</p>
</td>
<td valign="top" width="82">
<p class="24">　</p>
</td>
<td valign="top" width="75">
<p class="24">　</p>
</td>
<td valign="top" width="165">
<p class="24">　</p>
</td>
<td valign="top" width="134">
<p class="24">　</p>
</td>
</tr>
<tr>
<td valign="top" width="143">
<p class="24">Power-down</p>
</td>
<td valign="top" width="88">
<p class="24">B9h</p>
</td>
<td valign="top" width="75">
<p class="24">　</p>
</td>
<td valign="top" width="77">
<p class="24">　</p>
</td>
<td valign="top" width="82">
<p class="24">　</p>
</td>
<td valign="top" width="75">
<p class="24">　</p>
</td>
<td valign="top" width="165">
<p class="24">　</p>
</td>
<td valign="top" width="134">
<p class="24">　</p>
</td>
</tr>
<tr>
<td valign="top" width="143">
<p class="24">Release Power- down / Device ID</p>
</td>
<td valign="top" width="88">
<p class="24">ABh</p>
</td>
<td valign="top" width="75">
<p class="24">dummy</p>
</td>
<td valign="top" width="77">
<p class="24">dummy</p>
</td>
<td valign="top" width="82">
<p class="24">dummy</p>
</td>
<td valign="top" width="75">
<p class="24">(ID7-ID0)</p>
</td>
<td valign="top" width="165">
<p class="24">　</p>
</td>
<td valign="top" width="134">
<p class="24">　</p>
</td>
</tr>
<tr>
<td valign="top" width="143">
<p class="24">Manufacturer/ Device ID</p>
</td>
<td valign="top" width="88">
<p class="24">90h</p>
</td>
<td valign="top" width="75">
<p class="24">dummy</p>
</td>
<td valign="top" width="77">
<p class="24">dummy</p>
</td>
<td valign="top" width="82">
<p class="24">00h</p>
</td>
<td valign="top" width="75">
<p class="24">(M7-M0)</p>
</td>
<td valign="top" width="165">
<p class="24">(ID7-ID0)</p>
</td>
<td valign="top" width="134">
<p class="24">　</p>
</td>
</tr>
<tr>
<td valign="center" width="143">
<p class="24">JEDEC ID</p>
</td>
<td valign="center" width="88">
<p class="24">9Fh</p>
</td>
<td valign="top" width="75">
<p class="24">(M7-M0)</p>
<p class="24">生产厂商</p>
</td>
<td valign="top" width="77">
<p class="24">(ID15-ID8)</p>
<p class="24">&nbsp;存储器类型</p>
</td>
<td valign="top" width="82">
<p class="24">(ID7-ID0)&nbsp;容量</p>
</td>
<td valign="top" width="75">
<p class="24">　</p>
</td>
<td valign="top" width="165">
<p class="24">　</p>
</td>
<td valign="top" width="134">
<p class="24">　</p>
</td>
</tr>
</tbody>
</table>
<p class="21"><span style="font-family: 宋体;">该表中的第一列为指令名，第二列为指令编码，第三至第</span>N<span style="font-family: 宋体;">列的具体内容根据指令的不同而有不同的含义。其中带括号的字节参数，方向为</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">向主机传输，即命令响应，不带括号的则为主机向</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">传输。表中“</span>A0~A23<span style="font-family: 宋体;">”</span><span style="font-family: 宋体;">指</span>FLASH<span style="font-family: 宋体;">芯片内部存储器组织的地址；“</span>M0~M7<span style="font-family: 宋体;">”</span>为厂商号（MANUFACTURER ID<span style="font-family: 宋体;">）；</span>“<span style="font-family: &#39;Times New Roman&#39;;">ID0-ID15</span><span style="font-family: 宋体;">”为</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">芯片的</span><span style="font-family: &#39;Times New Roman&#39;;">ID</span><span style="font-family: 宋体;">；“</span><span style="font-family: &#39;Times New Roman&#39;;">dummy</span><span style="font-family: 宋体;">”指该处可为任意数据；“</span>D0~D7<span style="font-family: 宋体;">”</span><span style="font-family: 宋体;">为</span>FLASH<span style="font-family: 宋体;">内部存储矩阵的内容。</span></p>
<p class="21"><span style="font-family: 宋体;">在</span>FLSAH<span style="font-family: 宋体;">芯片内部，存储有固定的厂商编号</span><span style="font-family: &#39;Times New Roman&#39;;">(M7-M0)</span><span style="font-family: 宋体;">和不同类型</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">芯片独有的编号</span><span style="font-family: &#39;Times New Roman&#39;;">(ID15-ID0)</span><span style="font-family: 宋体;">，见</span><span style="font-family: 宋体;">表</span> 24-2。</p>
<p align="center"><span style="font-family: 黑体;">表</span> 24-2&nbsp;FLASH<span style="font-family: 黑体;">数据手册的设备</span><span style="font-family: Cambria;">ID</span><span style="font-family: 黑体;">说明</span></p>
<table border="1" cellspacing="0">
<tbody>
<tr>
<td valign="top" width="306">
<p class="18" align="justify">FLASH<span style="font-family: 黑体;">型号</span></p>
</td>
<td valign="top" width="273">
<p class="18" align="justify">厂商号<span style="font-family: &#39;Times New Roman&#39;;">(M7-M0)</span></p>
</td>
<td valign="top" width="273">
<p class="18" align="justify">FLASH<span style="font-family: 黑体;">型号</span><span style="font-family: &#39;Times New Roman&#39;;">(ID15-ID0)</span></p>
</td>
</tr>
<tr>
<td valign="top" width="306">
<p class="24" align="justify">W25Q64</p>
</td>
<td valign="top" width="273">
<p class="24" align="justify">EF h</p>
</td>
<td valign="top" width="273">
<p class="24" align="justify">4017 h</p>
</td>
</tr>
<tr>
<td valign="top" width="306">
<p class="24" align="justify">W25Q128</p>
</td>
<td valign="top" width="273">
<p class="24" align="justify">EF h</p>
</td>
<td valign="top" width="273">
<p class="24" align="justify">4018 h</p>
</td>
</tr>
</tbody>
</table>
<p class="21"><span style="font-family: 宋体;">通过指令表中的读</span>ID<span style="font-family: 宋体;">指令“</span><span style="font-family: &#39;Times New Roman&#39;;">JEDEC ID</span><span style="font-family: 宋体;">”可以获取这两个编号，</span>该指令<span style="font-family: 宋体;">编码为</span>“<span style="font-family: &#39;Times New Roman&#39;;">9F h</span><span style="font-family: 宋体;">”，其中“</span><span style="font-family: &#39;Times New Roman&#39;;">9F h</span><span style="font-family: 宋体;">”是指</span><span style="font-family: &#39;Times New Roman&#39;;">16</span><span style="font-family: 宋体;">进制数“</span><span style="font-family: &#39;Times New Roman&#39;;">9F</span><span style="font-family: 宋体;">” </span><span style="font-family: &#39;Times New Roman&#39;;">(</span><span style="font-family: 宋体;">相当于</span><span style="font-family: &#39;Times New Roman&#39;;">C</span><span style="font-family: 宋体;">语言中的</span><span style="font-family: &#39;Times New Roman&#39;;">0x9F)</span><span style="font-family: 宋体;">。紧跟指令编码的三个字节分别为</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">芯片输出的“</span><span style="font-family: &#39;Times New Roman&#39;;">(M7-M0)</span><span style="font-family: 宋体;">”、“</span><span style="font-family: &#39;Times New Roman&#39;;">(ID15-ID8)</span><span style="font-family: 宋体;">”及“</span><span style="font-family: &#39;Times New Roman&#39;;">(ID7-ID0)</span><span style="font-family: 宋体;">”</span>&nbsp;。</p>
<p class="21">此处我们以该指令为例，配合其指令时序图进行讲解，见<span style="font-family: 宋体;">图</span> 24-5。</p>
<p style="text-align: center;">&nbsp;<img src="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/896704-20180807100430717-428938890.png" alt=""></p>
<p align="center"><span style="font-family: 黑体;">图</span> 24-5&nbsp;FLASH<span style="font-family: 黑体;">读</span><span style="font-family: Cambria;">ID</span><span style="font-family: 黑体;">指令“</span><span style="font-family: Cambria;">JEDEC ID</span><span style="font-family: 黑体;">”的时序</span>(<span style="font-family: 黑体;">摘自规格书《</span><span style="font-family: Cambria;">W25Q128</span><span style="font-family: 黑体;">》</span><span style="font-family: Cambria;">)</span></p>
<p class="21">主机首先通过DIO(<span style="font-family: 宋体;">对应</span><span style="font-family: &#39;Times New Roman&#39;;">STM32</span><span style="font-family: 宋体;">的</span>QUADSPI_BK1_IO0)<span style="font-family: 宋体;">线向</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">芯片</span>发送第一个字节数据为“<span style="font-family: &#39;Times New Roman&#39;;">9F h</span><span style="font-family: 宋体;">”</span><span style="font-family: 宋体;">，当</span>FLASH<span style="font-family: 宋体;">芯片收到该数据后，它会解读成主机向它发送了“</span><span style="font-family: &#39;Times New Roman&#39;;">JEDEC</span><span style="font-family: 宋体;">指令”，然后它就作出该命令的响应：通过</span>DO(<span style="font-family: 宋体;">对应</span><span style="font-family: &#39;Times New Roman&#39;;">STM32</span><span style="font-family: 宋体;">的</span>QUADSPI_BK1_IO1)<span style="font-family: 宋体;">线</span><span style="font-family: 宋体;">把它的厂商</span>ID(M7-M0)<span style="font-family: 宋体;">及芯片类型</span><span style="font-family: &#39;Times New Roman&#39;;">(ID15-0)</span><span style="font-family: 宋体;">发送给主机，主机接收到指令响应后可进行校验。常见的应用是主机端通过读取设备</span><span style="font-family: &#39;Times New Roman&#39;;">ID</span><span style="font-family: 宋体;">来测试硬件是否连接正常，或用于识别设备。</span></p>
<p class="21"><span style="font-family: 宋体;">对于</span>FLASH<span style="font-family: 宋体;">芯片的其它指令，都是类似的，只是有的指令包含多个字节，或者响应包含更多的数据。 </span></p>
<p class="21"><span style="font-family: 宋体;">实际上，编写设备驱动都是有一定的规律可循的。首先我们要确定设备使用的是什么通讯协议。如上一章的</span>EEPROM<span style="font-family: 宋体;">使用的是</span><span style="font-family: &#39;Times New Roman&#39;;">I</span><sup>2</sup>C<span style="font-family: 宋体;">，本章的</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">使用的是</span><span style="font-family: &#39;Times New Roman&#39;;">QSPI</span><span style="font-family: 宋体;">。那么我们就先根据它的通讯协议，选择好</span><span style="font-family: &#39;Times New Roman&#39;;">STM32</span><span style="font-family: 宋体;">的硬件模块，并进行相应的</span><span style="font-family: &#39;Times New Roman&#39;;">I</span><sup>2</sup>C<span style="font-family: 宋体;">或</span><span style="font-family: &#39;Times New Roman&#39;;">SPI</span><span style="font-family: 宋体;">模块初始化。接着，我们要了解目标设备的相关指令，因为不同的设备，都会有相应的不同的指令。如</span><span style="font-family: &#39;Times New Roman&#39;;">EEPROM</span><span style="font-family: 宋体;">中会把第一个数据解释为内部存储矩阵的地址</span><span style="font-family: &#39;Times New Roman&#39;;">(</span><span style="font-family: 宋体;">实质就是指令</span><span style="font-family: &#39;Times New Roman&#39;;">)</span><span style="font-family: 宋体;">。而</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">则定义了更多的指令，有写指令，读指令，读</span><span style="font-family: &#39;Times New Roman&#39;;">ID</span><span style="font-family: 宋体;">指令等等。最后，我们根据这些指令的格式要求，使用通讯协议向设备发送指令，达到控制设备的目标。</span></p>
<h6><strong><span style="font-family: 宋体;">定义</span>FLASH<span style="font-family: 宋体;">指令编码表</span></strong></h6>
<p class="21"><span style="font-family: 宋体;">为了方便使用，我们把</span>FLASH<span style="font-family: 宋体;">芯片的常用指令编码使用宏来封装起来，后面需要发送指令编码的时候我们直接使用这些宏即可，见</span><span style="font-family: 宋体;">代码清单</span> 24-3。</p>
<p><span style="font-family: 黑体;">代码清单</span> 24-3&nbsp;FLASH<span style="font-family: 黑体;">指令编码表</span></p>
<p>1 /**</p>
<p>&nbsp;2 &nbsp;&nbsp;* @brief &nbsp;W25Q128FV <span style="font-family: 宋体;">指令</span></p>
<p>&nbsp;3 &nbsp;&nbsp;*/</p>
<p>&nbsp;4 /* <span style="font-family: 宋体;">复位操作 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>&nbsp;5 #define RESET_ENABLE_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x66</p>
<p>&nbsp;6 #define RESET_MEMORY_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x99</p>
<p>&nbsp;7</p>
<p>&nbsp;8 #define ENTER_QPI_MODE_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x38</p>
<p>&nbsp;9 #define EXIT_QPI_MODE_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xFF</p>
<p>10</p>
<p>11 /* <span style="font-family: 宋体;">识别操作 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>12 #define READ_ID_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x90</p>
<p>13 #define DUAL_READ_ID_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x92</p>
<p>14 #define QUAD_READ_ID_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x94</p>
<p>15 #define READ_JEDEC_ID_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x9F</p>
<p>16</p>
<p>17 /* <span style="font-family: 宋体;">读操作 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>18 #define READ_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x03</p>
<p>19 #define FAST_READ_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0B</p>
<p>20 #define DUAL_OUT_FAST_READ_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x3B</p>
<p>21 #define DUAL_INOUT_FAST_READ_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xBB</p>
<p>22 #define QUAD_OUT_FAST_READ_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x6B</p>
<p>23 #define QUAD_INOUT_FAST_READ_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xEB</p>
<p>24</p>
<p>25 /* <span style="font-family: 宋体;">写操作 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>26 #define WRITE_ENABLE_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x06</p>
<p>27 #define WRITE_DISABLE_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x04</p>
<p>28</p>
<p>29 /* <span style="font-family: 宋体;">寄存器操作 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>30 #define READ_STATUS_REG1_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x05</p>
<p>31 #define READ_STATUS_REG2_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x35</p>
<p>32 #define READ_STATUS_REG3_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x15</p>
<p>33</p>
<p>34 #define WRITE_STATUS_REG1_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x01</p>
<p>35 #define WRITE_STATUS_REG2_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x31</p>
<p>36 #define WRITE_STATUS_REG3_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x11</p>
<p>37</p>
<p>38</p>
<p>39 /* <span style="font-family: 宋体;">编程操作 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>40 #define PAGE_PROG_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x02</p>
<p>41 #define QUAD_INPUT_PAGE_PROG_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x32</p>
<p>42 #define EXT_QUAD_IN_FAST_PROG_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x12</p>
<p>43</p>
<p>44 /* <span style="font-family: 宋体;">擦除操作 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>45 #define SECTOR_ERASE_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x20</p>
<p>46 #define CHIP_ERASE_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xC7</p>
<p>47</p>
<p>48 #define PROG_ERASE_RESUME_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x7A</p>
<p>49&nbsp;#define PROG_ERASE_SUSPEND_CMD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x75</p>
<h6><strong>SPI<span style="font-family: 宋体;">硬件相关宏定义</span></strong></h6>
<p class="21"><span style="font-family: 宋体;">我们把</span>SPI<span style="font-family: 宋体;">硬件相关的配置都以宏的形式定义到 “</span><span style="font-family: &#39;Times New Roman&#39;;">bsp_qspi_ flash.h</span><span style="font-family: 宋体;">”文件中，见</span><span style="font-family: 宋体;">代码清单</span> 244。</p>
<p><span style="font-family: 黑体;">代码清单</span> 244&nbsp;&nbsp;SPI<span style="font-family: 黑体;">硬件配置相关的宏</span></p>
<p>1 #define QSPI_FLASH &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;QUADSPI</p>
<p>&nbsp;2 #define QSPI_FLASH_CLK_ENABLE() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__QSPI_CLK_ENABLE()</p>
<p>&nbsp;3</p>
<p>&nbsp;4 #define QSPI_FLASH_CLK_PIN &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GPIO_PIN_2</p>
<p>&nbsp;5 #define QSPI_FLASH_CLK_GPIO_PORT &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GPIOB</p>
<p>&nbsp;6 #define QSPI_FLASH_CLK_GPIO_ENABLE() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__GPIOB_CLK_ENABLE()</p>
<p>&nbsp;7 #define QSPI_FLASH_CLK_GPIO_AF &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GPIO_AF9_QUADSPI</p>
<p>&nbsp;8</p>
<p>&nbsp;9 #define QSPI_FLASH_BK1_IO0_PIN &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GPIO_PIN_8</p>
<p>10 #define QSPI_FLASH_BK1_IO0_PORT &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GPIOF</p>
<p>11 #define QSPI_FLASH_BK1_IO0_CLK_ENABLE() &nbsp;&nbsp;&nbsp;__GPIOF_CLK_ENABLE()</p>
<p>12 #define QSPI_FLASH_BK1_IO0_AF &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GPIO_AF10_QUADSPI</p>
<p>13</p>
<p>14 #define QSPI_FLASH_BK1_IO1_PIN &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GPIO_PIN_9</p>
<p>15 #define QSPI_FLASH_BK1_IO1_PORT &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GPIOF</p>
<p>16 #define QSPI_FLASH_BK1_IO1_CLK_ENABLE() &nbsp;&nbsp;&nbsp;__GPIOF_CLK_ENABLE()</p>
<p>17 #define QSPI_FLASH_BK1_IO1_AF &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GPIO_AF10_QUADSPI</p>
<p>18</p>
<p>19 #define QSPI_FLASH_BK1_IO2_PIN &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GPIO_PIN_7</p>
<p>20 #define QSPI_FLASH_BK1_IO2_PORT &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GPIOF</p>
<p>21 #define QSPI_FLASH_BK1_IO2_CLK_ENABLE() &nbsp;&nbsp;&nbsp;__GPIOF_CLK_ENABLE()</p>
<p>22 #define QSPI_FLASH_BK1_IO2_AF &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GPIO_AF9_QUADSPI</p>
<p>23</p>
<p>24 #define QSPI_FLASH_BK1_IO3_PIN &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GPIO_PIN_6</p>
<p>25 #define QSPI_FLASH_BK1_IO3_PORT &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GPIOF</p>
<p>26 #define QSPI_FLASH_BK1_IO3_CLK_ENABLE() &nbsp;&nbsp;&nbsp;__GPIOF_CLK_ENABLE()</p>
<p>27 #define QSPI_FLASH_BK1_IO3_AF &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GPIO_AF9_QUADSPI</p>
<p>28</p>
<p>29 #define QSPI_FLASH_CS_PIN &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GPIO_PIN_6</p>
<p>30 #define QSPI_FLASH_CS_GPIO_PORT &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GPIOB</p>
<p>31 #define QSPI_FLASH_CS_GPIO_CLK_ENABLE() &nbsp;&nbsp;__GPIOB_CLK_ENABLE()</p>
<p>32 #define QSPI_FLASH_CS_GPIO_AF &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GPIO_AF10_QUADSPI</p>
<p class="21"><span style="font-family: 宋体;">以上代码根据硬件连接，把与</span>FLASH<span style="font-family: 宋体;">通讯使用的</span><span style="font-family: &#39;Times New Roman&#39;;">QSPI </span><span style="font-family: 宋体;">、引脚号、引脚源以及复用功能映射都以宏封装起来。</span></p>
<h6><strong><span style="font-family: 宋体;">初始化</span>QSPI<span style="font-family: 宋体;">的 </span><span style="font-family: Cambria;">GPIO</span></strong><strong>&nbsp;</strong></h6>
<p class="21"><span style="font-family: 宋体;">利用上面的宏，编写</span>QSPI<span style="font-family: 宋体;">的初始化函数，见</span><span style="font-family: 宋体;">代码清单</span> 24-5。</p>
<p><span style="font-family: 黑体;">代码清单</span> 24-5&nbsp;QSPI<span style="font-family: 黑体;">的初始化函数</span></p>
<p class="pre">&nbsp;1 /**</p>
<p>&nbsp;2 &nbsp;&nbsp;* @brief &nbsp;QSPI_FLASH<span style="font-family: 宋体;">引脚初始化</span></p>
<p>&nbsp;3 &nbsp;&nbsp;* @param &nbsp;<span style="font-family: 宋体;">无</span></p>
<p>&nbsp;4 &nbsp;&nbsp;* @retval <span style="font-family: 宋体;">无</span></p>
<p>&nbsp;5 &nbsp;&nbsp;*/</p>
<p>&nbsp;6 void&nbsp;QSPI_FLASH_Init(void)</p>
<p>&nbsp;7 {</p>
<p>&nbsp;8</p>
<p>&nbsp;9 &nbsp;&nbsp;&nbsp;&nbsp;GPIO_InitTypeDef GPIO_InitStruct;</p>
<p>10</p>
<p>11 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">使能 </span><span style="font-family: &#39;Courier New&#39;;">QSPI </span><span style="font-family: 宋体;">及 </span><span style="font-family: &#39;Courier New&#39;;">GPIO </span><span style="font-family: 宋体;">时钟 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>12 &nbsp;&nbsp;&nbsp;&nbsp;QSPI_FLASH_CLK_ENABLE();</p>
<p>13 &nbsp;&nbsp;&nbsp;&nbsp;QSPI_FLASH_CLK_GPIO_ENABLE();</p>
<p>14 &nbsp;&nbsp;&nbsp;&nbsp;QSPI_FLASH_BK1_IO0_CLK_ENABLE();</p>
<p>15 &nbsp;&nbsp;&nbsp;&nbsp;QSPI_FLASH_BK1_IO1_CLK_ENABLE();</p>
<p>16 &nbsp;&nbsp;&nbsp;&nbsp;QSPI_FLASH_BK1_IO2_CLK_ENABLE();</p>
<p>17 &nbsp;&nbsp;&nbsp;&nbsp;QSPI_FLASH_BK1_IO3_CLK_ENABLE();</p>
<p>18 &nbsp;&nbsp;&nbsp;&nbsp;QSPI_FLASH_CS_GPIO_CLK_ENABLE();</p>
<p>19</p>
<p>20 &nbsp;&nbsp;&nbsp;&nbsp;//<span style="font-family: 宋体;">设置引脚</span></p>
<p>21 &nbsp;&nbsp;&nbsp;&nbsp;/*!&lt; <span style="font-family: 宋体;">配置 </span><span style="font-family: &#39;Courier New&#39;;">QSPI_FLASH </span><span style="font-family: 宋体;">引脚</span><span style="font-family: &#39;Courier New&#39;;">: CLK */</span></p>
<p>22 &nbsp;&nbsp;&nbsp;&nbsp;GPIO_InitStruct.Pin = QSPI_FLASH_CLK_PIN;</p>
<p>23 &nbsp;&nbsp;&nbsp;&nbsp;GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;</p>
<p>24 &nbsp;&nbsp;&nbsp;&nbsp;GPIO_InitStruct.Pull = GPIO_NOPULL;</p>
<p>25 &nbsp;&nbsp;&nbsp;&nbsp;GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;</p>
<p>26 &nbsp;&nbsp;&nbsp;&nbsp;GPIO_InitStruct.Alternate = QSPI_FLASH_CLK_GPIO_AF;</p>
<p>27</p>
<p>28 &nbsp;&nbsp;&nbsp;&nbsp;HAL_GPIO_Init(QSPI_FLASH_CLK_GPIO_PORT, &amp;GPIO_InitStruct);</p>
<p>29</p>
<p>30 &nbsp;&nbsp;&nbsp;&nbsp;/*!&lt; <span style="font-family: 宋体;">配置 </span><span style="font-family: &#39;Courier New&#39;;">QSPI_FLASH </span><span style="font-family: 宋体;">引脚</span><span style="font-family: &#39;Courier New&#39;;">: IO0 */</span></p>
<p>31 &nbsp;&nbsp;&nbsp;&nbsp;GPIO_InitStruct.Pin = QSPI_FLASH_BK1_IO0_PIN;</p>
<p>32 &nbsp;&nbsp;&nbsp;&nbsp;GPIO_InitStruct.Alternate = QSPI_FLASH_BK1_IO0_AF;</p>
<p>33 &nbsp;&nbsp;&nbsp;&nbsp;HAL_GPIO_Init(QSPI_FLASH_BK1_IO0_PORT, &amp;GPIO_InitStruct);</p>
<p>34</p>
<p>35 &nbsp;&nbsp;&nbsp;&nbsp;/*!&lt; <span style="font-family: 宋体;">配置 </span><span style="font-family: &#39;Courier New&#39;;">QSPI_FLASH </span><span style="font-family: 宋体;">引脚</span><span style="font-family: &#39;Courier New&#39;;">: IO1 */</span></p>
<p>36 &nbsp;&nbsp;&nbsp;&nbsp;GPIO_InitStruct.Pin = QSPI_FLASH_BK1_IO1_PIN;</p>
<p>37 &nbsp;&nbsp;&nbsp;&nbsp;GPIO_InitStruct.Alternate = QSPI_FLASH_BK1_IO1_AF;</p>
<p>38 &nbsp;&nbsp;&nbsp;&nbsp;HAL_GPIO_Init(QSPI_FLASH_BK1_IO1_PORT, &amp;GPIO_InitStruct);</p>
<p>39</p>
<p>40 &nbsp;&nbsp;&nbsp;&nbsp;/*!&lt; <span style="font-family: 宋体;">配置 </span><span style="font-family: &#39;Courier New&#39;;">QSPI_FLASH </span><span style="font-family: 宋体;">引脚</span><span style="font-family: &#39;Courier New&#39;;">: IO2 */</span></p>
<p>41 &nbsp;&nbsp;&nbsp;&nbsp;GPIO_InitStruct.Pin = QSPI_FLASH_BK1_IO2_PIN;</p>
<p>42 &nbsp;&nbsp;&nbsp;&nbsp;GPIO_InitStruct.Alternate = QSPI_FLASH_BK1_IO2_AF;</p>
<p>43 &nbsp;&nbsp;&nbsp;&nbsp;HAL_GPIO_Init(QSPI_FLASH_BK1_IO2_PORT, &amp;GPIO_InitStruct);</p>
<p>44</p>
<p>45 &nbsp;&nbsp;&nbsp;&nbsp;/*!&lt; <span style="font-family: 宋体;">配置 </span><span style="font-family: &#39;Courier New&#39;;">QSPI_FLASH </span><span style="font-family: 宋体;">引脚</span><span style="font-family: &#39;Courier New&#39;;">: IO3 */</span></p>
<p>46 &nbsp;&nbsp;&nbsp;&nbsp;GPIO_InitStruct.Pin = QSPI_FLASH_BK1_IO3_PIN;</p>
<p>47 &nbsp;&nbsp;&nbsp;&nbsp;GPIO_InitStruct.Alternate = QSPI_FLASH_BK1_IO3_AF;</p>
<p>48 &nbsp;&nbsp;&nbsp;&nbsp;HAL_GPIO_Init(QSPI_FLASH_BK1_IO3_PORT, &amp;GPIO_InitStruct);</p>
<p>49</p>
<p>50 &nbsp;&nbsp;&nbsp;&nbsp;/*!&lt; <span style="font-family: 宋体;">配置 </span><span style="font-family: &#39;Courier New&#39;;">SPI_FLASH_SPI </span><span style="font-family: 宋体;">引脚</span><span style="font-family: &#39;Courier New&#39;;">: NCS */</span></p>
<p>51 &nbsp;&nbsp;&nbsp;&nbsp;GPIO_InitStruct.Pin = QSPI_FLASH_CS_PIN;</p>
<p>52 &nbsp;&nbsp;&nbsp;&nbsp;GPIO_InitStruct.Alternate = QSPI_FLASH_CS_GPIO_AF;</p>
<p>53 &nbsp;&nbsp;&nbsp;&nbsp;HAL_GPIO_Init(QSPI_FLASH_CS_GPIO_PORT, &amp;GPIO_InitStruct);</p>
<p>54</p>
<p>55 &nbsp;&nbsp;&nbsp;&nbsp;/* QSPI_FLASH <span style="font-family: 宋体;">模式配置 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>56 &nbsp;&nbsp;&nbsp;&nbsp;QSPIHandle.Instance = QUADSPI;</p>
<p>57 &nbsp;&nbsp;&nbsp;&nbsp;QSPIHandle.Init.ClockPrescaler = 2;</p>
<p>58 &nbsp;&nbsp;&nbsp;&nbsp;QSPIHandle.Init.FifoThreshold = 4;</p>
<p>59 &nbsp;&nbsp;&nbsp;&nbsp;QSPIHandle.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_HALFCYCLE;</p>
<p>60 &nbsp;&nbsp;&nbsp;&nbsp;QSPIHandle.Init.FlashSize = 23;</p>
<p>61 &nbsp;&nbsp;&nbsp;&nbsp;QSPIHandle.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_8_CYCLE;</p>
<p>62 &nbsp;&nbsp;&nbsp;&nbsp;QSPIHandle.Init.ClockMode = QSPI_CLOCK_MODE_0;</p>
<p>63 &nbsp;&nbsp;&nbsp;&nbsp;HAL_QSPI_Init(&amp;QSPIHandle);</p>
<p>64 &nbsp;&nbsp;&nbsp;&nbsp;/*<span style="font-family: 宋体;">初始化</span><span style="font-family: &#39;Courier New&#39;;">QSPI</span><span style="font-family: 宋体;">接口</span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>65 &nbsp;&nbsp;&nbsp;&nbsp;BSP_QSPI_Init();</p>
<p>66&nbsp;}</p>
<p class="21"><span style="font-family: 宋体;">与所有使用到</span>GPIO<span style="font-family: 宋体;">的外设一样，都要先把使用到的</span><span style="font-family: &#39;Times New Roman&#39;;">GPIO</span><span style="font-family: 宋体;">引脚模式初始化，配置好复用功能。</span><span style="font-family: &#39;Times New Roman&#39;;">GPIO</span><span style="font-family: 宋体;">初始化流程如下：</span></p>
<p class="23">(1)&nbsp;使用GPIO_InitTypeDef<span style="font-family: 宋体;">定义</span>GPIO<span style="font-family: 宋体;">初始化结构体变量，以便下面用于存储</span><span style="font-family: &#39;Times New Roman&#39;;">GPIO</span><span style="font-family: 宋体;">配置；</span></p>
<p class="23">(2)&nbsp;<span style="font-family: 宋体;">调用宏定义使能</span>QSPI<span style="font-family: 宋体;">引脚使用的</span><span style="font-family: &#39;Times New Roman&#39;;">GPIO</span><span style="font-family: 宋体;">端口时钟和</span><span style="font-family: &#39;Times New Roman&#39;;">Q</span>SPI外设时钟。</p>
<p class="23">(3)&nbsp;<span style="font-family: 宋体;">向</span>GPIO<span style="font-family: 宋体;">初始化结构体赋值，把</span><span style="font-family: &#39;Times New Roman&#39;;">CLK/IO0/IO1/IO2/IO3/NCS</span><span style="font-family: 宋体;">引脚初始化成复用推挽模式。</span></p>
<p class="23">(4)&nbsp;<span style="font-family: 宋体;">使用以上初始化结构体的配置，调用</span>HAL_GPIO_Init<span style="font-family: 宋体;">函数向寄存器写入参数，完成</span><span style="font-family: &#39;Times New Roman&#39;;">GPIO</span><span style="font-family: 宋体;">的初始化。</span></p>
<p class="21">(5)&nbsp;<span style="font-family: 宋体;">以上只是配置了</span>QSPI<span style="font-family: 宋体;">使用的引脚，对</span><span style="font-family: &#39;Times New Roman&#39;;">QSPI</span><span style="font-family: 宋体;">外设模式的配置。在配置</span><span style="font-family: &#39;Times New Roman&#39;;">STM32</span><span style="font-family: 宋体;">的</span><span style="font-family: &#39;Times New Roman&#39;;">QSPI</span><span style="font-family: 宋体;">模式前，我们要先了解从机端的</span><span style="font-family: &#39;Times New Roman&#39;;">QSPI</span><span style="font-family: 宋体;">模式。本例子中可通过查阅</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">数据手册《</span><span style="font-family: &#39;Times New Roman&#39;;">W25Q128</span><span style="font-family: 宋体;">》获取。根据</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">芯片的说明，它支持</span><span style="font-family: &#39;Times New Roman&#39;;">SPI</span><span style="font-family: 宋体;">模式</span><span style="font-family: &#39;Times New Roman&#39;;">0</span><span style="font-family: 宋体;">及模式</span><span style="font-family: &#39;Times New Roman&#39;;">3</span><span style="font-family: 宋体;">，支持四线模式，支持最高通讯时钟为</span><span style="font-family: &#39;Times New Roman&#39;;">104MHz</span><span style="font-family: 宋体;">，数据帧长度为</span><span style="font-family: &#39;Times New Roman&#39;;">8</span><span style="font-family: 宋体;">位。我们要把</span><span style="font-family: &#39;Times New Roman&#39;;">STM32</span><span style="font-family: 宋体;">的</span><span style="font-family: &#39;Times New Roman&#39;;">QSPI</span><span style="font-family: 宋体;">外设中的这些参数配置一致。见</span><span style="font-family: 宋体;">代码清单</span> 24-5。</p>
<p class="23">(6)&nbsp;<span style="font-family: 宋体;">配置</span>QSPI<span style="font-family: 宋体;">接口模式；时钟三分频最高通讯时钟为</span><span style="font-family: &#39;Times New Roman&#39;;">72MHz</span><span style="font-family: 宋体;">（</span><span style="font-family: &#39;Times New Roman&#39;;">Flash</span><span style="font-family: 宋体;">最高支持</span><span style="font-family: &#39;Times New Roman&#39;;">104MHz</span><span style="font-family: 宋体;">）；</span><span style="font-family: &#39;Times New Roman&#39;;">FIFO </span><span style="font-family: 宋体;">阈值为 </span><span style="font-family: &#39;Times New Roman&#39;;">4 </span><span style="font-family: 宋体;">个字节；采样移位半个周期；</span><span style="font-family: &#39;Times New Roman&#39;;">SPI FLASH </span><span style="font-family: 宋体;">大小；</span><span style="font-family: &#39;Times New Roman&#39;;">W25Q128 </span><span style="font-family: 宋体;">大小为</span><span style="font-family: &#39;Times New Roman&#39;;">16M </span><span style="font-family: 宋体;">字节，即</span><span style="font-family: 宋体;">这里地址位数为</span>23+1=24<span style="font-family: 宋体;">，所以取值</span><span style="font-family: &#39;Times New Roman&#39;;">23</span><span style="font-family: 宋体;">；片选高电平时间为 </span><span style="font-family: &#39;Times New Roman&#39;;">1</span><span style="font-family: 宋体;">个时钟</span><span style="font-family: &#39;Times New Roman&#39;;">(9.2*6=55.2ns),</span><span style="font-family: 宋体;">即手册里面的 </span><span style="font-family: 宋体;">；时钟模式选择为</span>0<span style="font-family: 宋体;">；根据硬件连接选择第一片</span><span style="font-family: &#39;Times New Roman&#39;;">Flash</span><span style="font-family: 宋体;">；最后调用</span>HAL_QSPI_Init<span style="font-family: 宋体;">函数初始化</span>QSPI<span style="font-family: 宋体;">模式。</span></p>
<h6><strong><span style="font-family: 宋体;">初始化</span>QSPI<span style="font-family: 宋体;">存储器</span></strong></h6>
<p class="19"><span style="font-family: 宋体;">初始化好</span>QSPI<span style="font-family: 宋体;">外设后，还要初始化初始化</span><span style="font-family: &#39;Times New Roman&#39;;">QSPI</span><span style="font-family: 宋体;">存储器，需要先复位存储器，使能写操作，配置状态寄存器才可进行数据读写操作，见</span><span style="font-family: 宋体;">代码清单</span> 24-6。</p>
<p><span style="font-family: 黑体;">代码清单</span> 24-6<span style="font-family: 黑体;">初始化</span>QSPI<span style="font-family: 黑体;">存储器</span></p>
<p>1 /**</p>
<p>&nbsp;2 &nbsp;&nbsp;* @brief&nbsp;&nbsp;<span style="font-family: 宋体;">初始化</span>QSPI<span style="font-family: 宋体;">存储器</span></p>
<p>&nbsp;3 &nbsp;&nbsp;* @retval QSPI<span style="font-family: 宋体;">存储器状态</span></p>
<p>&nbsp;4 &nbsp;&nbsp;*/</p>
<p>&nbsp;5 uint8_t&nbsp;BSP_QSPI_Init(void)</p>
<p>&nbsp;6 {</p>
<p>&nbsp;7 &nbsp;&nbsp;&nbsp;&nbsp;QSPI_CommandTypeDef s_command;</p>
<p>&nbsp;8 &nbsp;&nbsp;&nbsp;&nbsp;uint8_t&nbsp;value = W25Q128FV_FSR_QE;</p>
<p>&nbsp;9</p>
<p>10 &nbsp;&nbsp;&nbsp;&nbsp;/* QSPI<span style="font-family: 宋体;">存储器复位 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>11 &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(QSPI_ResetMemory() != QSPI_OK) {</p>
<p>12 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;QSPI_NOT_SUPPORTED;</p>
<p>13 &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>14</p>
<p>15 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">使能写操作 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>16 &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(QSPI_WriteEnable() != QSPI_OK) {</p>
<p>17 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;QSPI_ERROR;</p>
<p>18 &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>19 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">设置四路使能的状态寄存器，使能四通道</span><span style="font-family: &#39;Courier New&#39;;">IO2</span><span style="font-family: 宋体;">和</span><span style="font-family: &#39;Courier New&#39;;">IO3</span><span style="font-family: 宋体;">引脚 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>20 &nbsp;&nbsp;&nbsp;&nbsp;s_command.InstructionMode &nbsp;&nbsp;= QSPI_INSTRUCTION_1_LINE;</p>
<p>21 &nbsp;&nbsp;&nbsp;&nbsp;s_command.Instruction &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= WRITE_STATUS_REG2_CMD;</p>
<p>22 &nbsp;&nbsp;&nbsp;&nbsp;s_command.AddressMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_ADDRESS_NONE;</p>
<p>23 &nbsp;&nbsp;&nbsp;&nbsp;s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;</p>
<p>24 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DataMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_DATA_1_LINE;</p>
<p>25 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DummyCycles &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0;</p>
<p>26 &nbsp;&nbsp;&nbsp;&nbsp;s_command.NbData &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 1;</p>
<p>27 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DdrMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_DDR_MODE_DISABLE;</p>
<p>28 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DdrHoldHalfCycle &nbsp;= QSPI_DDR_HHC_ANALOG_DELAY;</p>
<p>29 &nbsp;&nbsp;&nbsp;&nbsp;s_command.SIOOMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_SIOO_INST_EVERY_CMD;</p>
<p>30 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">配置命令 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>31if&nbsp;(HAL_QSPI_Command(&amp;QSPIHandle, &amp;s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK){</p>
<p>32 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;QSPI_ERROR;</p>
<p>33 &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>34 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">传输数据 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>35if&nbsp;(HAL_QSPI_Transmit(&amp;QSPIHandle, &amp;value, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK){</p>
<p>36 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;QSPI_ERROR;</p>
<p>37 &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>38 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">自动轮询模式等待存储器就绪 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>39 &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(QSPI_AutoPollingMemReady(W25Q128FV_SUBSECTOR_ERASE_MAX_TIME) != QSPI_OK) {</p>
<p>40 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;QSPI_ERROR;</p>
<p>41 &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>42 &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;QSPI_OK;</p>
<p>43 }</p>
<h6><strong><span style="font-family: 宋体;">使用</span>QSPI<span style="font-family: 宋体;">读取大量数据</span></strong></h6>
<p class="19">我们要从存取器中读取大量数据，首先要用一个指针指向读回来数据，并确定数据的首地址，数据大小，通过库函数HAL_QSPI_Command发送配置命令，然后调用库函数HAL_QSPI_Receive接收数据，最后等待操作完成，我们看看它的代码实现，见<span style="font-family: 宋体;">代码清单</span> 247。</p>
<p><span style="font-family: 黑体;">代码清单</span> 247&nbsp;<span style="font-family: 黑体;">使用</span>QSPI<span style="font-family: 黑体;">读取大量数据</span></p>
<p>1 /**</p>
<p>&nbsp;2 &nbsp;&nbsp;* @brief &nbsp;<span style="font-family: 宋体;">从</span><span style="font-family: &#39;Courier New&#39;;">QSPI</span><span style="font-family: 宋体;">存储器中读取大量数据</span><span style="font-family: &#39;Courier New&#39;;">.</span></p>
<p>&nbsp;3 &nbsp;&nbsp;* @param &nbsp;pData: <span style="font-family: 宋体;">指向要读取的数据的指针</span></p>
<p>&nbsp;4 &nbsp;&nbsp;* @param &nbsp;ReadAddr: <span style="font-family: 宋体;">读取起始地址</span></p>
<p>&nbsp;5 &nbsp;&nbsp;* @param &nbsp;Size: <span style="font-family: 宋体;">要读取的数据大小</span></p>
<p>&nbsp;6 &nbsp;&nbsp;* @retval QSPI<span style="font-family: 宋体;">存储器状态</span></p>
<p>&nbsp;7 &nbsp;&nbsp;*/</p>
<p>&nbsp;8 uint8_t&nbsp;BSP_QSPI_Read(uint8_t* pData, uint32_t&nbsp;ReadAddr, uint32_t&nbsp;Size)</p>
<p>&nbsp;9 {</p>
<p>10 &nbsp;&nbsp;&nbsp;&nbsp;QSPI_CommandTypeDef s_command;</p>
<p>11 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">初始化读命令 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>12 &nbsp;&nbsp;&nbsp;&nbsp;s_command.InstructionMode &nbsp;&nbsp;= QSPI_INSTRUCTION_1_LINE;</p>
<p>13 &nbsp;&nbsp;&nbsp;&nbsp;s_command.Instruction &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= READ_CMD;</p>
<p>14 &nbsp;&nbsp;&nbsp;&nbsp;s_command.AddressMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_ADDRESS_1_LINE;</p>
<p>15 &nbsp;&nbsp;&nbsp;&nbsp;s_command.AddressSize &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_ADDRESS_24_BITS;</p>
<p>16 &nbsp;&nbsp;&nbsp;&nbsp;s_command.Address &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= ReadAddr;</p>
<p>17 &nbsp;&nbsp;&nbsp;&nbsp;s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;</p>
<p>18 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DataMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_DATA_1_LINE;</p>
<p>19 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DummyCycles &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0;</p>
<p>20 &nbsp;&nbsp;&nbsp;&nbsp;s_command.NbData &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= Size;</p>
<p>21 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DdrMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_DDR_MODE_DISABLE;</p>
<p>22 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DdrHoldHalfCycle &nbsp;= QSPI_DDR_HHC_ANALOG_DELAY;</p>
<p>23 &nbsp;&nbsp;&nbsp;&nbsp;s_command.SIOOMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_SIOO_INST_EVERY_CMD;</p>
<p>24</p>
<p>25 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">配置命令 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>26if&nbsp;(HAL_QSPI_Command(&amp;QSPIHandle, &amp;s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK){</p>
<p>27 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;QSPI_ERROR;</p>
<p>28 &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>29</p>
<p>30 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">接收数据 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>31 &nbsp;&nbsp;&nbsp;&nbsp;if(HAL_QSPI_Receive(&amp;QSPIHandle, pData, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)!= HAL_OK) {</p>
<p>32 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;QSPI_ERROR;</p>
<p>33 &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>34 &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;QSPI_OK;</p>
<p>35 }</p>
<h6><strong><span style="font-family: 宋体;">使用</span>QSPI<span style="font-family: 宋体;">写入大量数据</span></strong></h6>
<p class="19">我们要从存取器中写入大量数据，首先要用一个指针指写入数据，并确定数据的首地址，数据大小，根据写入地址及大小判断存储器的页面，然后通过库函数HAL_QSPI_Command发送配置命令，然后调用库函数HAL_QSPI_Transmit逐页写入数据，最后等待操作完成，我们看看它的代码实现，见<span style="font-family: 宋体;">代码清单</span> 248。</p>
<p><span style="font-family: 黑体;">代码清单</span> 248&nbsp;<span style="font-family: 黑体;">使用</span>QSPI<span style="font-family: 黑体;">读取大量数据</span></p>
<p>1 /**</p>
<p>&nbsp;2 &nbsp;&nbsp;* @brief &nbsp;<span style="font-family: 宋体;">将大量数据写入</span><span style="font-family: &#39;Courier New&#39;;">QSPI</span><span style="font-family: 宋体;">存储器</span></p>
<p>&nbsp;3 &nbsp;&nbsp;* @param &nbsp;pData: <span style="font-family: 宋体;">指向要写入数据的指针</span></p>
<p>&nbsp;4 &nbsp;&nbsp;* @param &nbsp;WriteAddr: <span style="font-family: 宋体;">写起始地址</span></p>
<p>&nbsp;5 &nbsp;&nbsp;* @param &nbsp;Size: <span style="font-family: 宋体;">要写入的数据大小</span></p>
<p>&nbsp;6 &nbsp;&nbsp;* @retval QSPI<span style="font-family: 宋体;">存储器状态</span></p>
<p>&nbsp;7 &nbsp;&nbsp;*/</p>
<p>&nbsp;8 uint8_t&nbsp;BSP_QSPI_Write(uint8_t* pData, uint32_t&nbsp;WriteAddr, uint32_t&nbsp;Size)</p>
<p>&nbsp;9 {</p>
<p>10 &nbsp;&nbsp;&nbsp;&nbsp;QSPI_CommandTypeDef s_command;</p>
<p>11 &nbsp;&nbsp;&nbsp;&nbsp;uint32_t&nbsp;end_addr, current_size, current_addr;</p>
<p>12 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">计算写入地址和页面末尾之间的大小 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>13 &nbsp;&nbsp;&nbsp;&nbsp;current_addr = 0;</p>
<p>14</p>
<p>15 &nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(current_addr &lt;= WriteAddr) {</p>
<p>16 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_addr += W25Q128FV_PAGE_SIZE;</p>
<p>17 &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>18 &nbsp;&nbsp;&nbsp;&nbsp;current_size = current_addr - WriteAddr;</p>
<p>19</p>
<p>20 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">检查数据的大小是否小于页面中的剩余位置 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>21 &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(current_size &gt; Size) {</p>
<p>22 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_size = Size;</p>
<p>23 &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>24</p>
<p>25 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">初始化地址变量 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>26 &nbsp;&nbsp;&nbsp;&nbsp;current_addr = WriteAddr;</p>
<p>27 &nbsp;&nbsp;&nbsp;&nbsp;end_addr = WriteAddr + Size;</p>
<p>28</p>
<p>29 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">初始化程序命令 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>30 &nbsp;&nbsp;&nbsp;&nbsp;s_command.InstructionMode &nbsp;&nbsp;= QSPI_INSTRUCTION_1_LINE;</p>
<p>31 &nbsp;&nbsp;&nbsp;&nbsp;s_command.Instruction &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QUAD_INPUT_PAGE_PROG_CMD;</p>
<p>32 &nbsp;&nbsp;&nbsp;&nbsp;s_command.AddressMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_ADDRESS_1_LINE;</p>
<p>33 &nbsp;&nbsp;&nbsp;&nbsp;s_command.AddressSize &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_ADDRESS_24_BITS;</p>
<p>34 &nbsp;&nbsp;&nbsp;&nbsp;s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;</p>
<p>35 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DataMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_DATA_4_LINES;</p>
<p>36 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DummyCycles &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0;</p>
<p>37 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DdrMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_DDR_MODE_DISABLE;</p>
<p>38 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DdrHoldHalfCycle &nbsp;= QSPI_DDR_HHC_ANALOG_DELAY;</p>
<p>39 &nbsp;&nbsp;&nbsp;&nbsp;s_command.SIOOMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_SIOO_INST_EVERY_CMD;</p>
<p>40</p>
<p>41 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">逐页执行写入 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>42 &nbsp;&nbsp;&nbsp;&nbsp;do&nbsp;{</p>
<p>43 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s_command.Address = current_addr;</p>
<p>44 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s_command.NbData &nbsp;= current_size;</p>
<p>45</p>
<p>46 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">启用写操作 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>47 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(QSPI_WriteEnable() != QSPI_OK) {</p>
<p>48 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;QSPI_ERROR;</p>
<p>49 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>50</p>
<p>51 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">配置命令 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>52if(HAL_QSPI_Command(&amp;QSPIHandle, &amp;s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {</p>
<p>53 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;QSPI_ERROR;</p>
<p>54 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>55</p>
<p>56 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">传输数据 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>57if(HAL_QSPI_Transmit(&amp;QSPIHandle, pData, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {</p>
<p>58 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;QSPI_ERROR;</p>
<p>59 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>60</p>
<p>61 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">配置自动轮询模式等待程序结束 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>62 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(QSPI_AutoPollingMemReady(HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != QSPI_OK) {</p>
<p>63 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;QSPI_ERROR;</p>
<p>64 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>65</p>
<p>66 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">更新下一页编程的地址和大小变量 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>67 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_addr += current_size;</p>
<p>68 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pData += current_size;</p>
<p>69current_size = ((current_addr + W25Q128FV_PAGE_SIZE) &gt; end_addr) ? (end_addr-current_addr) :</p>
<p>70 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;W25Q128FV_PAGE_SIZE;</p>
<p>71 &nbsp;&nbsp;&nbsp;&nbsp;} while&nbsp;(current_addr &lt; end_addr);</p>
<p>72 &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;QSPI_OK;</p>
<p>73 }</p>
<h6><strong><span style="font-family: 宋体;">读取</span>FLASH<span style="font-family: 宋体;">芯片</span><span style="font-family: Cambria;">ID</span></strong></h6>
<p class="19"><span style="font-family: 宋体;">根据</span>“<span style="font-family: &#39;Times New Roman&#39;;">JEDEC</span><span style="font-family: 宋体;">”指令的时序，我们把读取</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH &nbsp;ID</span><span style="font-family: 宋体;">的过程编写成一个函数，见</span><span style="font-family: 宋体;">代码清单</span> 249。</p>
<p><span style="font-family: 黑体;">代码清单</span> 249&nbsp;<span style="font-family: 黑体;">读取</span>FLASH<span style="font-family: 黑体;">芯片</span><span style="font-family: Cambria;">ID</span></p>
<p>1 /**</p>
<p>&nbsp;2 &nbsp;* @brief &nbsp;<span style="font-family: 宋体;">读取</span><span style="font-family: &#39;Courier New&#39;;">FLASH ID</span></p>
<p>&nbsp;3 &nbsp;* @param &nbsp;&nbsp;<span style="font-family: 宋体;">无</span></p>
<p>&nbsp;4 &nbsp;* @retval FLASH ID</p>
<p>&nbsp;5 &nbsp;*/</p>
<p>&nbsp;6 uint32_t&nbsp;QSPI_FLASH_ReadID(void)</p>
<p>&nbsp;7 {</p>
<p>&nbsp;8 &nbsp;&nbsp;&nbsp;&nbsp;QSPI_CommandTypeDef s_command;</p>
<p>&nbsp;9 &nbsp;&nbsp;&nbsp;&nbsp;uint32_t&nbsp;Temp = 0;</p>
<p>10 &nbsp;&nbsp;&nbsp;&nbsp;uint8_t&nbsp;pData[3];</p>
<p>11 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">读取</span><span style="font-family: &#39;Courier New&#39;;">JEDEC ID */</span></p>
<p>12 &nbsp;&nbsp;&nbsp;&nbsp;s_command.InstructionMode &nbsp;&nbsp;= QSPI_INSTRUCTION_1_LINE;</p>
<p>13 &nbsp;&nbsp;&nbsp;&nbsp;s_command.Instruction &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= READ_JEDEC_ID_CMD;</p>
<p>14 &nbsp;&nbsp;&nbsp;&nbsp;s_command.AddressMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_ADDRESS_1_LINE;</p>
<p>15 &nbsp;&nbsp;&nbsp;&nbsp;s_command.AddressSize &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_ADDRESS_24_BITS;</p>
<p>16 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DataMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_DATA_1_LINE;</p>
<p>17 &nbsp;&nbsp;&nbsp;&nbsp;s_command.AddressMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_ADDRESS_NONE;</p>
<p>18 &nbsp;&nbsp;&nbsp;&nbsp;s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;</p>
<p>19 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DummyCycles &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0;</p>
<p>20 &nbsp;&nbsp;&nbsp;&nbsp;s_command.NbData &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 3;</p>
<p>21 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DdrMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_DDR_MODE_DISABLE;</p>
<p>22 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DdrHoldHalfCycle &nbsp;= QSPI_DDR_HHC_ANALOG_DELAY;</p>
<p>23 &nbsp;&nbsp;&nbsp;&nbsp;s_command.SIOOMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_SIOO_INST_EVERY_CMD;</p>
<p>24</p>
<p>25if(HAL_QSPI_Command(&amp;QSPIHandle, &amp;s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {</p>
<p>26 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("something wrong ....\r\n");</p>
<p>27 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">用户可以在这里添加一些代码来处理这个错误 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>28 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(1) {</p>
<p>29</p>
<p>30 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>31 &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>32 &nbsp;&nbsp;&nbsp;&nbsp;if(HAL_QSPI_Receive(&amp;QSPIHandle, pData, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)!= HAL_OK) {</p>
<p>33 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("something wrong ....\r\n");</p>
<p>34 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">用户可以在这里添加一些代码来处理这个错误 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>35 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(1) {</p>
<p>36</p>
<p>37 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>38 &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>39</p>
<p>40 &nbsp;&nbsp;&nbsp;&nbsp;Temp = ( pData[2] | pData[1]&lt;&lt;8 )| ( pData[0]&lt;&lt;16 );</p>
<p>41</p>
<p>42 &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Temp;</p>
<p>43 }</p>
<p class="21">这段代码利用库函数HAL_QSPI_Command发送读取FLASH&nbsp;&nbsp;ID指令，再调用库函数HAL_QSPI_Receive<span style="font-family: 宋体;">读取</span>3<span style="font-family: 宋体;">个字节，获取</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">芯片对该指令的响应，最后把读取到的这</span><span style="font-family: &#39;Times New Roman&#39;;">3</span><span style="font-family: 宋体;">个数据合并到一个变量</span><span style="font-family: &#39;Times New Roman&#39;;">Temp</span><span style="font-family: 宋体;">中。然后然后作为函数返回值，把该返回值与我们定义的宏“</span>sFLASH_ID”对比，即可知道<span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">芯片是否正常。</span></p>
<h6><strong>FLASH<span style="font-family: 宋体;">写使能以及读取当前状态</span></strong></h6>
<p class="21"><span style="font-family: 宋体;">在向</span>FLASH<span style="font-family: 宋体;">芯片存储矩阵写入数据前，首先要使能写操作，通过“</span><span style="font-family: &#39;Times New Roman&#39;;">Write Enable</span><span style="font-family: 宋体;">”命令即可写使能，见</span><span style="font-family: 宋体;">代码清单</span> 24-10。</p>
<p><span style="font-family: 黑体;">代码清单</span> 24-10&nbsp;<span style="font-family: 黑体;">写使能命令</span></p>
<p>1 /**</p>
<p>&nbsp;2 &nbsp;&nbsp;* @brief &nbsp;<span style="font-family: 宋体;">发送写入使能，等待它有效</span><span style="font-family: &#39;Courier New&#39;;">.</span></p>
<p>&nbsp;3 &nbsp;&nbsp;* @param &nbsp;QSPIHandle: QSPI<span style="font-family: 宋体;">句柄</span></p>
<p>&nbsp;4 &nbsp;&nbsp;* @retval <span style="font-family: 宋体;">无</span></p>
<p>&nbsp;5 &nbsp;&nbsp;*/</p>
<p>&nbsp;6 static uint8_t&nbsp;QSPI_WriteEnable()</p>
<p>&nbsp;7 {</p>
<p>&nbsp;8 &nbsp;&nbsp;&nbsp;&nbsp;QSPI_CommandTypeDef &nbsp;&nbsp;&nbsp;&nbsp;s_command;</p>
<p>&nbsp;9 &nbsp;&nbsp;&nbsp;&nbsp;QSPI_AutoPollingTypeDef s_config;</p>
<p>10 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">启用写操作 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>11 &nbsp;&nbsp;&nbsp;&nbsp;s_command.InstructionMode &nbsp;&nbsp;= QSPI_INSTRUCTION_1_LINE;</p>
<p>12 &nbsp;&nbsp;&nbsp;&nbsp;s_command.Instruction &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= WRITE_ENABLE_CMD;</p>
<p>13 &nbsp;&nbsp;&nbsp;&nbsp;s_command.AddressMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_ADDRESS_NONE;</p>
<p>14 &nbsp;&nbsp;&nbsp;&nbsp;s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;</p>
<p>15 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DataMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_DATA_NONE;</p>
<p>16 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DummyCycles &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0;</p>
<p>17 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DdrMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_DDR_MODE_DISABLE;</p>
<p>18 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DdrHoldHalfCycle &nbsp;= QSPI_DDR_HHC_ANALOG_DELAY;</p>
<p>19 &nbsp;&nbsp;&nbsp;&nbsp;s_command.SIOOMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_SIOO_INST_EVERY_CMD;</p>
<p>20if(HAL_QSPI_Command(&amp;QSPIHandle, &amp;s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK){</p>
<p>21 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;QSPI_ERROR;</p>
<p>22 &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>23</p>
<p>24 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">配置自动轮询模式等待写启用 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>25 &nbsp;&nbsp;&nbsp;&nbsp;s_config.Match &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= W25Q128FV_FSR_WREN;</p>
<p>26 &nbsp;&nbsp;&nbsp;&nbsp;s_config.Mask &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= W25Q128FV_FSR_WREN;</p>
<p>27 &nbsp;&nbsp;&nbsp;&nbsp;s_config.MatchMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_MATCH_MODE_AND;</p>
<p>28 &nbsp;&nbsp;&nbsp;&nbsp;s_config.StatusBytesSize = 1;</p>
<p>29 &nbsp;&nbsp;&nbsp;&nbsp;s_config.Interval &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x10;</p>
<p>30 &nbsp;&nbsp;&nbsp;&nbsp;s_config.AutomaticStop &nbsp;&nbsp;= QSPI_AUTOMATIC_STOP_ENABLE;</p>
<p>31</p>
<p>32 &nbsp;&nbsp;&nbsp;&nbsp;s_command.Instruction &nbsp;&nbsp;&nbsp;= READ_STATUS_REG1_CMD;</p>
<p>33 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DataMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_DATA_1_LINE;</p>
<p>34 &nbsp;&nbsp;&nbsp;&nbsp;s_command.NbData &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 1;</p>
<p>35</p>
<p>36if(HAL_QSPI_AutoPolling(&amp;QSPIHandle, &amp;s_command, &amp;s_config, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK){</p>
<p>37 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;QSPI_ERROR;</p>
<p>38 &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>39 &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;QSPI_OK;</p>
<p>40 }</p>
<p class="21"><span style="font-family: 宋体;">与</span>EEPROM<span style="font-family: 宋体;">一样，由于</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">芯片向内部存储矩阵写入数据需要消耗一定的时间，并不是在总线通讯结束的一瞬间完成的，所以在写操作后需要确认</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">芯片“空闲”时才能进行再次写入。为了表示自己的工作状态，</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">芯片定义了一个状态寄存器，见</span><span style="font-family: 宋体;">图</span> 24-6。</p>
<p style="text-align: center;"><img src="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/896704-20180807100515800-701409723.png" alt="">&nbsp;</p>
<p align="center"><span style="font-family: 黑体;">图</span> 24-6&nbsp;FLASH<span style="font-family: 黑体;">芯片的状态寄存器</span></p>
<p class="21"><span style="font-family: 宋体;">我们只关注这个状态寄存器的第</span>0<span style="font-family: 宋体;">位“</span><span style="font-family: &#39;Times New Roman&#39;;">BUSY</span><span style="font-family: 宋体;">”，当这个位为“</span><span style="font-family: &#39;Times New Roman&#39;;">1</span><span style="font-family: 宋体;">”时，表明</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">芯片处于忙碌状态，它可能正在对内部的存储矩阵进行“擦除”或“数据写入”的操作。</span></p>
<p class="21"><span style="font-family: 宋体;">利用指令表中的</span>“<span style="font-family: &#39;Times New Roman&#39;;">Read Status Register</span><span style="font-family: 宋体;">”指令可以获取</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">芯片状态寄存器的内容，其时序见</span><span style="font-family: 宋体;">图</span> 24-7。</p>
<p class="21" style="text-align: center;">&nbsp;<img src="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/896704-20180807100539805-1564985532.png" alt=""></p>
<p align="center"><span style="font-family: 黑体;">图</span> 24-7&nbsp;<span style="font-family: 黑体;">读取状态寄存器的时序</span></p>
<p class="21"><span style="font-family: 宋体;">只要向</span>FLASH<span style="font-family: 宋体;">芯片发送了读状态寄存器的指令，</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">芯片就会持续向主机返回最新的状态寄存器内容，直到收到</span><span style="font-family: &#39;Times New Roman&#39;;">SPI</span><span style="font-family: 宋体;">通讯的停止信号。</span><span style="font-family: &#39;Times New Roman&#39;;">HAL</span><span style="font-family: 宋体;">库提供了具有等待</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">芯片写入结束功能的函数，见</span><span style="font-family: 宋体;">代码清单</span> 2411。</p>
<p><span style="font-family: 黑体;">代码清单</span> 2411&nbsp;<span style="font-family: 黑体;">通过读状态寄存器等待</span>FLASH<span style="font-family: 黑体;">芯片空闲</span></p>
<p>1 /**</p>
<p>&nbsp;2 &nbsp;&nbsp;* @brief &nbsp;<span style="font-family: 宋体;">读取存储器的</span><span style="font-family: &#39;Courier New&#39;;">SR</span><span style="font-family: 宋体;">并等待</span><span style="font-family: &#39;Courier New&#39;;">EOP</span></p>
<p>&nbsp;3 &nbsp;&nbsp;* @param &nbsp;QSPIHandle: QSPI<span style="font-family: 宋体;">句柄</span></p>
<p>&nbsp;4 &nbsp;&nbsp;* @param &nbsp;Timeout <span style="font-family: 宋体;">超时</span></p>
<p>&nbsp;5 &nbsp;&nbsp;* @retval <span style="font-family: 宋体;">无</span></p>
<p>&nbsp;6 &nbsp;&nbsp;*/</p>
<p>&nbsp;7 static uint8_t&nbsp;QSPI_AutoPollingMemReady(uint32_t&nbsp;Timeout)</p>
<p>&nbsp;8 {</p>
<p>&nbsp;9 &nbsp;&nbsp;&nbsp;&nbsp;QSPI_CommandTypeDef &nbsp;&nbsp;&nbsp;&nbsp;s_command;</p>
<p>10 &nbsp;&nbsp;&nbsp;&nbsp;QSPI_AutoPollingTypeDef s_config;</p>
<p>11 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">配置自动轮询模式等待存储器准备就绪 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>12 &nbsp;&nbsp;&nbsp;&nbsp;s_command.InstructionMode &nbsp;&nbsp;= QSPI_INSTRUCTION_1_LINE;</p>
<p>13 &nbsp;&nbsp;&nbsp;&nbsp;s_command.Instruction &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= READ_STATUS_REG1_CMD;</p>
<p>14 &nbsp;&nbsp;&nbsp;&nbsp;s_command.AddressMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_ADDRESS_NONE;</p>
<p>15 &nbsp;&nbsp;&nbsp;&nbsp;s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;</p>
<p>16 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DataMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_DATA_1_LINE;</p>
<p>17 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DummyCycles &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0;</p>
<p>18 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DdrMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_DDR_MODE_DISABLE;</p>
<p>19 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DdrHoldHalfCycle &nbsp;= QSPI_DDR_HHC_ANALOG_DELAY;</p>
<p>20 &nbsp;&nbsp;&nbsp;&nbsp;s_command.SIOOMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_SIOO_INST_EVERY_CMD;</p>
<p>21</p>
<p>22 &nbsp;&nbsp;&nbsp;&nbsp;s_config.Match &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x00;</p>
<p>23 &nbsp;&nbsp;&nbsp;&nbsp;s_config.Mask &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= W25Q128FV_FSR_BUSY;</p>
<p>24 &nbsp;&nbsp;&nbsp;&nbsp;s_config.MatchMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_MATCH_MODE_AND;</p>
<p>25 &nbsp;&nbsp;&nbsp;&nbsp;s_config.StatusBytesSize = 1;</p>
<p>26 &nbsp;&nbsp;&nbsp;&nbsp;s_config.Interval &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x10;</p>
<p>27 &nbsp;&nbsp;&nbsp;&nbsp;s_config.AutomaticStop &nbsp;&nbsp;= QSPI_AUTOMATIC_STOP_ENABLE;</p>
<p>28</p>
<p>29 &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(HAL_QSPI_AutoPolling(&amp;QSPIHandle, &amp;s_command, &amp;s_config, Timeout) != HAL_OK) {</p>
<p>30 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;QSPI_ERROR;</p>
<p>31 &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>32 &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;QSPI_OK;</p>
<p class="21">33 }</p>
<p class="21">这段代码直接调用HAL_QSPI_AutoPolling<span style="font-family: 宋体;">库函数，设定命令参数及自动轮询参数，最后设定超时返回，如果在超时等待时间内确定</span>FLASH<span style="font-family: 宋体;">就绪则返回存储器就绪状态，否则返回存储器错误。其实主要操作就是检查它的“</span>W25Q128FV_FSR_BUSY”<span style="font-family: &#39;Times New Roman&#39;;">(</span><span style="font-family: 宋体;">即</span><span style="font-family: &#39;Times New Roman&#39;;">BUSY</span><span style="font-family: 宋体;">位</span><span style="font-family: &#39;Times New Roman&#39;;">)</span><span style="font-family: 宋体;">，一直等待到该标志表示写入结束时才退出本函数，以便继续后面与</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">芯片的数据通讯。</span></p>
<h6><strong>FLASH<span style="font-family: 宋体;">扇区擦除</span></strong></h6>
<p class="21"><span style="font-family: 宋体;">由于</span>FLASH<span style="font-family: 宋体;">存储器的特性决定了它只能把原来为“</span><span style="font-family: &#39;Times New Roman&#39;;">1</span><span style="font-family: 宋体;">”的数据位改写成“</span><span style="font-family: &#39;Times New Roman&#39;;">0</span><span style="font-family: 宋体;">”，而原来为“</span><span style="font-family: &#39;Times New Roman&#39;;">0</span><span style="font-family: 宋体;">”的数据位不能直接改写为“</span><span style="font-family: &#39;Times New Roman&#39;;">1</span><span style="font-family: 宋体;">”。所以这里涉及到数据“擦除”的概念，在写入前，必须要对目标存储矩阵进行擦除操作，把矩阵中的数据位擦除为“</span><span style="font-family: &#39;Times New Roman&#39;;">1</span><span style="font-family: 宋体;">”，在数据写入的时候，如果要存储数据“</span><span style="font-family: &#39;Times New Roman&#39;;">1</span><span style="font-family: 宋体;">”，那就不修改存储矩阵 ，在要存储数据“</span><span style="font-family: &#39;Times New Roman&#39;;">0</span><span style="font-family: 宋体;">”时，才更改该位。</span></p>
<p class="21"><span style="font-family: 宋体;">通常，对存储矩阵擦除的基本操作单位都是多个字节进行，如本例子中的</span>FLASH<span style="font-family: 宋体;">芯片支持“扇区擦除”、“块擦除”以及“整片擦除”，见</span><span style="font-family: 宋体;">表</span> 24-3。</p>
<p align="center"><span style="font-family: 黑体;">表</span> 24-3&nbsp;<span style="font-family: 黑体;">本实验</span>FLASH<span style="font-family: 黑体;">芯片的擦除单位</span></p>
<table border="1" cellspacing="0">
<tbody>
<tr>
<td valign="top" width="426">
<p class="18" align="justify">擦除单位</p>
</td>
<td valign="top" width="426">
<p class="18" align="justify">大小</p>
</td>
</tr>
<tr>
<td valign="top" width="426">
<p class="23">扇区擦除<span style="font-family: &#39;Times New Roman&#39;;">Sector Erase</span></p>
</td>
<td valign="top" width="426">
<p class="23">4KB</p>
</td>
</tr>
<tr>
<td valign="top" width="426">
<p class="23">块擦除<span style="font-family: &#39;Times New Roman&#39;;">Block Erase</span></p>
</td>
<td valign="top" width="426">
<p class="23">64KB</p>
</td>
</tr>
<tr>
<td valign="top" width="426">
<p class="23">整片擦除<span style="font-family: &#39;Times New Roman&#39;;">Chip Erase</span></p>
</td>
<td valign="top" width="426">
<p class="23">整个芯片完全擦除</p>
</td>
</tr>
</tbody>
</table>
<p class="23">FLASH<span style="font-family: 宋体;">芯片的最小擦除单位为扇区</span><span style="font-family: &#39;Times New Roman&#39;;">(Sector)</span><span style="font-family: 宋体;">，而一个块</span><span style="font-family: &#39;Times New Roman&#39;;">(Block)</span><span style="font-family: 宋体;">包含</span><span style="font-family: &#39;Times New Roman&#39;;">16</span><span style="font-family: 宋体;">个扇区，其内部存储矩阵分布见</span><span style="font-family: 宋体;">图</span> 24-8。</p>
<p align="center"><img src="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/896704-20180807100601113-559828711.png" alt=""></p>
<p>&nbsp;</p>
<p align="center">&nbsp;</p>
<p align="center"><span style="font-family: 黑体;">图</span> 24-8&nbsp;FLASH<span style="font-family: 黑体;">芯片的存储矩阵</span></p>
<p class="21"><span style="font-family: 宋体;">使用扇区擦除指令</span>“<a href="https://www.cnblogs.com/firege/p/9435349.html#_%E6%8E%A7%E5%88%B6FLASH%E7%9A%84%E6%8C%87%E4%BB%A4"><span style="text-decoration: underline;">Sector Erase</span></a>”可控制<span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">芯片开始擦写，其指令时序见</span><strong><span style="font-family: 宋体;">错误</span>!<span style="font-family: 宋体;">未找到引用源。</span></strong>。</p>
<p style="text-align: center;">&nbsp;<img src="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/896704-20180807100617293-2141779329.png" alt=""></p>
<p align="center"><span style="font-family: 黑体;">图</span> 24-9&nbsp;<span style="font-family: 黑体;">扇区擦除时序</span></p>
<p class="21"><span style="font-family: 宋体;">扇区擦除指令的第一个字节为指令编码，紧接着发送的</span>3<span style="font-family: 宋体;">个字节用于表示要擦除的存储矩阵地址。要注意的是在扇区擦除指令前，还需要先发送“写使能”指令，发送扇区擦除指令后，通过读取寄存器状态等待扇区擦除操作完毕，代码实现见</span><span style="font-family: 宋体;">代码清单</span> 24-12。</p>
<p><span style="font-family: 黑体;">代码清单</span> 24-12&nbsp;<span style="font-family: 黑体;">擦除扇区</span></p>
<p>1 /**</p>
<p>&nbsp;2 &nbsp;&nbsp;* @brief &nbsp;<span style="font-family: 宋体;">擦除</span><span style="font-family: &#39;Courier New&#39;;">QSPI</span><span style="font-family: 宋体;">存储器的指定块</span></p>
<p>&nbsp;3 &nbsp;&nbsp;* @param &nbsp;BlockAddress: <span style="font-family: 宋体;">需要擦除的块地址</span></p>
<p>&nbsp;4 &nbsp;&nbsp;* @retval QSPI<span style="font-family: 宋体;">存储器状态</span></p>
<p>&nbsp;5 &nbsp;&nbsp;*/</p>
<p>&nbsp;6 uint8_t&nbsp;BSP_QSPI_Erase_Block(uint32_t&nbsp;BlockAddress)</p>
<p>&nbsp;7 {</p>
<p>&nbsp;8 &nbsp;&nbsp;&nbsp;&nbsp;QSPI_CommandTypeDef s_command;</p>
<p>&nbsp;9 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">初始化擦除命令 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>10 &nbsp;&nbsp;&nbsp;&nbsp;s_command.InstructionMode &nbsp;&nbsp;= QSPI_INSTRUCTION_1_LINE;</p>
<p>11 &nbsp;&nbsp;&nbsp;&nbsp;s_command.Instruction &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= SECTOR_ERASE_CMD;</p>
<p>12 &nbsp;&nbsp;&nbsp;&nbsp;s_command.AddressMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_ADDRESS_1_LINE;</p>
<p>13 &nbsp;&nbsp;&nbsp;&nbsp;s_command.AddressSize &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_ADDRESS_24_BITS;</p>
<p>14 &nbsp;&nbsp;&nbsp;&nbsp;s_command.Address &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= BlockAddress;</p>
<p>15 &nbsp;&nbsp;&nbsp;&nbsp;s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;</p>
<p>16 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DataMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_DATA_NONE;</p>
<p>17 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DummyCycles &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0;</p>
<p>18 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DdrMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_DDR_MODE_DISABLE;</p>
<p>19 &nbsp;&nbsp;&nbsp;&nbsp;s_command.DdrHoldHalfCycle &nbsp;= QSPI_DDR_HHC_ANALOG_DELAY;</p>
<p>20 &nbsp;&nbsp;&nbsp;&nbsp;s_command.SIOOMode &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= QSPI_SIOO_INST_EVERY_CMD;</p>
<p>21</p>
<p>22 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">启用写操作 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>23 &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(QSPI_WriteEnable() != QSPI_OK) {</p>
<p>24 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;QSPI_ERROR;</p>
<p>25 &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>26</p>
<p>27 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">发送命令 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>28if(HAL_QSPI_Command(&amp;QSPIHandle, &amp;s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {</p>
<p>29 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;QSPI_ERROR;</p>
<p>30 &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>31</p>
<p>32 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">配置自动轮询模式等待擦除结束 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>33 &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(QSPI_AutoPollingMemReady(W25Q128FV_SUBSECTOR_ERASE_MAX_TIME) != QSPI_OK) {</p>
<p>34 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;QSPI_ERROR;</p>
<p>35 &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>36 &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;QSPI_OK;</p>
<p class="21">37 }</p>
<h5>3.&nbsp;main<span style="font-family: 黑体;">函数</span></h5>
<p class="21"><span style="font-family: 宋体;">最后我们来编写</span>main<span style="font-family: 宋体;">函数，进行</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">芯片读写校验，见</span><strong><span style="font-family: 宋体;">错误</span>!<span style="font-family: 宋体;">未找到引用源。</span></strong>。</p>
<p><span style="font-family: 黑体;">代码清单</span> 2413&nbsp;main<span style="font-family: 黑体;">函数</span></p>
<p>1 int&nbsp;main(void)</p>
<p>&nbsp;2 {</p>
<p>&nbsp;3 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">使能指令缓存 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>&nbsp;4 &nbsp;&nbsp;&nbsp;&nbsp;SCB_EnableICache();</p>
<p>&nbsp;5</p>
<p>&nbsp;6 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">使能数据缓存 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>&nbsp;7 &nbsp;&nbsp;&nbsp;&nbsp;SCB_EnableDCache();</p>
<p>&nbsp;8</p>
<p>&nbsp;9 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">设定系统时钟为</span><span style="font-family: &#39;Courier New&#39;;">216MHz */</span></p>
<p>10 &nbsp;&nbsp;&nbsp;&nbsp;SystemClock_Config();</p>
<p>11</p>
<p>12 &nbsp;&nbsp;&nbsp;&nbsp;LED_GPIO_Config();</p>
<p>13 &nbsp;&nbsp;&nbsp;&nbsp;LED_BLUE;</p>
<p>14</p>
<p>15 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">配置串口</span><span style="font-family: &#39;Courier New&#39;;">1</span><span style="font-family: 宋体;">为：</span><span style="font-family: &#39;Courier New&#39;;">115200 8-N-1 */</span></p>
<p>16 &nbsp;&nbsp;&nbsp;&nbsp;DEBUG_USART_Config();</p>
<p>17</p>
<p>18 &nbsp;&nbsp;&nbsp;&nbsp;printf("\r\n<span style="font-family: 宋体;">这是一个</span><span style="font-family: &#39;Courier New&#39;;">16M</span><span style="font-family: 宋体;">串行</span><span style="font-family: &#39;Courier New&#39;;">flash(W25Q128)</span><span style="font-family: 宋体;">实验</span><span style="font-family: &#39;Courier New&#39;;">(QSPI</span><span style="font-family: 宋体;">驱动</span><span style="font-family: &#39;Courier New&#39;;">)</span>&nbsp;\r\n");</p>
<p>19</p>
<p>20 &nbsp;&nbsp;&nbsp;&nbsp;/* 16M<span style="font-family: 宋体;">串行</span><span style="font-family: &#39;Courier New&#39;;">flash W25Q128</span><span style="font-family: 宋体;">初始化 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>21 &nbsp;&nbsp;&nbsp;&nbsp;QSPI_FLASH_Init();</p>
<p>22</p>
<p>23 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">获取 </span><span style="font-family: &#39;Courier New&#39;;">Flash Device ID */</span></p>
<p>24 &nbsp;&nbsp;&nbsp;&nbsp;DeviceID = QSPI_FLASH_ReadDeviceID();</p>
<p>25</p>
<p>26 &nbsp;&nbsp;&nbsp;&nbsp;Delay( 200 );</p>
<p>27</p>
<p>28 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">获取 </span><span style="font-family: &#39;Courier New&#39;;">SPI Flash ID */</span></p>
<p>29 &nbsp;&nbsp;&nbsp;&nbsp;FlashID = QSPI_FLASH_ReadID();</p>
<p>30</p>
<p>31 &nbsp;&nbsp;&nbsp;printf("\r\nFlashID is 0x%X, &nbsp;Manufacturer Device ID is 0x%X\r\n", FlashID, DeviceID);</p>
<p>32</p>
<p>33 &nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">检验 </span><span style="font-family: &#39;Courier New&#39;;">SPI Flash ID */</span></p>
<p>34 &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(FlashID == sFLASH_ID) {</p>
<p>35 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\r\n<span style="font-family: 宋体;">检测到</span><span style="font-family: &#39;Courier New&#39;;">QSPI FLASH W25Q128 !\r\n"</span>);</p>
<p>36</p>
<p>37 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">擦除将要写入的 </span><span style="font-family: &#39;Courier New&#39;;">QSPI FLASH </span><span style="font-family: 宋体;">扇区，</span><span style="font-family: &#39;Courier New&#39;;">FLASH</span><span style="font-family: 宋体;">写入前要先擦除 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>38 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BSP_QSPI_Erase_Block(FLASH_SectorToErase);</p>
<p>39</p>
<p>40 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">将发送缓冲区的数据写到</span><span style="font-family: &#39;Courier New&#39;;">flash</span><span style="font-family: 宋体;">中 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>41 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BSP_QSPI_Write(Tx_Buffer, FLASH_WriteAddress, BufferSize);</p>
<p>42 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\r\n<span style="font-family: 宋体;">写入的数据为：</span><span style="font-family: &#39;Courier New&#39;;">\r\n%s"</span>, Tx_Buffer);</p>
<p>43</p>
<p>44 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">将刚刚写入的数据读出来放到接收缓冲区中 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>45 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BSP_QSPI_Read(Rx_Buffer, FLASH_ReadAddress, BufferSize);</p>
<p>46 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\r\n<span style="font-family: 宋体;">读出的数据为：</span><span style="font-family: &#39;Courier New&#39;;">\r\n%s"</span>, Rx_Buffer);</p>
<p>47</p>
<p>48 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* <span style="font-family: 宋体;">检查写入的数据与读出的数据是否相等 </span><span style="font-family: &#39;Courier New&#39;;">*/</span></p>
<p>49 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TransferStatus1 = Buffercmp(Tx_Buffer, Rx_Buffer, BufferSize);</p>
<p>50</p>
<p>51 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;( PASSED == TransferStatus1 ) {</p>
<p>52 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LED_GREEN;</p>
<p>53 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\r\n16M<span style="font-family: 宋体;">串行</span><span style="font-family: &#39;Courier New&#39;;">flash(W25Q128)</span><span style="font-family: 宋体;">测试成功</span><span style="font-family: &#39;Courier New&#39;;">!\n\r"</span>);</p>
<p>54 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else&nbsp;{</p>
<p>55 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LED_RED;</p>
<p>56 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\r\n16M<span style="font-family: 宋体;">串行</span><span style="font-family: &#39;Courier New&#39;;">flash(W25Q128)</span><span style="font-family: 宋体;">测试失败</span><span style="font-family: &#39;Courier New&#39;;">!\n\r"</span>);</p>
<p>57 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>58 &nbsp;&nbsp;&nbsp;&nbsp;}// if (FlashID == sFLASH_ID)</p>
<p>59 &nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{</p>
<p>60 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LED_RED;</p>
<p>61 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\r\n<span style="font-family: 宋体;">获取不到 </span><span style="font-family: &#39;Courier New&#39;;">W25Q128 ID!\n\r"</span>);</p>
<p>62 &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>63</p>
<p>64 &nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(1);</p>
<p class="21">65 }</p>
<p class="21"><span style="font-family: 宋体;">函数中初始化了系统时钟、</span>LED<span style="font-family: 宋体;">、串口</span><span style="font-family: &#39;Times New Roman&#39;;">SPI</span><span style="font-family: 宋体;">外设，然后读取</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">芯片的</span><span style="font-family: &#39;Times New Roman&#39;;">ID</span><span style="font-family: 宋体;">进行校验，若</span><span style="font-family: &#39;Times New Roman&#39;;">ID</span><span style="font-family: 宋体;">校验通过则向</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">的特定地址写入测试数据，然后再从该地址读取数据，测试读写是否正常。</span></p>
<p class="21">&nbsp;</p>
<p class="20"><strong>注意：</strong></p>
<p class="20"><strong><span style="font-family: 宋体;">由于实验板上的</span>FLASH<span style="font-family: 宋体;">芯片默认已经存储了特定用途的数据，如擦除了这些数据会影响到某些程序的运行。所以我们预留了</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">芯片的“第</span><span style="font-family: &#39;Times New Roman&#39;;">0</span><span style="font-family: 宋体;">扇区</span><span style="font-family: &#39;Times New Roman&#39;;">(0-4096</span><span style="font-family: 宋体;">地址</span><span style="font-family: &#39;Times New Roman&#39;;">)</span><span style="font-family: 宋体;">”专用于本实验，如非必要，请勿擦除其它地址的内容。如已擦除，可在配套资料里找到“刷外部</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">内容”程序，根据其说明给</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">重新写入出厂内容。</span></strong></p>
<h4>24.6.3 &nbsp;下载验证</h4>
<p align="justify"><span style="font-family: 宋体;">用</span>USB<span style="font-family: 宋体;">线连接开发板“</span><span style="font-family: &#39;Times New Roman&#39;;">USB TO UART</span><span style="font-family: 宋体;">”接口跟电脑，在电脑端打开串口调试助手，把编译好的程序下载到开发板。在串口调试助手可看到</span><span style="font-family: &#39;Times New Roman&#39;;">FLASH</span><span style="font-family: 宋体;">测试的调试信息。</span></p>
<p>&nbsp;</p>
</div>
<div id="MySignature" style="display: block;">开源共享，共同进步。</div>
<div class="clear"></div>
<div id="blog_post_info_block">


    <div id="blog_post_info">
<div id="green_channel">
        <a href="javascript:void(0);" id="green_channel_digg" onclick="DiggIt(9435349,cb_blogId,1);green_channel_success(this,&#39;谢谢推荐！&#39;);">好文要顶</a>
        <a id="green_channel_follow" onclick="follow(&#39;059ac0a0-f1d9-e511-9fc1-ac853d9f53cc&#39;);" href="javascript:void(0);">关注我</a>
    <a id="green_channel_favorite" onclick="AddToWz(cb_entryId);return false;" href="javascript:void(0);">收藏该文</a>
    <a id="green_channel_weibo" href="javascript:void(0);" title="分享至新浪微博" onclick="ShareToTsina()"><img src="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/icon_weibo_24.png" alt=""></a>
    <a id="green_channel_wechat" href="javascript:void(0);" title="分享至微信" onclick="shareOnWechat()"><img src="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/wechat.png" alt=""></a>
</div>
<div id="author_profile">
    <div id="author_profile_info" class="author_profile_info">
            <a href="https://home.cnblogs.com/u/firege/" target="_blank"><img src="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/20160805094839.png" class="author_avatar" alt=""></a>
        <div id="author_profile_detail" class="author_profile_info">
            <a href="https://home.cnblogs.com/u/firege/">野火_firege</a><br>
            <a href="https://home.cnblogs.com/u/firege/followees/">关注 - 0</a><br>
            <a href="https://home.cnblogs.com/u/firege/followers/">粉丝 - 139</a>
        </div>
    </div>
    <div class="clear"></div>
    <div id="author_profile_honor"></div>
    <div id="author_profile_follow">
                <a href="javascript:void(0);" onclick="follow(&#39;059ac0a0-f1d9-e511-9fc1-ac853d9f53cc&#39;);return false;">+加关注</a>
    </div>
</div>
<div id="div_digg">
    <div class="diggit" onclick="votePost(9435349,&#39;Digg&#39;)">
        <span class="diggnum" id="digg_count">1</span>
    </div>
    <div class="buryit" onclick="votePost(9435349,&#39;Bury&#39;)">
        <span class="burynum" id="bury_count">0</span>
    </div>
    <div class="clear"></div>
    <div class="diggword" id="digg_tips">
    </div>
</div>

<script type="text/javascript">
    currentDiggType = 0;
</script></div>
    <div class="clear"></div>
    <div id="post_next_prev">

    <a href="https://www.cnblogs.com/firege/p/9372029.html" class="p_n_p_prefix">« </a> 上一篇：    <a href="https://www.cnblogs.com/firege/p/9372029.html" title="发布于 2018-07-26 15:26">第23章 I2C—读写EEPR</a>
    <br>
    <a href="https://www.cnblogs.com/firege/p/9435397.html" class="p_n_p_prefix">» </a> 下一篇：    <a href="https://www.cnblogs.com/firege/p/9435397.html" title="发布于 2018-08-07 10:12">第25章 串行FLASH文件系统FatFs</a>

</div>
</div>
		</div>
		<div class="postDesc">posted @ 
<span id="post-date">2018-08-07 10:07</span>&nbsp;<a href="https://www.cnblogs.com/firege/">野火_firege</a> 阅读(<span id="post_view_count">9047</span>) 评论(<span id="post_comment_count">0</span>) <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9435349" rel="nofollow"> 编辑</a> <a href="javascript:void(0)" onclick="AddToWz(9435349); return false;">收藏</a>
</div>
	</div>
	
	
</div><!--end: topics 文章、评论容器-->
<script src="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/highlight.min.js.download"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 267886, cb_blogApp = 'firege', cb_blogUserGuid = '059ac0a0-f1d9-e511-9fc1-ac853d9f53cc';
    var cb_entryId = 9435349, cb_entryCreatedDate = '2018-08-07 10:07', cb_postType = 1; 
    loadViewCount(cb_entryId);
</script><a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<script>
    var commentManager = new blogCommentManager();
    commentManager.renderComments(0);
</script>

<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="https://www.cnblogs.com/firege/p/9435349.html#" onclick="return RefreshPage();">刷新页面</a><a href="https://www.cnblogs.com/firege/p/9435349.html#top">返回顶部</a></div>
    <div id="comment_form_container"><div class="login_tips">
    注册用户登录后才能发表评论，请 
    <a rel="nofollow" href="javascript:void(0);" class="underline" onclick="return login(&#39;commentform&#39;);">登录</a>
     或 
    <a rel="nofollow" href="javascript:void(0);" class="underline" onclick="return register();">注册</a>，
    <a href="https://www.cnblogs.com/">访问</a> 网站首页。
</div></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"><a href="http://www.ucancode.com/index.htm" target="_blank" onclick="ga(&#39;send&#39;, &#39;event&#39;, &#39;Link&#39;, &#39;click&#39;, &#39;T2-工控&#39;)">【推荐】超50万C++/C#源码: 大型实时仿真组态图形源码</a><br><a href="http://clickc.admaster.com.cn/c/a131574,b3595115,c1705,i0,m101,8a1,8b3,h" target="_blank" onclick="ga(&#39;send&#39;, &#39;event&#39;, &#39;Link&#39;, &#39;click&#39;, &#39;T2-华为云微认证&#39;)">【推荐】零基础轻松玩转华为云产品，获壕礼加返百元大礼</a><br><a href="https://www.ctyun.cn/activity/#/20190919?hmsr=%E5%8D%9A%E5%AE%A2%E5%9B%AD-0916-919%E6%B4%BB%E5%8A%A8&amp;hmpl=&amp;hmcu=&amp;hmkw=&amp;hmci=" target="_blank" onclick="ga(&#39;send&#39;, &#39;event&#39;, &#39;Link&#39;, &#39;click&#39;, &#39;T2-天翼云&#39;)">【推荐】919 天翼云钜惠，全网低价，云主机9元轻松购</a><br><a href="http://clickc.admaster.com.cn/c/a131575,b3595121,c1705,i0,m101,8a1,8b3,h" target="_blank" onclick="ga(&#39;send&#39;, &#39;event&#39;, &#39;Link&#39;, &#39;click&#39;, &#39;T2-华为文字&#39;)">【推荐】华为云文字识别资源包重磅上市，1元万次限时抢购</a><br><a href="https://www.cnblogs.com/cmt/p/11505603.html" target="_blank" onclick="ga(&#39;send&#39;, &#39;event&#39;, &#39;Link&#39;, &#39;click&#39;, &#39;T2-华为云代金券&#39;)">【福利】git pull &amp;&amp; cherry-pick 博客园&amp;华为云百万代金券</a><br></div>
    <div id="opt_under_post"></div>
    <script async="async" src="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/gpt.js.download"></script>
    <script>
        var googletag = googletag || {};
        googletag.cmd = googletag.cmd || [];
    </script>
    <script>
        googletag.cmd.push(function () {
            googletag.defineSlot("/1090369/C1", [300, 250], "div-gpt-ad-1546353474406-0").addService(googletag.pubads());
            googletag.defineSlot("/1090369/C2", [468, 60], "div-gpt-ad-1539008685004-0").addService(googletag.pubads());
            googletag.pubads().enableSingleRequest();
            googletag.enableServices();
        });
    </script>
    <div id="cnblogs_c1" class="c_ad_block">
        <div id="div-gpt-ad-1546353474406-0" style="height:250px; width:300px;" data-google-query-id="CIX4ycmG2uQCFdUYKgodM_wKfA"><div id="google_ads_iframe_/1090369/C1_0__container__" style="border: 0pt none;"><iframe id="google_ads_iframe_/1090369/C1_0" title="3rd party ad content" name="google_ads_iframe_/1090369/C1_0" width="300" height="250" scrolling="no" marginwidth="0" marginheight="0" frameborder="0" style="border: 0px; vertical-align: bottom;" data-google-container-id="1" data-load-complete="true" src="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/saved_resource.html"></iframe></div></div>
    </div>
    <div id="under_post_news"><div class="recomm-block"><b>相关博文：</b><br>·  <a title="FLASH 存储学习-串行SPI nor" href="https://www.cnblogs.com/heiyue/p/4390039.html" target="_blank" onclick="clickRecomItmem(4390039)">FLASH 存储学习-串行SPI nor</a><br>·  <a title="SPI—读写串行 FLASH" href="https://www.cnblogs.com/yangguang-it/p/7111181.html" target="_blank" onclick="clickRecomItmem(7111181)">SPI—读写串行 FLASH</a><br>·  <a title="FLASH 存储学习-串行SPI NOR FLASH" href="https://www.cnblogs.com/heiyue/p/5129299.html" target="_blank" onclick="clickRecomItmem(5129299)">FLASH 存储学习-串行SPI NOR FLASH</a><br>·  <a title="第24章 	SPI—读写串行FLASH—零死角玩转STM32-F429系列" href="https://www.cnblogs.com/firege/p/5805790.html" target="_blank" onclick="clickRecomItmem(5805790)">第24章 	SPI—读写串行FLASH—零死角玩转STM32-F429系列</a><br>·  <a title="3.3SPI串行Flash配置模式" href="https://www.cnblogs.com/l20902/p/10610928.html" target="_blank" onclick="clickRecomItmem(10610928)">3.3SPI串行Flash配置模式</a><br></div></div>
    <div id="cnblogs_c2" class="c_ad_block">
        <div id="div-gpt-ad-1539008685004-0" style="height:60px; width:468px;" data-google-query-id="CIb4ycmG2uQCFdUYKgodM_wKfA">
            
        <div id="google_ads_iframe_/1090369/C2_0__container__" style="border: 0pt none;"><iframe id="google_ads_iframe_/1090369/C2_0" title="3rd party ad content" name="google_ads_iframe_/1090369/C2_0" width="468" height="60" scrolling="no" marginwidth="0" marginheight="0" frameborder="0" style="border: 0px; vertical-align: bottom;" data-google-container-id="2" data-load-complete="true" src="./第24章 QSPI—读写串行FLASH - 野火_firege - 博客园_files/saved_resource(1).html"></iframe></div></div>
    </div>
    <div id="under_post_kb">
<div class="itnews c_ad_block">
    <b>最新 IT 新闻</b>:
    <br>
 ·              <a href="https://news.cnblogs.com/n/638045/" target="_blank">未来学家预测5年、50年、500年世界变迁</a>
            <br>
 ·              <a href="https://news.cnblogs.com/n/638044/" target="_blank">Adobe实习生的智能景深算法：2D图片3秒变立体，变换视角流畅自然</a>
            <br>
 ·              <a href="https://news.cnblogs.com/n/638043/" target="_blank">腾讯云助力厦门海上世界 打造智慧“未来之城”</a>
            <br>
 ·              <a href="https://news.cnblogs.com/n/638042/" target="_blank">任正非：可一次性出售华为5G技术许可，Mate 30系列没预装谷歌GMS</a>
            <br>
 ·              <a href="https://news.cnblogs.com/n/638041/" target="_blank">RMS 澄清他没有为 Jeffrey Epstein 辩护</a>
            <br>
    » <a href="https://news.cnblogs.com/" title="IT 新闻" target="_blank">更多新闻...</a>
</div></div>
    <div id="HistoryToday" class="c_ad_block"></div>
    <script type="text/javascript">
        fixPostBody();
        setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
        deliverAdT2();
        deliverAdC1();
        deliverAdC2();
        loadNewsAndKb();
        loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
        loadOptUnderPost();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div></div>


	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<div id="sidebar_news" class="newsItem"><!--done-->
<div class="newsItem">
<h3 class="catListTitle">公告</h3>
	
<div id="blog-news">
    
    <div id="profile_block">
        昵称：
        <a href="https://home.cnblogs.com/u/firege/">
            野火_firege
        </a>
        <br>
        园龄：
        <a href="https://home.cnblogs.com/u/firege/" title="入园时间：2016-02-23">
            3年6个月
        </a>
        <br>
        粉丝：
        <a href="https://home.cnblogs.com/u/firege/followers/">
            138
        </a>
        <br>
        关注：
        <a href="https://home.cnblogs.com/u/firege/followees/">
            0
        </a>
        <div id="p_b_follow">
<a href="javascript:void(0)" onclick="follow(&#39;059ac0a0-f1d9-e511-9fc1-ac853d9f53cc&#39;)">+加关注</a></div>
        <script>getFollowStatus('059ac0a0-f1d9-e511-9fc1-ac853d9f53cc');</script>
    </div>
</div>
</div>

</div>

			<div id="calendar"><div id="blog-calendar" style="">

<table id="blogCalendar" class="Cal" cellspacing="0" cellpadding="0" title="Calendar" border="0">
    <tbody>
        <tr>
            <td colspan="7">
                <table class="CalTitle" cellspacing="0" border="0">
                    <tbody>
                        <tr>
                            <td class="CalNextPrev">
                                <a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2019/08/16&#39;); return false;">&lt;</a>
                            </td>
                            <td align="center">2019年9月</td>
                            <td align="right" class="CalNextPrev">
                                <a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2019/10/16&#39;); return false;">&gt;</a>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </td>
        </tr>
        <tr>
                    <th class="CalDayHeader" align="center" abbr="日" scope="col">日</th>
                    <th class="CalDayHeader" align="center" abbr="一" scope="col">一</th>
                    <th class="CalDayHeader" align="center" abbr="二" scope="col">二</th>
                    <th class="CalDayHeader" align="center" abbr="三" scope="col">三</th>
                    <th class="CalDayHeader" align="center" abbr="四" scope="col">四</th>
                    <th class="CalDayHeader" align="center" abbr="五" scope="col">五</th>
                    <th class="CalDayHeader" align="center" abbr="六" scope="col">六</th>
        </tr>
            <tr>
                        <td class="CalWeekendDay" align="center">
                            1
                        </td>
                        <td class="" align="center">
                            2
                        </td>
                        <td class="" align="center">
                            3
                        </td>
                        <td class="" align="center">
                            4
                        </td>
                        <td class="" align="center">
                            5
                        </td>
                        <td class="" align="center">
                            6
                        </td>
                    <td class="CalWeekendDay" align="center">
                        7
                    </td>
            </tr>
                <tr>
                        <td class="CalWeekendDay" align="center">
                            8
                        </td>
                            <td class="" align="center">
                                9
                            </td>
                            <td class="" align="center">
                                10
                            </td>
                            <td class="" align="center">
                                11
                            </td>
                            <td class="" align="center">
                                12
                            </td>
                            <td class="" align="center">
                                13
                            </td>
                        <td class="CalWeekendDay" align="center">
                            14
                        </td>
                </tr>
                <tr>
                        <td class="CalWeekendDay" align="center">
                            15
                        </td>
                            <td class="CalTodayDay" align="center">
                                16
                            </td>
                            <td class="" align="center">
                                17
                            </td>
                            <td class="" align="center">
                                18
                            </td>
                            <td class="" align="center">
                                19
                            </td>
                            <td class="" align="center">
                                20
                            </td>
                        <td class="CalWeekendDay" align="center">
                            21
                        </td>
                </tr>
                <tr>
                        <td class="CalWeekendDay" align="center">
                            22
                        </td>
                            <td class="" align="center">
                                23
                            </td>
                            <td class="" align="center">
                                24
                            </td>
                            <td class="" align="center">
                                25
                            </td>
                            <td class="" align="center">
                                26
                            </td>
                            <td class="" align="center">
                                27
                            </td>
                        <td class="CalWeekendDay" align="center">
                            28
                        </td>
                </tr>
                <tr>
                        <td class="CalWeekendDay" align="center">
                            29
                        </td>
                            <td class="" align="center">
                                30
                            </td>
                            <td class="CalOtherMonthDay" align="center">
                                1
                            </td>
                            <td class="CalOtherMonthDay" align="center">
                                2
                            </td>
                            <td class="CalOtherMonthDay" align="center">
                                3
                            </td>
                            <td class="CalOtherMonthDay" align="center">
                                4
                            </td>
                        <td class="CalOtherMonthDay" align="center">
                            5
                        </td>
                </tr>
                <tr>
                        <td class="CalOtherMonthDay" align="center">
                            6
                        </td>
                            <td class="CalOtherMonthDay" align="center">
                                7
                            </td>
                            <td class="CalOtherMonthDay" align="center">
                                8
                            </td>
                            <td class="CalOtherMonthDay" align="center">
                                9
                            </td>
                            <td class="CalOtherMonthDay" align="center">
                                10
                            </td>
                            <td class="CalOtherMonthDay" align="center">
                                11
                            </td>
                        <td class="CalOtherMonthDay" align="center">
                            12
                        </td>
                </tr>
    </tbody>
</table></div><script>loadBlogDefaultCalendar();</script></div>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn">

<!-- 搜索 -->
<div id="sidebar_search" class="sidebar-block">
    <div id="sidebar_search" class="mySearch">
        <h3 class="catListTitle">搜索</h3>
        <div id="sidebar_search_box">
            <div id="widget_my_zzk" class="div_my_zzk">
                <input type="text" id="q" onkeydown="return zzk_go_enter(event);" class="input_my_zzk">&nbsp;<input onclick="zzk_go()" type="button" value="找找看" id="btnZzk" class="btn_my_zzk">
            </div>
            <div id="widget_my_google" class="div_my_zzk">
                <input type="text" name="google_q" id="google_q" onkeydown="return google_go_enter(event);" class="input_my_zzk">&nbsp;<input onclick="google_go()" type="button" value="谷歌搜索" class="btn_my_zzk">
            </div>
        </div>
    </div>
</div>

<!-- 常用链接 -->
<div id="sidebar_shortcut" class="sidebar-block">
    <div class="catListLink">
<h3 class="catListTitle">
常用链接
</h3>
<ul>
		<li>

<a href="https://www.cnblogs.com/firege/p/" title="我的博客的随笔列表">我的随笔</a>
</li>
		<li>

<a href="https://www.cnblogs.com/firege/MyComments.html" title="我的发表过的评论列表">我的评论</a>
</li>
		<li>

<a href="https://www.cnblogs.com/firege/OtherPosts.html" title="我评论过的随笔列表">我的参与</a>
</li>
		<li>

<a href="https://www.cnblogs.com/firege/RecentComments.html" title="我的博客的评论列表">最新评论</a>
</li>
		<li>

<a href="https://www.cnblogs.com/firege/tag/" title="我的博客的标签列表">我的标签</a>
</li>

<li><a id="itemListLink" onclick="this.blur();WarpClass(&#39;itemListLink&#39;, &#39;itemListLin_con&#39;);return false;" href="https://www.cnblogs.com/firege/p/9435349.html#">更多链接</a></li>
</ul>
<div id="itemListLin_con" style="display:none;">
<ul>

</ul>
</div>
</div>


</div>

<!-- 最新随笔 -->



<!-- 我的标签 -->
<div id="sidebar_toptags" class="sidebar-block">
    <div class="catListTag">
<h3 class="catListTitle">我的标签</h3>
<ul>

        <li>
            <a href="https://www.cnblogs.com/firege/tag/STM32/">STM32</a>(4)
        </li>
        <li>
            <a href="https://www.cnblogs.com/firege/tag/%E7%A7%89%E7%81%AB/">秉火</a>(3)
        </li>
        <li>
            <a href="https://www.cnblogs.com/firege/tag/%E9%9B%B6%E6%AD%BB%E8%A7%92/">零死角</a>(3)
        </li>
        <li>
            <a href="https://www.cnblogs.com/firege/tag/%E9%87%8E%E7%81%AB/">野火</a>(3)
        </li>
        <li>
            <a href="https://www.cnblogs.com/firege/tag/ARM/">ARM</a>(3)
        </li>
        <li>
            <a href="https://www.cnblogs.com/firege/tag/F429/">F429</a>(3)
        </li>
        <li>
            <a href="https://www.cnblogs.com/firege/tag/F7/">F7</a>(1)
        </li>
        <li>
            <a href="https://www.cnblogs.com/firege/tag/HAL/">HAL</a>(1)
        </li>
        <li>
            <a href="https://www.cnblogs.com/firege/tag/%E5%BA%93%E5%BC%80%E5%8F%91/">库开发</a>(1)
        </li>

</ul>
</div>


</div>

<!-- 积分与排名 -->


<!-- 随笔分类、随笔档案、文章分类、新闻分类、相册、链接 -->
<div id="sidebar_categories">
    
<div class="catListPostCategory">
<h3 class="catListTitle">

随笔分类


</h3>


<ul>

<li>
<a href="https://www.cnblogs.com/firege/category/864466.html" rel="" target="">
    零死角-F429(51)
</a>
 
</li>

</ul>


</div>
<div class="catListPostArchive">
<h3 class="catListTitle">

随笔档案


</h3>


<ul>

<li>
<a href="https://www.cnblogs.com/firege/archive/2018/08.html" rel="" target="">
    2018年8月(6)
</a>
 
</li>
<li>
<a href="https://www.cnblogs.com/firege/archive/2018/07.html" rel="" target="">
    2018年7月(11)
</a>
 
</li>
<li>
<a href="https://www.cnblogs.com/firege/archive/2018/06.html" rel="" target="">
    2018年6月(12)
</a>
 
</li>
<li>
<a href="https://www.cnblogs.com/firege/archive/2016/08.html" rel="" target="">
    2016年8月(52)
</a>
 
</li>

</ul>


</div>
<div class="catListImageCategory">
<h3 class="catListTitle">

相册


</h3>


<ul>

<li>
<a href="https://www.cnblogs.com/firege/gallery/863332.html" rel="nofollow noopener noreferrer" target="">
    野火STM32开发板(4)
</a>
 
</li>

</ul>


</div>


</div>

<!-- 最新评论 -->
<div id="sidebar_recentcomments" class="sidebar-block">
    <div class="catListComment">
<h3 class="catListTitle">最新评论</h3>

	<div class="RecentCommentBlock">
        <ul>
                    <li class="recent_comment_title"><a href="https://www.cnblogs.com/firege/p/5805823.html#4341866">1. Re:第27章 	LTDC/DMA2D—液晶显示—零死角玩转STM32-F429系列</a></li>
                    <li class="recent_comment_body">嗨，以目前MCU最大Flash空間為2MB，但是以480*272最低顯示就需要127.5KB，這樣算一下這空間只能放16張圖片，加大MCU Flash是算比較不太合適的做法，若Flash預設為512K...</li>
                    <li class="recent_comment_author">--FangDi</li>
                    <li class="recent_comment_title"><a href="https://www.cnblogs.com/firege/p/9211930.html#4311285">2. Re:第9章 初识HAL固件库</a></li>
                    <li class="recent_comment_body">xuexi</li>
                    <li class="recent_comment_author">--神探小神马</li>
                    <li class="recent_comment_title"><a href="https://www.cnblogs.com/firege/p/5806134.html#4168727">3. Re:第48章 	MDK的编译过程及文件类型全解—零死角玩转STM32-F429系列</a></li>
                    <li class="recent_comment_body">老板这篇文章好棒！！！！实在敬佩！！！！<br>（来自小白）</li>
                    <li class="recent_comment_author">--BEIYI_MARK</li>
                    <li class="recent_comment_title"><a href="https://www.cnblogs.com/firege/p/5748220.html#4142039">4. Re:第1章-如何使用本书—零死角玩转STM32-F429系列</a></li>
                    <li class="recent_comment_body">感谢</li>
                    <li class="recent_comment_author">--glxu</li>
                    <li class="recent_comment_title"><a href="http://www.cnblogs.com/firege/p/5806121.html#3948206">5. Re:第46章 	DCMI—OV5640摄像头—零死角玩转STM32-F429系列</a></li>
                    <li class="recent_comment_body">大佬能分享一波源码吗，我是摄像头小白，最近刚刚准备学习ov5640，准备用f1来驱动，看到您写的这个f4例子很棒</li>
                    <li class="recent_comment_author">--随风狼人lixun</li>
        </ul>
    </div>
</div>


</div>



<!-- 阅读排行榜 -->
<div id="sidebar_topviewedposts" class="sidebar-block">
    <div class="catListView">
<h3 class="catListTitle">阅读排行榜</h3>
	<div id="TopViewPostsBlock">
        <ul style="word-break:break-all">
                    <li>
                        <a href="https://www.cnblogs.com/firege/p/5806087.html">
                            1. 第45章 	DCMI—OV2640摄像头—零死角玩转STM32-F429系列(19383)
                        </a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/firege/p/5805983.html">
                            2. 第39章 	ETH—Lwip以太网通信—零死角玩转STM32-F429系列(17171)
                        </a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/firege/p/5805977.html">
                            3. 第38章 	I2S—音频播放与录音输入—零死角玩转STM32-F429系列(16676)
                        </a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/firege/p/5805734.html">
                            4. 第18章 	SysTick—系统定时器—零死角玩转STM32-F429系列(14914)
                        </a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/firege/p/5806121.html">
                            5. 第46章 	DCMI—OV5640摄像头—零死角玩转STM32-F429系列(14888)
                        </a>
                    </li>
        </ul>
    </div>
</div>


</div>

<!-- 评论排行榜 -->
<div id="sidebar_topcommentedposts" class="sidebar-block">
    <div class="catListFeedback">
<h3 class="catListTitle">评论排行榜</h3>
	<div id="TopFeedbackPostsBlock">
        <ul style="word-break:break-all">
                    <li>
                        <a href="https://www.cnblogs.com/firege/p/5748480.html">
                            1. 第7章 	使用寄存器点亮LED灯—零死角玩转STM32-F429系列(3)
                        </a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/firege/p/5805823.html">
                            2. 第27章 	LTDC/DMA2D—液晶显示—零死角玩转STM32-F429系列(1)
                        </a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/firege/p/9211930.html">
                            3. 第9章 初识HAL固件库(1)
                        </a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/firege/p/5806134.html">
                            4. 第48章 	MDK的编译过程及文件类型全解—零死角玩转STM32-F429系列(1)
                        </a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/firege/p/5806121.html">
                            5. 第46章 	DCMI—OV5640摄像头—零死角玩转STM32-F429系列(1)
                        </a>
                    </li>
        </ul>
    </div>
</div>


</div>

<!-- 推荐排行榜 -->
<div id="sidebar_topdiggedposts" class="sidebar-block">
    <div id="topdigg_posts_wrap">
    <div class="catListView">
        <h3 class="catListTitle">推荐排行榜</h3>
        <div id="TopDiggPostsBlock">
            <ul style="word-break: break-all">
                        <li>
                            <a href="https://www.cnblogs.com/firege/p/5806134.html">
                                1. 第48章 	MDK的编译过程及文件类型全解—零死角玩转STM32-F429系列(3)
                            </a>
                        </li>
                        <li>
                            <a href="https://www.cnblogs.com/firege/p/5748317.html">
                                2. 第4章 初识STM32—零死角玩转STM32-F429系列(2)
                            </a>
                        </li>
                        <li>
                            <a href="https://www.cnblogs.com/firege/p/5805977.html">
                                3. 第38章 	I2S—音频播放与录音输入—零死角玩转STM32-F429系列(2)
                            </a>
                        </li>
                        <li>
                            <a href="https://www.cnblogs.com/firege/p/5805934.html">
                                4. 第33章 	TIM—电容按键检测—零死角玩转STM32-F429系列(1)
                            </a>
                        </li>
                        <li>
                            <a href="https://www.cnblogs.com/firege/p/5805894.html">
                                5. 第32章 	TIM—高级定时器—零死角玩转STM32-F429系列(1)
                            </a>
                        </li>
            </ul>
        </div>
    </div>
</div>
</div></div>
                    <script>loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		<!--done-->
Copyright © 2019 野火_firege
<br><span id="poweredby">Powered by .NET Core 3.0.0-preview9-19423-09 on Linux</span>



	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


    


</body></html>