
<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="origin" />
    <meta property="og:description" content="ssh端口转发    三种转发方式及实例" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <title>SSH端口转发详解及实例 - 珂儿吖 - 博客园</title>
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=sqi5FxOybx6gjGoG6Zfy1wD-0AwznLNLYOVx7Y9tIN0" />
    <link id="MainCss" rel="stylesheet" href="/skins/stylepink/bundle-stylepink.min.css?v=aLoPh5W21GLIJInqb-eEZ49WAoqFxSntZFgTJv5sCJQ" />
    <link type="text/css" rel="stylesheet" href="https://www.cnblogs.com/keerya/custom.css?v=cszkZqWGcLf/bwqwBcK6c1XnVZQ=" />
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/stylepink/bundle-stylepink-mobile.min.css?v=netr1CuSsXZ0CExbtEiL-uTF8pqcWT8cR0el_b5SyJM" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/keerya/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/keerya/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/keerya/wlwmanifest.xml" />
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=6P27kw_BZIOkZbw6PG6m9_Bo1b1r0zKDMPQFHUeKGYY"></script>
    <script>
        var currentBlogId = 368867;
        var currentBlogApp = 'keerya';
        var cb_enable_mathjax = false;
        var isLogined = false;
    </script>
    
    
    
</head>
<body>
    <a name="top"></a>
    <div id="page_begin_html">
        <script>loadPageBeginHtml();</script>
    </div>
    <!--done-->
<div id="banner">
<!--done-->
<div class="header">
	<div class="headerText">
		<a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/keerya/">珂儿吖</a>
<br>
		<div class="headerDis">

</div>
	</div>
</div>

</div>
<div id="main">
	<!-- right starts -->
	<div id="right">
		<div id="right_content">
			<DIV id="mystats">
				
					<!--done-->
<div class="blogStats">
随笔- 
36&nbsp;
文章- 
0&nbsp;
评论- 
43&nbsp;

</div>


				
			</DIV>
			<div id="mylinks">

<a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
&nbsp;&nbsp;
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/keerya/">
首页</a>
&nbsp;&nbsp;

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
&nbsp;&nbsp;
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/%E7%8F%82%E5%84%BF%E5%90%96">
联系</a>&nbsp;&nbsp;
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
&nbsp;&nbsp;
<a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/keerya/rss/">
订阅</a>&nbsp;
<a id="blog_nav_rss_image" href="https://www.cnblogs.com/keerya/rss/">
    <img src="/skins/stylepink/images/xml.gif" alt="订阅" />
</a>

</div>
			<div id="topics">
				<div id="post_detail">
<!--done-->
<div class="post">
	<div class="postTitle">
		
<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/keerya/p/7612715.html">SSH端口转发详解及实例</a>

	</div>
	
<div id="cnblogs_post_body" class="blogpost-body ">
    <h1>一、SSH端口转发简介</h1>
<p><span style="font-family: 楷体; font-size: 14pt;">　　SSH会自动加密和解密所有SSH客户端与服务端之间的网络数据。但是，SSH还能够将其他TCP端口的网络数据通SSH链接来转发，并且自动提供了相应的加密及解密服务。这一过程也被叫做"<span style="color: #df402a;"><strong>隧道</strong></span>"（tunneling），这是因为SSH为其他TCP链接提供了一个安全的通道来进行传输而得名。例如，Telnet ，SMTP ，LDAP这些TCP应用均能够从中得益，避免了用户名，密码以及隐私信息的明文传输。而与此同时，如果工作环境许中的防火墙限制了一些网络端口的使用，但是允许SSH的连接，也能够将通过将TCP用端口转发来使用SSH进行通讯。 </span></p>
<h2>1.1 SSH端口转发的两大功能</h2>
<ul>
<li><span style="font-family: 楷体; font-size: 14pt;">加密SSH Client端至SSH Server端之间的通讯数据。</span></li>
<li><span style="font-family: 楷体; font-size: 14pt;">突破防火墙的简直完成一些之前无法建立的TCP连接。 </span></li>
</ul>
<p>&nbsp;</p>
<h1>二、本地转发</h1>
<p><span style="font-family: 楷体; font-size: 14pt;"><strong>命令：-L localport:remotehost:remotehostport sshserver</strong> </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;"><strong>说明：</strong>localport　　　　　　 本机开启的端口号 </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remotehost　　　　　　最终连接机器的IP地址 </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">&nbsp;&nbsp;&nbsp; &nbsp; remotehostport&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转发机器的端口号 </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">&nbsp;&nbsp;&nbsp; &nbsp; sshserver　　　　　　 转发机器的IP地址 </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;"><strong>选项：</strong>-f 后台启用 </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">&nbsp;&nbsp;&nbsp; &nbsp; -N 不打开远程shell，处于等待状态（不加-N则直接登录进去） </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -g 启用网关功能 </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们通过实验来详细的说明一下如何实现本地转发： </span></p>
<h2>实验一：实现SSH端口转发&mdash;&mdash;本地转发</h2>
<ul>
<li>
<div style="text-align: justify;"><span style="font-family: 楷体; font-size: 14pt;"><strong>背景：</strong>企业内部C服务器只允许telnet连接（23端口）访问，不允许外部直接访问，B服务器是一个ssh服务器；有一个用户需要从外部连接到企业内部的C服务器。 </span></div>
</li>
<li>
<div style="text-align: justify;"><span style="font-family: 楷体; font-size: 14pt;"><strong>前提：</strong>防火墙允许22端口进来（或者企业内部有一个堡垒机，ssh -t通过堡垒机进去）。 </span></div>
</li>
<li>
<div style="text-align: justify;"><span style="font-family: 楷体; font-size: 14pt;"><strong>原理：</strong>A用户通过ssh协议连接到B机器上，再通过B机器做跳板，连接至C机器。 </span></div>
</li>
<li>
<div style="text-align: justify;"><span style="font-family: 楷体; font-size: 14pt;"><strong>机器：</strong>rhel5模拟A用户，centos6模拟B机器，centos7模拟C机器 </span></div>
</li>
<li>
<div style="text-align: justify;"><span style="font-family: 楷体; font-size: 14pt;"><strong>图示如下：</strong> </span></div>
</li>
</ul>
<p><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929204939184-1198655976.png" alt="" /></p>
<ul>
<li>
<div style="text-align: justify;"><span style="font-family: 楷体; font-size: 14pt;"><strong>实验步骤： </strong></span></div>
</li>
</ul>
<p><span style="font-family: 楷体; font-size: 14pt;">1）模拟C机器不允许A用户连接，并且开启B机器的telnet服务端口23。 </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">在centos7上输入以下口令： </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;"><strong>iptables -A INPUT -s 192.168.191.55 -j REJECT </strong></span></p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929204946090-799558356.png" alt="" /></p>
<p><span style="font-family: 楷体; font-size: 14pt;">此时，从rhel5用ssh命令连接centos7，是拒绝的： </span></p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929204952997-420060970.png" alt="" /></p>
<p><span style="font-family: 楷体; font-size: 14pt;">同时，我们还要开启7的telnet服务端口23： </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;"><strong>systemctl start telnet.soc ket </strong></span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">用<strong>ss -ntl</strong>命令可以查看的服务端口是否已开启 </span></p>
<p><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929204959340-216194604.png" alt="" /></p>
<p><span style="font-family: 楷体; font-size: 14pt;">2）开启端口转发（telnet隧道） </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">&nbsp;&nbsp;&nbsp;&nbsp;首先，我们在5机器上确认已经开启的端口有哪些： </span></p>
<p><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205045544-338468897.png" alt="" /></p>
<p>&nbsp;</p>
<p><span style="font-family: 楷体; font-size: 14pt;">我们使用的端口是9527端口，从上图中我么已经看出，9527端口没有被占用，所以我们可以使用~ </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">接着我们建立本地转发的隧道（5上输入以下命令）： </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;"><strong>ssh <span style="color: #df402a;">-L</span> 9527:192.168.191.77:23 <span style="color: #df402a;">-fN </span>192.168.191.66</strong> </span></p>
<p><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205053544-608836533.png" alt="" /></p>
<p><span style="font-family: 楷体; font-size: 14pt;">&nbsp;&nbsp;&nbsp;&nbsp;在这里，我们可以使用<strong>ps aux</strong>来查询后台运行的进程。也可以通过<strong>ss -nt</strong>查看接口连接情况： </span></p>
<p><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205059575-1478652996.png" alt="" /></p>
<p><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205104325-1955892788.png" alt="" /></p>
<p><span style="font-family: 楷体; font-size: 14pt;">3）在rhel5上输入以下命令，用9527端口连接自己： </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">&nbsp;&nbsp;&nbsp;&nbsp;<strong>telnet 127.0.0.1 9527 </strong></span></p>
<p><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205110356-28832344.png" alt="" /></p>
<p><span style="font-family: 楷体; font-size: 14pt;">&nbsp;&nbsp;&nbsp;&nbsp;此时，我们可以查看一下centos6和centos7的连接情况： </span></p>
<p><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205116965-799174141.png" alt="" /></p>
<p><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205121356-1208183849.png" alt="" /></p>
<p><span style="font-family: 楷体; font-size: 14pt;">&nbsp;&nbsp;&nbsp;&nbsp;至此，我们已经实现了A用户在公司外部远程连接C机器的需求，接下来我们就来讲一讲实现过程： </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">&nbsp;&nbsp;&nbsp;&nbsp;data &lt;- -&gt; localhost:9527端口 &lt;- -&gt; localhost:XXXXX（随机在客户端6开一个端口） &lt;- -&gt; sshsrv:22（通过ssh封装） &lt;- -&gt; sshsrv:YYYYY（服务器解封装，开一个端口，代表telnet客户端） &lt;- -&gt; telnetsrv:23 </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">　　用大白话来解释就是：当rhel5（A用户）连接自己的9527端口时，该请求自然会通过ssh协议封装发送给centos6（B机器），然后在centos6（C机器）上解封装,形成telnet流量，发送给centos7（C机器）。 </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">　　实验做完了，如果我们想要停止这个隧道，直接把后台的隧道进程杀死就可以了，命令如下： </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;"><strong>　　killall ssh </strong></span></p>
<p><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205131200-118523022.png" alt="" /></p>
<p><span style="font-size: 14pt;"><span style="font-family: 楷体;">　　我们的实验圆满完成ヾ(</span><span style="font-family: MS Mincho;">✿</span><span style="font-family: 微软雅黑;">ﾟ</span><span style="font-family: 楷体;">▽</span><span style="font-family: 微软雅黑;">ﾟ</span><span style="font-family: 楷体;">)ノ </span></span></p>
<p>&nbsp;</p>
<h1>三、远程转发</h1>
<p><span style="font-family: 楷体; font-size: 14pt;">　　在我们实验一的场景下，首先要满足的是防火墙上必须打开22端口，但是在现实生活中，企业处于安全考虑，一般是不会打开防火墙，只允许出不允许进。所以，当防火墙的端口没有打开的时候，我们要怎么办呢？这就要用到我们接下来要说的远程转发了： </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;"><strong>命令：</strong>-R sshserverport:remotehost:remotehostport sshserver </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;"><strong>说明：</strong>sshserverport &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;被转发机器开启的端口号 </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remotehost&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;　　&nbsp;最终连接机器的IP地址 </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">&nbsp;&nbsp;&nbsp; &nbsp; remotehostport&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;被转发机器的端口号 </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">&nbsp;&nbsp;&nbsp; &nbsp; sshserver&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 被转发机器的IP地址 </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">　　同样的，我们以实验来具体说明我们的远程转发： </span></p>
<h2>实验二、实现SSH端口转发&mdash;&mdash;远程转发</h2>
<ul>
<li>
<div style="text-align: justify;"><span style="font-family: 楷体; font-size: 14pt;"><strong>背景：</strong>企业内部C服务器只允许telnet连接（23端口）访问，不允许外部直接访问，B服务器是一个ssh服务器；有一个用户需要从外部连接到企业内部的C服务器。 </span></div>
</li>
<li>
<div style="text-align: justify;"><span style="font-family: 楷体; font-size: 14pt;"><strong>原理：</strong>B机器访问A用户，给A用户转发 </span></div>
</li>
<li>
<div style="text-align: justify;"><span style="font-family: 楷体; font-size: 14pt;"><strong>机器：</strong>rhel5模拟A用户，centos6模拟B机器，centos7模拟C机器 </span></div>
</li>
<li>
<div style="text-align: justify;"><span style="font-family: 楷体; font-size: 14pt;"><strong>图示如下： </strong></span></div>
</li>
</ul>
<p><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205136872-1668551804.png" alt="" /></p>
<ul>
<li>
<div style="text-align: justify;"><span style="font-family: 楷体; font-size: 14pt;"><strong>实验步骤： </strong></span></div>
</li>
</ul>
<p><span style="font-family: 楷体; font-size: 14pt;">1）模拟C机器不允许A用户连接，并且开启B机器的telnet服务端口23。 </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">　　在centos7上输入以下口令： </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;"><strong>　　iptables -A INPUT -s 192.168.191.55 -j REJECT </strong></span></p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205145247-127307491.png" alt="" /></p>
<p><span style="font-family: 楷体; font-size: 14pt;">　　此时，从rhel5用ssh命令连接centos7，是拒绝的： </span></p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205248294-1843157952.png" alt="" /></p>
<p><span style="font-family: 楷体; font-size: 14pt;">　　同时，我们还要开启7的telnet服务端口23： </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;"><strong>　　systemctl start telnet.soc ket </strong></span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">　　用<strong>ss -ntl</strong>命令可以查看的服务端口是否已开启 </span></p>
<p><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205303122-1448246970.png" alt="" /></p>
<p><span style="font-family: 楷体; font-size: 14pt;">2）开启隧道转发（telnet隧道） </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">&nbsp;&nbsp;&nbsp;&nbsp;这一次，由于防火墙完全关闭，外部的设备连接不进来，所以我们要通过B机器去连接A用户的机器，因此，我们的开启隧道命令要在B机器（centos6）上运行： </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">&nbsp;&nbsp;&nbsp;&nbsp;首先，我们要确定一下centos6上开启了哪些端口： </span></p>
<p><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205322028-576361080.png" alt="" /></p>
<p><span style="font-family: 楷体; font-size: 14pt;">&nbsp;&nbsp;&nbsp;&nbsp;然后，我们选择一个没有被开启的端口开启隧道，进行实验： </span></p>
<p><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205327637-662271955.png" alt="" /></p>
<p><span style="font-family: 楷体; font-size: 14pt;">　　同样的，在这里，我们可以使用<strong>ps aux</strong>来查询后台运行的进程。也可以通过<strong>ss -nt</strong>查看接口连接情况： </span></p>
<p><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205338044-686952570.png" alt="" /></p>
<p><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205344044-556145885.png" alt="" /></p>
<p><span style="font-family: 楷体; font-size: 14pt;">3）在rhel5上输入以下命令，用9527端口连接自己： </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">&nbsp;&nbsp;&nbsp;&nbsp;<strong>telnet 127.0.0.1 9527 </strong></span></p>
<p><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205351325-1129373533.png" alt="" /></p>
<p><span style="font-family: 楷体; font-size: 14pt;">&nbsp;&nbsp;&nbsp;&nbsp;此时，我们可以查看一下centos6和centos7的连接情况： </span></p>
<p><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205409215-1545186456.png" alt="" /></p>
<p><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205416481-508450694.png" alt="" /></p>
<p><span style="font-family: 楷体; font-size: 14pt;">&nbsp;&nbsp;&nbsp;&nbsp;至此，我们已经实现了A用户在公司外部远程连接C机器的需求，接下来我们就来讲一讲实现过程： </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">　　data &lt;- -&gt; sshsrv:9527端口 &lt;- -&gt; sshsrv:22（通过ssh封装） &lt;- -&gt; localhost:XXXXX（随机在客户端6开一个端口） &lt;- -&gt; localhost:YYYYY（服务器解封装，开一个端口，代表telnet客户端） &lt;- -&gt; telnetsrv:23 </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">　　用大白话来解释就是：当rhel5（A用户）连接自己的9527端口时，该请求自然会通过ssh协议封装发送给centos6（B机器），然后在centos6（C机器）上解封装,形成telnet流量，发送给centos7（C机器）。 </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">　　实验做完了，如果我们想要停止这个隧道，直接把后台的隧道进程杀死就可以了，命令如下： </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;"><strong>　　killall ssh </strong></span></p>
<p><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205425247-2126441723.png" alt="" /></p>
<p><span style="font-size: 14pt;"><span style="font-family: 楷体;">　　我们的实验圆满完成ヾ(</span><span style="font-family: MS Mincho;">✿</span><span style="font-family: 微软雅黑;">ﾟ</span><span style="font-family: 楷体;">▽</span><span style="font-family: 微软雅黑;">ﾟ</span><span style="font-family: 楷体;">)ノ </span></span></p>
<p>&nbsp;</p>
<h1>四、动态转发</h1>
<p><span style="font-family: 楷体; font-size: 14pt;">　　众所周知，我国有一个功能强大的防火墙，用来避免我们访问谷歌等外国的部分网站，嗯。。。翻墙的方法有很多，相信大家不比小编懂的少，所以我们就不一一举例说明了。接下来，小编就给大家说一说如何通过ssh转发技术实现翻墙~ </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">　　这里，就要用到我们的动态转发技术了：</span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">　　当用firefox 访问internet 时，本机的1080 端口做为代理服务器，firefox 的访问请求被转发到sshserver 上，由sshserver替之访问internet。 </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">　　接下来，我们还是以实验进行说明： </span></p>
<h2>实验三、实现SSH端口转发&mdash;&mdash;动态转发</h2>
<ul>
<li>
<div style="text-align: justify;"><span style="font-family: 楷体; font-size: 14pt;"><strong>背景：</strong>模拟Google的服务器C不允许国内网站A直接访问，B服务器是国外的一个小型的学习用的服务器；国内网站A可以访问国外学习服务器B；实现国内网站A访问模拟Google服务器C。 </span></div>
</li>
<li>
<div style="text-align: justify;"><span style="font-family: 楷体; font-size: 14pt;"><strong>原理：</strong>国内网站A通过ssh协议连接到国外学习服务器B上，再通过国外学习服务器B做跳板，连接至Google服务器C。 </span></div>
</li>
<li>
<div style="text-align: justify;"><span style="font-family: 楷体; font-size: 14pt;"><strong>机器：</strong>centos6模拟国内网站A，rhel5模拟国外学习服务器B，centos7模拟Google服务器C </span></div>
</li>
<li>
<div style="text-align: justify;"><span style="font-family: 楷体; font-size: 14pt;"><strong>图示如下：</strong> </span></div>
</li>
</ul>
<p><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205432215-1263045591.png" alt="" /></p>
<ul>
<li>
<div style="text-align: justify;"><span style="font-family: 楷体; font-size: 14pt;"><strong>实验步骤： </strong></span></div>
</li>
</ul>
<p><span style="font-family: 楷体; font-size: 14pt;">1）在模拟google服务器C上搭建一个网页，从互联网上访问centos7时，页面显示"Welcome to www.google.com" </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">　　命令如下： </span></p>
<div class="cnblogs_code">
<pre>[root@centos7 ~]# cd /var/www/html/<span style="color: #000000;">
[root@centos7 html]# vim index.html
</span>&lt;h1&gt; Welcome to www.google.com &lt;/h1&gt; </pre>
</div>
<p><span style="font-family: 楷体; font-size: 14pt;">&nbsp;&nbsp;&nbsp;&nbsp;编写完文件以后，记得重启一下httpd服务： </span></p>
<div class="cnblogs_code">
<pre>[root@centos7 html]# systemctl restart httpd </pre>
</div>
<p><span style="font-family: 楷体; font-size: 14pt;">2）模拟Google服务器C不允许国内网站A连接 </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">　　在centos7上输入以下口令： </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;"><strong>　　[root@centos7 ~]# iptables -A INPUT -s 192.168.191.66 -j REJECT</strong> </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">　　此时，我们来测试一下centos6和rhel5能否访问centos7，命令为： </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;"><strong>　　curl 192.168.191.77 </strong> 或 <strong>links 192.168.191.77</strong> </span></p>
<div class="cnblogs_code">
<pre>[root@rhel5 ~]# curl <span style="color: #800080;">192.168</span>.<span style="color: #800080;">191.77</span>
&lt;h1&gt; Welcome to www.google.com &lt;/h1&gt;<span style="color: #000000;">

 
[root@centos6 </span>~]# curl <span style="color: #800080;">192.168</span>.<span style="color: #800080;">191.77</span><span style="color: #000000;">
curl: (</span><span style="color: #800080;">7</span>) couldn<span style="color: #800000;">'</span><span style="color: #800000;">t connect to host </span></pre>
</div>
<p><span style="font-family: 楷体; font-size: 14pt;">　　可以看出，rhel5可以连接到centos7，但是centos6不能连接到centos7。我们现在的需求就是希望centos6可以借助于rhel5访问centos7，方法也很简单，接下来就给大家说一说。 </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">3）动态端口转发 </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">&nbsp;&nbsp;&nbsp;&nbsp;首先，我们在6机器上确认已经开启的端口有哪些： </span></p>
<p><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205535059-1032039355.png" alt="" /></p>
<p><span style="font-family: 楷体; font-size: 14pt;">　　我们使用1080端口，从上图中我么已经看出，1080端口没有被占用，所以我们可以使用~ </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">　　接着我们建立动态转发的隧道（6上输入以下命令）： </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;"><strong>　　ssh <span style="color: #df402a;">-D </span>1080 -fN 192.168.191.55</strong> </span></p>
<p><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205541669-2100046067.png" alt="" /></p>
<p><span style="font-family: 楷体; font-size: 14pt;">&nbsp;&nbsp;&nbsp;&nbsp;在这里，我们可以在rhel5上查看到centos6的连接： </span></p>
<p><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205548340-494872131.png" alt="" /></p>
<p><span style="font-family: 楷体; font-size: 14pt;">4）设置代理rhel5访问centos7，命令如下（在centos6上输入）： </span></p>
<p><span style="font-family: 楷体; font-size: 14pt;"><strong>　　curl --socks5 127.0.0.1:1080 http://192.168.191.77</strong></span></p>
<p><span style="font-family: 楷体; font-size: 14pt;"><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205555278-1023160986.png" alt="" /></span></p>
<p><span style="font-family: 楷体; font-size: 14pt;">5）在图形化界面，在centos6上的firefox浏览器设置代理： </span></p>
<p><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205601419-1786576273.png" alt="" /></p>
<p><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205607122-1134889932.png" alt="" /></p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205615356-509324349.png" alt="" /></p>
<p><img src="https://images2017.cnblogs.com/blog/1204916/201709/1204916-20170929205624606-1436174155.png" alt="" /></p>
<p><span style="font-size: 14pt;"><span style="font-family: 楷体;">　　我们的实验圆满完成ヾ(</span><span style="font-family: MS Mincho;">✿</span><span style="font-family: 微软雅黑;">ﾟ</span><span style="font-family: 楷体;">▽</span><span style="font-family: 微软雅黑;">ﾟ</span><span style="font-family: 楷体;">)ノ </span></span></p>
<p>&nbsp;</p>
</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
	<div class="postDesc">posted on 
<span id="post-date">2017-09-29 20:58</span>&nbsp;<a href="https://www.cnblogs.com/keerya/">珂儿吖</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>) <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7612715" rel="nofollow"> 编辑</a> <a href="javascript:void(0)" onclick="AddToWz(7612715); return false;">收藏</a>
</div>
</div>


<script src="https://common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 368867, cb_blogApp = 'keerya', cb_blogUserGuid = 'b65ff178-7cd6-41e3-36bc-08d49c352df3';
    var cb_entryId = 7612715, cb_entryCreatedDate = '2017-09-29 20:58', cb_postType = 1; 
    loadViewCount(cb_entryId);
</script><a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<script>
    var commentManager = new blogCommentManager();
    commentManager.renderComments(0);
</script>

<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <script async="async" src="https://www.googletagservices.com/tag/js/gpt.js"></script>
    <script>
        var googletag = googletag || {};
        googletag.cmd = googletag.cmd || [];
    </script>
    <script>
        googletag.cmd.push(function () {
            googletag.defineSlot("/1090369/C1", [300, 250], "div-gpt-ad-1546353474406-0").addService(googletag.pubads());
            googletag.defineSlot("/1090369/C2", [468, 60], "div-gpt-ad-1539008685004-0").addService(googletag.pubads());
            googletag.pubads().enableSingleRequest();
            googletag.enableServices();
        });
    </script>
    <div id="cnblogs_c1" class="c_ad_block">
        <div id="div-gpt-ad-1546353474406-0" style="height:250px; width:300px;"></div>
    </div>
    <div id="under_post_news"></div>
    <div id="cnblogs_c2" class="c_ad_block">
        <div id="div-gpt-ad-1539008685004-0" style="height:60px; width:468px;">
            <script>
                if (new Date() >= new Date(2018, 9, 13)) {
                    googletag.cmd.push(function () { googletag.display("div-gpt-ad-1539008685004-0"); });
                }
            </script>
        </div>
    </div>
    <div id="under_post_kb"></div>
    <div id="HistoryToday" class="c_ad_block"></div>
    <script type="text/javascript">
        fixPostBody();
        setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
        deliverAdT2();
        deliverAdC1();
        deliverAdC2();
        loadNewsAndKb();
        loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
        loadOptUnderPost();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div></div>


			</div>
		</div>
	</div>
	<!-- right ends -->
	<!-- left starts -->
	<div id="left">
		<!-- 左侧工具部分 -->
		<div id="left_content">
			<div id="calendar"><div id="calendar"><div id="blog-calendar" style="display:none"></div></div>                
                    <script>loadBlogDefaultCalendar();</script></div>
			
<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>

			
				<DIV id="leftcontentcontainer">
					<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
				</DIV>
			
		</div>
		<!-- //右侧工具部分 -->
	</div>
	<!-- left ends -->	
	<div class="clear"></div>
</div>
<div id="footer">
	<!--done-->
Copyright &copy; 2019 珂儿吖
<br /><span id="poweredby">Powered by .NET Core 3.0.0 on Linux</span>



</div>


    
</body>
</html>
